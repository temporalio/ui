{
  "openapi": "3.0.3",
  "info": {
    "title": "",
    "version": "0.0.1"
  },
  "paths": {
    "/api/v1/cluster-info": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetClusterInfo returns information about temporal cluster",
        "operationId": "GetClusterInfo",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetClusterInfoResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "ListNamespaces",
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "in": "query",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\n Setting include_deleted to true will include deleted namespaces.\n Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNamespacesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "RegisterNamespace creates a new namespace which can be used as a container for all resources.\n\n A Namespace is a top level entity within Temporal, and is used as a container for resources\n like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\n isolation for all resources within the namespace. All resources belongs to exactly one\n namespace.",
        "operationId": "RegisterNamespace",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterNamespaceRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisterNamespaceResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "DescribeNamespace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeNamespaceResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/cancel": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RespondActivityTaskFailed is called by workers when processing an activity task fails.\n\n This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history\n and a new workflow task created for the workflow. Fails with `NotFound` if the task token is\n no longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCanceled",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCanceledRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCanceledResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/cancel-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskCanceled`. This version allows clients to record failures by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RespondActivityTaskCanceledById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCanceledByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCanceledByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/complete": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RespondActivityTaskCompleted is called by workers when they successfully complete an activity\n task.\n\n This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history\n and a new workflow task created for the workflow. Fails with `NotFound` if the task token is\n no longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCompleted",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCompletedRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCompletedResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/complete-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskCompleted`. This version allows clients to record completions by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RespondActivityTaskCompletedById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCompletedByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCompletedByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/fail": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RespondActivityTaskFailed is called by workers when processing an activity task fails.\n\n This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and\n a new workflow task created for the workflow. Fails with `NotFound` if the task token is no\n longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskFailed",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskFailedRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskFailedResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/fail-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskFailed`. This version allows clients to record failures by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RespondActivityTaskFailedById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskFailedByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskFailedByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/heartbeat": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.\n\n If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,\n then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to\n the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in\n such situations, in that event, the SDK should request cancellation of the activity.",
        "operationId": "RecordActivityTaskHeartbeat",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecordActivityTaskHeartbeatRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordActivityTaskHeartbeatResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/heartbeat-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RecordActivityTaskHeartbeatById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecordActivityTaskHeartbeatByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordActivityTaskHeartbeatByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/pause": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "PauseActivity pauses the execution of an activity specified by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be paused\n\n Pausing an activity means:\n - If the activity is currently waiting for a retry or is running and subsequently fails,\n   it will not be rescheduled until it is unpaused.\n - If the activity is already paused, calling this method will have no effect.\n - If the activity is running and finishes successfully, the activity will be completed.\n - If the activity is running and finishes with failure:\n   * if there is no retry left - the activity will be completed.\n   * if there are more retries left - the activity will be paused.\n For long-running activities:\n - activities in paused state will send a cancellation with \"activity_paused\" set to 'true' in response to 'RecordActivityTaskHeartbeat'.\n - The activity should respond to the cancellation accordingly.\n\n Returns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "PauseActivity",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PauseActivityRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PauseActivityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/reset": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "ResetActivity resets the execution of an activity specified by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be reset.\n\n Resetting an activity means:\n * number of attempts will be reset to 0.\n * activity timeouts will be reset.\n * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:\n    it will be scheduled immediately (* see 'jitter' flag),\n\n Flags:\n\n 'jitter': the activity will be scheduled at a random time within the jitter duration.\n If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.\n 'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.\n 'keep_paused': if the activity is paused, it will remain paused.\n\n Returns a `NotFound` error if there is no pending activity with the provided ID or type.",
        "operationId": "ResetActivity",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResetActivityRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResetActivityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/unpause": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UnpauseActivity unpauses the execution of an activity specified by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be unpaused.\n\n If activity is not paused, this call will have no effect.\n If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).\n Once the activity is unpaused, all timeout timers will be regenerated.\n\n Flags:\n 'jitter': the activity will be scheduled at a random time within the jitter duration.\n 'reset_attempts': the number of attempts will be reset.\n 'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.\n\n Returns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "UnpauseActivity",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnpauseActivityRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnpauseActivityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/activities/update-options": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be updated.",
        "operationId": "UpdateActivityOptions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateActivityOptionsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateActivityOptionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/archived-workflows": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "ListArchivedWorkflowExecutions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListArchivedWorkflowExecutionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListBatchOperations returns a list of batch operations",
        "operationId": "ListBatchOperations",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "List page size",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "Next page token",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBatchOperationsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations/{jobId}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "DescribeBatchOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "Batch job id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeBatchOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "StartBatchOperation starts a new batch operation",
        "operationId": "StartBatchOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "Job ID defines the unique ID for the batch job",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartBatchOperationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartBatchOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations/{jobId}/stop": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "StopBatchOperation stops a batch operation",
        "operationId": "StopBatchOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "Batch job id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopBatchOperationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopBatchOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/current-deployment/{deployment.series_name}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Sets a deployment as the current deployment for its deployment series. Can optionally update\n the metadata of the deployment as well.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.",
        "operationId": "SetCurrentDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.series_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetCurrentDeploymentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetCurrentDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/current-deployment/{seriesName}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Returns the current deployment (and its info) for a given deployment series.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.",
        "operationId": "GetCurrentDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "seriesName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetCurrentDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/deployments": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Lists worker deployments in the namespace. Optionally can filter based on deployment series\n name.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced with `ListWorkerDeployments`.",
        "operationId": "ListDeployments",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "seriesName",
            "in": "query",
            "description": "Optional. Use to filter based on exact series name match.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDeploymentsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Describes a worker deployment.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.",
        "operationId": "DescribeDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.series_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.build_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.seriesName",
            "in": "query",
            "description": "Different versions of the same worker service/application are related together by having a\n shared series name.\n Out of all deployments of a series, one can be designated as the current deployment, which\n receives new workflow executions and new tasks of workflows with\n `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.buildId",
            "in": "query",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\n changes.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}/reachability": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Returns the reachability level of a worker deployment to help users decide when it is time\n to decommission a deployment. Reachability level is calculated based on the deployment's\n `status` and existing workflows that depend on the given deployment for their execution.\n Calculating reachability is relatively expensive. Therefore, server might return a recently\n cached value. In such a case, the `last_update_time` will inform you about the actual\n reachability calculation time.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.",
        "operationId": "GetDeploymentReachability",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.series_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.build_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.seriesName",
            "in": "query",
            "description": "Different versions of the same worker service/application are related together by having a\n shared series name.\n Out of all deployments of a series, one can be designated as the current deployment, which\n receives new workflow executions and new tasks of workflows with\n `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.buildId",
            "in": "query",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\n changes.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDeploymentReachabilityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/schedules": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "List all schedules in a namespace.",
        "operationId": "ListSchedules",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace to list schedules in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "description": "How many to return at once.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "Token to get the next page of results.",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "query",
            "in": "query",
            "description": "Query to filter schedules.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSchedulesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "DescribeSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to describe.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to describe.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "Creates a new schedule.",
        "operationId": "CreateSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace the schedule should be created in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the new schedule.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateScheduleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Deletes a schedule, removing it from the system.",
        "operationId": "DeleteSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "identity",
            "in": "query",
            "description": "The identity of the client who initiated this request.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/matching-times": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Lists matching times within a range.",
        "operationId": "ListScheduleMatchingTimes",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to query.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to query.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "startTime",
            "in": "query",
            "description": "Time range to query.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "endTime",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListScheduleMatchingTimesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/patch": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Makes a specific change to a schedule or triggers an immediate action.",
        "operationId": "PatchSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to patch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to patch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchScheduleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PatchScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/update": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Changes the configuration or state of an existing schedule.",
        "operationId": "UpdateSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateScheduleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/search-attributes": {
      "get": {
        "tags": ["OperatorService"],
        "description": "ListSearchAttributes returns comprehensive information about search attributes.",
        "operationId": "ListSearchAttributes",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSearchAttributesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Deprecated. Use `GetWorkerVersioningRules`.\n Fetches the worker build id versioning sets for a task queue.",
        "operationId": "GetWorkerBuildIdCompatibility",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue",
            "in": "path",
            "description": "Must be set, the task queue to interrogate about worker id compatibility.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maxSets",
            "in": "query",
            "description": "Limits how many compatible sets will be returned. Specify 1 to only return the current\n default major version set. 0 returns all sets.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkerBuildIdCompatibilityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Fetches the Build ID assignment and redirect rules for a Task Queue.\n WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.",
        "operationId": "GetWorkerVersioningRules",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkerVersioningRulesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{task_queue.name}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:\n   - List of pollers\n   - Workflow Reachability status\n   - Backlog info for Workflow and/or Activity tasks",
        "operationId": "DescribeTaskQueue",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "task_queue.name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue.name",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue.kind",
            "in": "query",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.",
            "schema": {
              "enum": [
                "TASK_QUEUE_KIND_UNSPECIFIED",
                "TASK_QUEUE_KIND_NORMAL",
                "TASK_QUEUE_KIND_STICKY"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "taskQueue.normalName",
            "in": "query",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\n the normal task queue that the sticky worker is running on.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueueType",
            "in": "query",
            "description": "Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.\n If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.",
            "schema": {
              "enum": [
                "TASK_QUEUE_TYPE_UNSPECIFIED",
                "TASK_QUEUE_TYPE_WORKFLOW",
                "TASK_QUEUE_TYPE_ACTIVITY",
                "TASK_QUEUE_TYPE_NEXUS"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "includeTaskQueueStatus",
            "in": "query",
            "description": "Deprecated. Ignored in `ENHANCED` mode.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "apiMode",
            "in": "query",
            "description": "All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode.",
            "schema": {
              "enum": [
                "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
                "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "versions.buildIds",
            "in": "query",
            "description": "Include specific Build IDs.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "versions.unversioned",
            "in": "query",
            "description": "Include the unversioned queue.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "versions.allActive",
            "in": "query",
            "description": "Include all active versions. A version is considered active if, in the last few minutes,\n it has had new tasks or polls, or it has been the subject of certain task queue API calls.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "taskQueueTypes",
            "in": "query",
            "description": "Task queue types to report info about. If not specified, all types are considered.",
            "schema": {
              "type": "array",
              "items": {
                "enum": [
                  "TASK_QUEUE_TYPE_UNSPECIFIED",
                  "TASK_QUEUE_TYPE_WORKFLOW",
                  "TASK_QUEUE_TYPE_ACTIVITY",
                  "TASK_QUEUE_TYPE_NEXUS"
                ],
                "type": "string",
                "format": "enum"
              }
            }
          },
          {
            "name": "reportStats",
            "in": "query",
            "description": "Report stats for the requested task queue types and versions",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "reportPollers",
            "in": "query",
            "description": "Report list of pollers for requested task queue types and versions",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "reportTaskReachability",
            "in": "query",
            "description": "Report task reachability for the requested versions and all task types (task reachability is not reported\n per task type).",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeTaskQueueResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/update": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UpdateNamespace is used to update the information and configuration of a registered\n namespace.",
        "operationId": "UpdateNamespace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNamespaceRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateNamespaceResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployment-versions/{version}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Describes a worker deployment version.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeploymentVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkerDeploymentVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Used for manual deletion of Versions. User can delete a Version only when all the\n following conditions are met:\n  - It is not the Current or Ramping Version of its Deployment.\n  - It has no active pollers (none of the task queues in the Version have pollers)\n  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition\n    can be skipped by passing `skip-drainage=true`.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeploymentVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "skipDrainage",
            "in": "query",
            "description": "Pass to force deletion even if the Version is draining. In this case the open pinned\n workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "identity",
            "in": "query",
            "description": "Optional. The identity of the client who initiated this request.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWorkerDeploymentVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployment-versions/{version}/update-metadata": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Updates the user-given metadata attached to a Worker Deployment Version.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "UpdateWorkerDeploymentVersionMetadata",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkerDeploymentVersionMetadataRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkerDeploymentVersionMetadataResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Lists all Worker Deployments that are tracked in the Namespace.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "ListWorkerDeployments",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListWorkerDeploymentsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Describes a Worker Deployment.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkerDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Deletes records of (an old) Deployment. A deployment can only be deleted if\n it has no Version in it.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "identity",
            "in": "query",
            "description": "Optional. The identity of the client who initiated this request.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWorkerDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping\n Version if it is the Version being set as Current.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentCurrentVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetWorkerDeploymentCurrentVersionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetWorkerDeploymentCurrentVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for\n gradual ramp to unversioned workers too.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentRampingVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetWorkerDeploymentRampingVersionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetWorkerDeploymentRampingVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/worker-task-reachability": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Deprecated. Use `DescribeTaskQueue`.\n\n Fetches task reachability to determine whether a worker may be retired.\n The request may specify task queues to query for or let the server fetch all task queues mapped to the given\n build IDs.\n\n When requesting a large number of task queues or all task queues associated with the given build ids in a\n namespace, all task queues will be listed in the response but some of them may not contain reachability\n information due to a server enforced limit. When reaching the limit, task queues that reachability information\n could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\n another call to get the reachability for those task queues.\n\n Open source users can adjust this limit by setting the server's dynamic config value for\n `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.",
        "operationId": "GetWorkerTaskReachability",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "buildIds",
            "in": "query",
            "description": "Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.\n The number of build ids that can be queried in a single API call is limited.\n Open source users can adjust this limit by setting the server's dynamic config value for\n `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "taskQueues",
            "in": "query",
            "description": "Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given\n build ids in the namespace.\n Must specify at least one task queue if querying for an unversioned worker.\n The number of task queues that the server will fetch reachability information for is limited.\n See the `GetWorkerTaskReachabilityResponse` documentation for more information.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "reachability",
            "in": "query",
            "description": "Type of reachability to query for.\n `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.\n Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.\n Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left\n unspecified.\n See the TaskReachability docstring for information about each enum variant.",
            "schema": {
              "enum": [
                "TASK_REACHABILITY_UNSPECIFIED",
                "TASK_REACHABILITY_NEW_WORKFLOWS",
                "TASK_REACHABILITY_EXISTING_WORKFLOWS",
                "TASK_REACHABILITY_OPEN_WORKFLOWS",
                "TASK_REACHABILITY_CLOSED_WORKFLOWS"
              ],
              "type": "string",
              "format": "enum"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkerTaskReachabilityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-count": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "CountWorkflowExecutions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountWorkflowExecutionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-rules": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Return all namespace workflow rules",
        "operationId": "ListWorkflowRules",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListWorkflowRulesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "Create a new workflow rule. The rules are used to control the workflow execution.\n The rule will be applied to all running and new workflows in the namespace.\n If the rule with such ID already exist this call will fail\n Note: the rules are part of namespace configuration and will be stored in the namespace config.\n Namespace config is eventually consistent.",
        "operationId": "CreateWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWorkflowRuleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-rules/{ruleId}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeWorkflowRule return the rule specification for existing rule id.\n If there is no rule with such id - NOT FOUND error will be returned.",
        "operationId": "DescribeWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ruleId",
            "in": "path",
            "description": "User-specified ID of the rule to read. Unique within the namespace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Delete rule by rule id",
        "operationId": "DeleteWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ruleId",
            "in": "path",
            "description": "ID of the rule to delete. Unique within the namespace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "ListWorkflowExecutions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListWorkflowExecutionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/execute-multi-operation": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "ExecuteMultiOperation executes multiple operations within a single workflow.\n\n Operations are started atomically, meaning if *any* operation fails to be started, none are,\n and the request fails. Upon start, the API returns only when *all* operations have a response.\n\n Upon failure, it returns `MultiOperationExecutionFailure` where the status code\n equals the status code of the *first* operation that failed to be started.\n\n NOTE: Experimental API.",
        "operationId": "ExecuteMultiOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteMultiOperationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteMultiOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "DescribeWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.runId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n `NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "GetWorkflowExecutionHistory",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.runId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\n these, it should be passed here to fetch the next page.",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "waitNewEvent",
            "in": "query",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\n the `history_event_filter_type`, or a timeout is hit.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "historyEventFilterType",
            "in": "query",
            "description": "Filter returned events such that they match the specified filter type.\n Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "schema": {
              "enum": [
                "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
                "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
                "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "skipArchival",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowExecutionHistoryResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history-reverse": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \n order (starting from last event). Fails with`NotFound` if the specified workflow execution is \n unknown to the service.",
        "operationId": "GetWorkflowExecutionHistoryReverse",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.runId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowExecutionHistoryReverseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/query/{query.query_type}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "QueryWorkflow",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "query.query_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryWorkflowRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryWorkflowResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/trigger-rule": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "TriggerWorkflowRule allows to:\n  * trigger existing rule for a specific workflow execution;\n  * trigger rule for a specific workflow execution without creating a rule;\n This is useful for one-off operations.",
        "operationId": "TriggerWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TriggerWorkflowRuleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "StartWorkflowExecution starts a new workflow execution.\n\n It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\n also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\n instance already exists with same workflow id.",
        "operationId": "StartWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if\n it isn't yet started.\n\n If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history\n and a workflow task is generated.\n\n If the workflow is not running or not found, then the workflow is created with\n `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a\n workflow task is generated.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"With\" is used to indicate combined operation. --)",
        "operationId": "SignalWithStartWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signalName",
            "in": "path",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignalWithStartWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignalWithStartWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/cancel": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\n a workflow execution.\n\n This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\n workflow history and a new workflow task created for the workflow. It returns success if the requested\n workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.",
        "operationId": "RequestCancelWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestCancelWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestCancelWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/reset": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\n execution instance.\n TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "ResetWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResetWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResetWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/signal/{signalName}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "SignalWorkflowExecution is used to send a signal to a running workflow execution.\n\n This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\n task being created for the execution.",
        "operationId": "SignalWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signalName",
            "in": "path",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignalWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignalWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/terminate": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\n execution instance.",
        "operationId": "TerminateWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerminateWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TerminateWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update-options": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.",
        "operationId": "UpdateWorkflowExecutionOptions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name of the target Workflow.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkflowExecutionOptionsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkflowExecutionOptionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update/{request.input.name}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Invokes the specified Update function on user Workflow code.",
        "operationId": "UpdateWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name of the target Workflow.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "request.input.name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/nexus/endpoints": {
      "get": {
        "tags": ["OperatorService"],
        "description": "List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the\n next_page_token field of the previous response to get the next page of results. An empty next_page_token\n indicates that there are no more results. During pagination, a newly added service with an ID lexicographically\n earlier than the previous page's last endpoint's ID may be missed.",
        "operationId": "ListNexusEndpoints",
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's\n response, the token will be empty if there's no other page.\n Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size.",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.\n (-- api-linter: core::203::field-behavior-required=disabled\n     aip.dev/not-precedent: Not following linter rules. --)",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNexusEndpointsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["OperatorService"],
        "description": "Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of\n ALREADY_EXISTS.\n Returns the created endpoint with its initial version. You may use this version for subsequent updates.",
        "operationId": "CreateNexusEndpoint",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateNexusEndpointRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/nexus/endpoints/{id}": {
      "get": {
        "tags": ["OperatorService"],
        "description": "Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates.",
        "operationId": "GetNexusEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Server-generated unique endpoint ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["OperatorService"],
        "description": "Delete an incoming Nexus service by ID.",
        "operationId": "DeleteNexusEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Server-generated unique endpoint ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "query",
            "description": "Data version for this endpoint. Must match current version.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/nexus/endpoints/{id}/update": {
      "post": {
        "tags": ["OperatorService"],
        "description": "Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or\n `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not\n match.\n Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't\n need to increment the version yourself. The server will increment the version for you after each update.",
        "operationId": "UpdateNexusEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Server-generated unique endpoint ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNexusEndpointRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/system-info": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetSystemInfo returns information about the system.",
        "operationId": "GetSystemInfo",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSystemInfoResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetClusterInfo returns information about temporal cluster",
        "operationId": "GetClusterInfo",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetClusterInfoResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/namespaces": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "ListNamespaces",
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "in": "query",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\n Setting include_deleted to true will include deleted namespaces.\n Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNamespacesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "RegisterNamespace creates a new namespace which can be used as a container for all resources.\n\n A Namespace is a top level entity within Temporal, and is used as a container for resources\n like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\n isolation for all resources within the namespace. All resources belongs to exactly one\n namespace.",
        "operationId": "RegisterNamespace",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RegisterNamespaceRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RegisterNamespaceResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/namespaces/{namespace}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "DescribeNamespace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "id",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeNamespaceResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/namespaces/{namespace}/search-attributes": {
      "get": {
        "tags": ["OperatorService"],
        "description": "ListSearchAttributes returns comprehensive information about search attributes.",
        "operationId": "ListSearchAttributes",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSearchAttributesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/namespaces/{namespace}/update": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UpdateNamespace is used to update the information and configuration of a registered\n namespace.",
        "operationId": "UpdateNamespace",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNamespaceRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateNamespaceResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/nexus/endpoints": {
      "get": {
        "tags": ["OperatorService"],
        "description": "List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the\n next_page_token field of the previous response to get the next page of results. An empty next_page_token\n indicates that there are no more results. During pagination, a newly added service with an ID lexicographically\n earlier than the previous page's last endpoint's ID may be missed.",
        "operationId": "ListNexusEndpoints",
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's\n response, the token will be empty if there's no other page.\n Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size.",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.\n (-- api-linter: core::203::field-behavior-required=disabled\n     aip.dev/not-precedent: Not following linter rules. --)",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNexusEndpointsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["OperatorService"],
        "description": "Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of\n ALREADY_EXISTS.\n Returns the created endpoint with its initial version. You may use this version for subsequent updates.",
        "operationId": "CreateNexusEndpoint",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateNexusEndpointRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/nexus/endpoints/{id}": {
      "get": {
        "tags": ["OperatorService"],
        "description": "Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates.",
        "operationId": "GetNexusEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Server-generated unique endpoint ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["OperatorService"],
        "description": "Delete an incoming Nexus service by ID.",
        "operationId": "DeleteNexusEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Server-generated unique endpoint ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "query",
            "description": "Data version for this endpoint. Must match current version.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/cluster/nexus/endpoints/{id}/update": {
      "post": {
        "tags": ["OperatorService"],
        "description": "Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or\n `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not\n match.\n Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't\n need to increment the version yourself. The server will increment the version for you after each update.",
        "operationId": "UpdateNexusEndpoint",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Server-generated unique endpoint ID.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNexusEndpointRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateNexusEndpointResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/cancel": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RespondActivityTaskFailed is called by workers when processing an activity task fails.\n\n This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history\n and a new workflow task created for the workflow. Fails with `NotFound` if the task token is\n no longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCanceled",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCanceledRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCanceledResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/cancel-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskCanceled`. This version allows clients to record failures by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RespondActivityTaskCanceledById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCanceledByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCanceledByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/complete": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RespondActivityTaskCompleted is called by workers when they successfully complete an activity\n task.\n\n This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history\n and a new workflow task created for the workflow. Fails with `NotFound` if the task token is\n no longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCompleted",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCompletedRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCompletedResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/complete-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskCompleted`. This version allows clients to record completions by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RespondActivityTaskCompletedById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskCompletedByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskCompletedByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/fail": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RespondActivityTaskFailed is called by workers when processing an activity task fails.\n\n This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and\n a new workflow task created for the workflow. Fails with `NotFound` if the task token is no\n longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskFailed",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskFailedRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskFailedResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/fail-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskFailed`. This version allows clients to record failures by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RespondActivityTaskFailedById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RespondActivityTaskFailedByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RespondActivityTaskFailedByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/heartbeat": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.\n\n If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,\n then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to\n the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in\n such situations, in that event, the SDK should request cancellation of the activity.",
        "operationId": "RecordActivityTaskHeartbeat",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecordActivityTaskHeartbeatRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordActivityTaskHeartbeatResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/heartbeat-by-id": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by\n namespace/workflow id/activity id instead of task token.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"By\" is used to indicate request type. --)",
        "operationId": "RecordActivityTaskHeartbeatById",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecordActivityTaskHeartbeatByIdRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RecordActivityTaskHeartbeatByIdResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/pause": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "PauseActivity pauses the execution of an activity specified by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be paused\n\n Pausing an activity means:\n - If the activity is currently waiting for a retry or is running and subsequently fails,\n   it will not be rescheduled until it is unpaused.\n - If the activity is already paused, calling this method will have no effect.\n - If the activity is running and finishes successfully, the activity will be completed.\n - If the activity is running and finishes with failure:\n   * if there is no retry left - the activity will be completed.\n   * if there are more retries left - the activity will be paused.\n For long-running activities:\n - activities in paused state will send a cancellation with \"activity_paused\" set to 'true' in response to 'RecordActivityTaskHeartbeat'.\n - The activity should respond to the cancellation accordingly.\n\n Returns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "PauseActivity",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PauseActivityRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PauseActivityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/reset": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "ResetActivity resets the execution of an activity specified by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be reset.\n\n Resetting an activity means:\n * number of attempts will be reset to 0.\n * activity timeouts will be reset.\n * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:\n    it will be scheduled immediately (* see 'jitter' flag),\n\n Flags:\n\n 'jitter': the activity will be scheduled at a random time within the jitter duration.\n If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.\n 'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.\n 'keep_paused': if the activity is paused, it will remain paused.\n\n Returns a `NotFound` error if there is no pending activity with the provided ID or type.",
        "operationId": "ResetActivity",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResetActivityRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResetActivityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/unpause": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UnpauseActivity unpauses the execution of an activity specified by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be unpaused.\n\n If activity is not paused, this call will have no effect.\n If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).\n Once the activity is unpaused, all timeout timers will be regenerated.\n\n Flags:\n 'jitter': the activity will be scheduled at a random time within the jitter duration.\n 'reset_attempts': the number of attempts will be reset.\n 'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.\n\n Returns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "UnpauseActivity",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnpauseActivityRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnpauseActivityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/activities/update-options": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.\n If there are multiple pending activities of the provided type - all of them will be updated.",
        "operationId": "UpdateActivityOptions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace of the workflow which scheduled this activity",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateActivityOptionsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateActivityOptionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/archived-workflows": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "ListArchivedWorkflowExecutions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListArchivedWorkflowExecutionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/batch-operations": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListBatchOperations returns a list of batch operations",
        "operationId": "ListBatchOperations",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "description": "List page size",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "Next page token",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBatchOperationsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/batch-operations/{jobId}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "DescribeBatchOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "Batch job id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeBatchOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "StartBatchOperation starts a new batch operation",
        "operationId": "StartBatchOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "Job ID defines the unique ID for the batch job",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartBatchOperationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartBatchOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/batch-operations/{jobId}/stop": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "StopBatchOperation stops a batch operation",
        "operationId": "StopBatchOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "Namespace that contains the batch operation",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jobId",
            "in": "path",
            "description": "Batch job id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StopBatchOperationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StopBatchOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/current-deployment/{deployment.series_name}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Sets a deployment as the current deployment for its deployment series. Can optionally update\n the metadata of the deployment as well.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.",
        "operationId": "SetCurrentDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.series_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetCurrentDeploymentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetCurrentDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/current-deployment/{seriesName}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Returns the current deployment (and its info) for a given deployment series.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.",
        "operationId": "GetCurrentDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "seriesName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetCurrentDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/deployments": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Lists worker deployments in the namespace. Optionally can filter based on deployment series\n name.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced with `ListWorkerDeployments`.",
        "operationId": "ListDeployments",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "seriesName",
            "in": "query",
            "description": "Optional. Use to filter based on exact series name match.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDeploymentsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Describes a worker deployment.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced with `DescribeWorkerDeploymentVersion`.",
        "operationId": "DescribeDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.series_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.build_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.seriesName",
            "in": "query",
            "description": "Different versions of the same worker service/application are related together by having a\n shared series name.\n Out of all deployments of a series, one can be designated as the current deployment, which\n receives new workflow executions and new tasks of workflows with\n `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.buildId",
            "in": "query",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\n changes.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/deployments/{deployment.series_name}/{deployment.build_id}/reachability": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Returns the reachability level of a worker deployment to help users decide when it is time\n to decommission a deployment. Reachability level is calculated based on the deployment's\n `status` and existing workflows that depend on the given deployment for their execution.\n Calculating reachability is relatively expensive. Therefore, server might return a recently\n cached value. In such a case, the `last_update_time` will inform you about the actual\n reachability calculation time.\n Experimental. This API might significantly change or be removed in a future release.\n Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.",
        "operationId": "GetDeploymentReachability",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.series_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.build_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.seriesName",
            "in": "query",
            "description": "Different versions of the same worker service/application are related together by having a\n shared series name.\n Out of all deployments of a series, one can be designated as the current deployment, which\n receives new workflow executions and new tasks of workflows with\n `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deployment.buildId",
            "in": "query",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\n changes.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetDeploymentReachabilityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/schedules": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "List all schedules in a namespace.",
        "operationId": "ListSchedules",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace to list schedules in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "description": "How many to return at once.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "Token to get the next page of results.",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "query",
            "in": "query",
            "description": "Query to filter schedules.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListSchedulesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "DescribeSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to describe.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to describe.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "Creates a new schedule.",
        "operationId": "CreateSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace the schedule should be created in.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the new schedule.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateScheduleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Deletes a schedule, removing it from the system.",
        "operationId": "DeleteSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to delete.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "identity",
            "in": "query",
            "description": "The identity of the client who initiated this request.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/matching-times": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Lists matching times within a range.",
        "operationId": "ListScheduleMatchingTimes",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to query.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to query.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "startTime",
            "in": "query",
            "description": "Time range to query.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "endTime",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListScheduleMatchingTimesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/patch": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Makes a specific change to a schedule or triggers an immediate action.",
        "operationId": "PatchSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to patch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to patch.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PatchScheduleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PatchScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/update": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Changes the configuration or state of an existing schedule.",
        "operationId": "UpdateSchedule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace of the schedule to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "scheduleId",
            "in": "path",
            "description": "The id of the schedule to update.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateScheduleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateScheduleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Deprecated. Use `GetWorkerVersioningRules`.\n Fetches the worker build id versioning sets for a task queue.",
        "operationId": "GetWorkerBuildIdCompatibility",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue",
            "in": "path",
            "description": "Must be set, the task queue to interrogate about worker id compatibility.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maxSets",
            "in": "query",
            "description": "Limits how many compatible sets will be returned. Specify 1 to only return the current\n default major version set. 0 returns all sets.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkerBuildIdCompatibilityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Fetches the Build ID assignment and redirect rules for a Task Queue.\n WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.",
        "operationId": "GetWorkerVersioningRules",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkerVersioningRulesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/task-queues/{task_queue.name}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:\n   - List of pollers\n   - Workflow Reachability status\n   - Backlog info for Workflow and/or Activity tasks",
        "operationId": "DescribeTaskQueue",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "task_queue.name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue.name",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueue.kind",
            "in": "query",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.",
            "schema": {
              "enum": [
                "TASK_QUEUE_KIND_UNSPECIFIED",
                "TASK_QUEUE_KIND_NORMAL",
                "TASK_QUEUE_KIND_STICKY"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "taskQueue.normalName",
            "in": "query",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\n the normal task queue that the sticky worker is running on.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "taskQueueType",
            "in": "query",
            "description": "Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.\n If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.",
            "schema": {
              "enum": [
                "TASK_QUEUE_TYPE_UNSPECIFIED",
                "TASK_QUEUE_TYPE_WORKFLOW",
                "TASK_QUEUE_TYPE_ACTIVITY",
                "TASK_QUEUE_TYPE_NEXUS"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "includeTaskQueueStatus",
            "in": "query",
            "description": "Deprecated. Ignored in `ENHANCED` mode.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "apiMode",
            "in": "query",
            "description": "All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode.",
            "schema": {
              "enum": [
                "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
                "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "versions.buildIds",
            "in": "query",
            "description": "Include specific Build IDs.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "versions.unversioned",
            "in": "query",
            "description": "Include the unversioned queue.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "versions.allActive",
            "in": "query",
            "description": "Include all active versions. A version is considered active if, in the last few minutes,\n it has had new tasks or polls, or it has been the subject of certain task queue API calls.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "taskQueueTypes",
            "in": "query",
            "description": "Task queue types to report info about. If not specified, all types are considered.",
            "schema": {
              "type": "array",
              "items": {
                "enum": [
                  "TASK_QUEUE_TYPE_UNSPECIFIED",
                  "TASK_QUEUE_TYPE_WORKFLOW",
                  "TASK_QUEUE_TYPE_ACTIVITY",
                  "TASK_QUEUE_TYPE_NEXUS"
                ],
                "type": "string",
                "format": "enum"
              }
            }
          },
          {
            "name": "reportStats",
            "in": "query",
            "description": "Report stats for the requested task queue types and versions",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "reportPollers",
            "in": "query",
            "description": "Report list of pollers for requested task queue types and versions",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "reportTaskReachability",
            "in": "query",
            "description": "Report task reachability for the requested versions and all task types (task reachability is not reported\n per task type).",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeTaskQueueResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-deployment-versions/{version}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Describes a worker deployment version.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeploymentVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkerDeploymentVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Used for manual deletion of Versions. User can delete a Version only when all the\n following conditions are met:\n  - It is not the Current or Ramping Version of its Deployment.\n  - It has no active pollers (none of the task queues in the Version have pollers)\n  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition\n    can be skipped by passing `skip-drainage=true`.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeploymentVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "skipDrainage",
            "in": "query",
            "description": "Pass to force deletion even if the Version is draining. In this case the open pinned\n workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "identity",
            "in": "query",
            "description": "Optional. The identity of the client who initiated this request.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWorkerDeploymentVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-deployment-versions/{version}/update-metadata": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Updates the user-given metadata attached to a Worker Deployment Version.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "UpdateWorkerDeploymentVersionMetadata",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "version",
            "in": "path",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkerDeploymentVersionMetadataRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkerDeploymentVersionMetadataResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-deployments": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Lists all Worker Deployments that are tracked in the Namespace.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "ListWorkerDeployments",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListWorkerDeploymentsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-deployments/{deploymentName}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Describes a Worker Deployment.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkerDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Deletes records of (an old) Deployment. A deployment can only be deleted if\n it has no Version in it.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeployment",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "identity",
            "in": "query",
            "description": "Optional. The identity of the client who initiated this request.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWorkerDeploymentResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping\n Version if it is the Version being set as Current.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentCurrentVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetWorkerDeploymentCurrentVersionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetWorkerDeploymentCurrentVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for\n gradual ramp to unversioned workers too.\n Experimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentRampingVersion",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SetWorkerDeploymentRampingVersionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SetWorkerDeploymentRampingVersionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/worker-task-reachability": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Deprecated. Use `DescribeTaskQueue`.\n\n Fetches task reachability to determine whether a worker may be retired.\n The request may specify task queues to query for or let the server fetch all task queues mapped to the given\n build IDs.\n\n When requesting a large number of task queues or all task queues associated with the given build ids in a\n namespace, all task queues will be listed in the response but some of them may not contain reachability\n information due to a server enforced limit. When reaching the limit, task queues that reachability information\n could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\n another call to get the reachability for those task queues.\n\n Open source users can adjust this limit by setting the server's dynamic config value for\n `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.",
        "operationId": "GetWorkerTaskReachability",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "buildIds",
            "in": "query",
            "description": "Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.\n The number of build ids that can be queried in a single API call is limited.\n Open source users can adjust this limit by setting the server's dynamic config value for\n `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "taskQueues",
            "in": "query",
            "description": "Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given\n build ids in the namespace.\n Must specify at least one task queue if querying for an unversioned worker.\n The number of task queues that the server will fetch reachability information for is limited.\n See the `GetWorkerTaskReachabilityResponse` documentation for more information.",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "reachability",
            "in": "query",
            "description": "Type of reachability to query for.\n `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.\n Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.\n Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left\n unspecified.\n See the TaskReachability docstring for information about each enum variant.",
            "schema": {
              "enum": [
                "TASK_REACHABILITY_UNSPECIFIED",
                "TASK_REACHABILITY_NEW_WORKFLOWS",
                "TASK_REACHABILITY_EXISTING_WORKFLOWS",
                "TASK_REACHABILITY_OPEN_WORKFLOWS",
                "TASK_REACHABILITY_CLOSED_WORKFLOWS"
              ],
              "type": "string",
              "format": "enum"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkerTaskReachabilityResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflow-count": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "CountWorkflowExecutions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CountWorkflowExecutionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflow-rules": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "Return all namespace workflow rules",
        "operationId": "ListWorkflowRules",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListWorkflowRulesResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["WorkflowService"],
        "description": "Create a new workflow rule. The rules are used to control the workflow execution.\n The rule will be applied to all running and new workflows in the namespace.\n If the rule with such ID already exist this call will fail\n Note: the rules are part of namespace configuration and will be stored in the namespace config.\n Namespace config is eventually consistent.",
        "operationId": "CreateWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateWorkflowRuleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflow-rules/{ruleId}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeWorkflowRule return the rule specification for existing rule id.\n If there is no rule with such id - NOT FOUND error will be returned.",
        "operationId": "DescribeWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ruleId",
            "in": "path",
            "description": "User-specified ID of the rule to read. Unique within the namespace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["WorkflowService"],
        "description": "Delete rule by rule id",
        "operationId": "DeleteWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "ruleId",
            "in": "path",
            "description": "ID of the rule to delete. Unique within the namespace.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DeleteWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "ListWorkflowExecutions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "query",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListWorkflowExecutionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/execute-multi-operation": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "ExecuteMultiOperation executes multiple operations within a single workflow.\n\n Operations are started atomically, meaning if *any* operation fails to be started, none are,\n and the request fails. Upon start, the API returns only when *all* operations have a response.\n\n Upon failure, it returns `MultiOperationExecutionFailure` where the status code\n equals the status code of the *first* operation that failed to be started.\n\n NOTE: Experimental API.",
        "operationId": "ExecuteMultiOperation",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteMultiOperationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteMultiOperationResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflow_id}": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "DescribeWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.runId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflow_id}/history": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n `NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "GetWorkflowExecutionHistory",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.runId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\n these, it should be passed here to fetch the next page.",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          },
          {
            "name": "waitNewEvent",
            "in": "query",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\n the `history_event_filter_type`, or a timeout is hit.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "historyEventFilterType",
            "in": "query",
            "description": "Filter returned events such that they match the specified filter type.\n Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "schema": {
              "enum": [
                "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
                "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
                "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
              ],
              "type": "string",
              "format": "enum"
            }
          },
          {
            "name": "skipArchival",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowExecutionHistoryResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflow_id}/history-reverse": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \n order (starting from last event). Fails with`NotFound` if the specified workflow execution is \n unknown to the service.",
        "operationId": "GetWorkflowExecutionHistoryReverse",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflowId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.runId",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "bytes"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetWorkflowExecutionHistoryReverseResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflow_id}/query/{query.query_type}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "QueryWorkflow",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "query.query_type",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QueryWorkflowRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/QueryWorkflowResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflow_id}/trigger-rule": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "TriggerWorkflowRule allows to:\n  * trigger existing rule for a specific workflow execution;\n  * trigger rule for a specific workflow execution without creating a rule;\n This is useful for one-off operations.",
        "operationId": "TriggerWorkflowRule",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TriggerWorkflowRuleRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerWorkflowRuleResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflowId}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "StartWorkflowExecution starts a new workflow execution.\n\n It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\n also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\n instance already exists with same workflow id.",
        "operationId": "StartWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/StartWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/StartWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if\n it isn't yet started.\n\n If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history\n and a workflow task is generated.\n\n If the workflow is not running or not found, then the workflow is created with\n `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a\n workflow task is generated.\n\n (-- api-linter: core::0136::prepositions=disabled\n     aip.dev/not-precedent: \"With\" is used to indicate combined operation. --)",
        "operationId": "SignalWithStartWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signalName",
            "in": "path",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignalWithStartWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignalWithStartWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/cancel": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\n a workflow execution.\n\n This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\n workflow history and a new workflow task created for the workflow. It returns success if the requested\n workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.",
        "operationId": "RequestCancelWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RequestCancelWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RequestCancelWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/reset": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\n execution instance.\n TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "ResetWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResetWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResetWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/signal/{signalName}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "SignalWorkflowExecution is used to send a signal to a running workflow execution.\n\n This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\n task being created for the execution.",
        "operationId": "SignalWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "signalName",
            "in": "path",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SignalWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SignalWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/terminate": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\n execution instance.",
        "operationId": "TerminateWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TerminateWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TerminateWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update-options": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.",
        "operationId": "UpdateWorkflowExecutionOptions",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name of the target Workflow.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkflowExecutionOptionsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkflowExecutionOptionsResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update/{request.input.name}": {
      "post": {
        "tags": ["WorkflowService"],
        "description": "Invokes the specified Update function on user Workflow code.",
        "operationId": "UpdateWorkflowExecution",
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "description": "The namespace name of the target Workflow.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "workflow_execution.workflow_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "request.input.name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateWorkflowExecutionRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateWorkflowExecutionResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    },
    "/system-info": {
      "get": {
        "tags": ["WorkflowService"],
        "description": "GetSystemInfo returns information about the system.",
        "operationId": "GetSystemInfo",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSystemInfoResponse"
                }
              }
            }
          },
          "default": {
            "description": "Default error response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Status"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ActivityFailureInfo": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string"
          },
          "startedEventId": {
            "type": "string"
          },
          "identity": {
            "type": "string"
          },
          "activityType": {
            "$ref": "#/components/schemas/ActivityType"
          },
          "activityId": {
            "type": "string"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "ActivityOptions": {
        "type": "object",
        "properties": {
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "scheduleToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\n retries will be attempted. Either this or `start_to_close_timeout` must be specified.\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "scheduleToStartTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\n timeout is always non retryable, as all a retry would achieve is to put it back into the same\n queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\n specified.\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "startToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\n timeout is always retryable. Either this or `schedule_to_close_timeout` must be\n specified.\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "heartbeatTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Maximum permitted time between successful worker heartbeats."
          },
          "retryPolicy": {
            "$ref": "#/components/schemas/RetryPolicy"
          }
        }
      },
      "ActivityPropertiesModifiedExternallyEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to."
          },
          "newRetryPolicy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RetryPolicy"
              }
            ],
            "description": "If set, update the retry policy of the activity, replacing it with the specified one.\n The number of attempts at the activity is preserved."
          }
        }
      },
      "ActivityTaskCancelRequestedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          }
        }
      },
      "ActivityTaskCanceledEventAttributes": {
        "type": "object",
        "properties": {
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Additional information that the activity reported upon confirming cancellation"
          },
          "latestCancelRequestedEventId": {
            "type": "string",
            "description": "id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same\n activity"
          },
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to"
          },
          "identity": {
            "type": "string",
            "description": "id of the worker who canceled this activity"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this workflow task.\n Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent"
          }
        }
      },
      "ActivityTaskCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "result": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized results of the activity. IE: The return value of the activity function"
          },
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to"
          },
          "identity": {
            "type": "string",
            "description": "id of the worker that completed this task"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this workflow task.\n Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent"
          }
        }
      },
      "ActivityTaskFailedEventAttributes": {
        "type": "object",
        "properties": {
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Failure details"
          },
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to"
          },
          "identity": {
            "type": "string",
            "description": "id of the worker that failed this task"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this workflow task.\n Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent"
          }
        }
      },
      "ActivityTaskScheduledEventAttributes": {
        "type": "object",
        "properties": {
          "activityId": {
            "type": "string",
            "description": "The worker/user assigned identifier for the activity"
          },
          "activityType": {
            "$ref": "#/components/schemas/ActivityType"
          },
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "input": {
            "$ref": "#/components/schemas/Payloads"
          },
          "scheduleToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\n retries will be attempted. Either this or `start_to_close_timeout` must be specified.\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "scheduleToStartTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\n timeout is always non retryable, as all a retry would achieve is to put it back into the same\n queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\n specified.\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "startToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\n timeout is always retryable. Either this or `schedule_to_close_timeout` must be\n specified.\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "heartbeatTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Maximum permitted time between successful worker heartbeats."
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "retryPolicy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RetryPolicy"
              }
            ],
            "description": "Activities are assigned a default retry policy controlled by the service's dynamic\n configuration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set\n retry_policy.maximum_attempts to 1."
          },
          "useWorkflowBuildId": {
            "type": "boolean",
            "description": "If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,\n Assignment rules of the activity's Task Queue will be used to determine the Build ID."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata. If this message is not present, or any fields are not\n present, they inherit the values from the workflow."
          }
        }
      },
      "ActivityTaskStartedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to"
          },
          "identity": {
            "type": "string",
            "description": "id of the worker that picked up this task"
          },
          "requestId": {
            "type": "string",
            "description": "TODO ??"
          },
          "attempt": {
            "type": "integer",
            "description": "Starting at 1, the number of times this task has been attempted",
            "format": "int32"
          },
          "lastFailure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Will be set to the most recent failure details, if this task has previously failed and then\n been retried."
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker to whom this task was dispatched.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "buildIdRedirectCounter": {
            "type": "string",
            "description": "Used by server internally to properly reapply build ID redirects to an execution\n when rebuilding it from events.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          }
        }
      },
      "ActivityTaskTimedOutEventAttributes": {
        "type": "object",
        "properties": {
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "If this activity had failed, was retried, and then timed out, that failure is stored as the\n `cause` in here."
          },
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "ActivityType": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "description": "Represents the identifier used by a activity author to define the activity. Typically, the\n name of a function. This is sometimes referred to as the activity's \"name\""
      },
      "Alert": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "severity": {
            "enum": [
              "SEVERITY_UNSPECIFIED",
              "SEVERITY_HIGH",
              "SEVERITY_MEDIUM",
              "SEVERITY_LOW"
            ],
            "type": "string",
            "format": "enum"
          }
        },
        "description": "Alert contains notification and severity."
      },
      "ApplicationFailureInfo": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "nonRetryable": {
            "type": "boolean"
          },
          "details": {
            "$ref": "#/components/schemas/Payloads"
          },
          "nextRetryDelay": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "next_retry_delay can be used by the client to override the activity\n retry interval calculated by the retry policy. Retry attempts will\n still be subject to the maximum retries limit and total time limit\n defined by the policy."
          }
        }
      },
      "BackfillRequest": {
        "type": "object",
        "properties": {
          "startTime": {
            "type": "string",
            "description": "Time range to evaluate schedule in. Currently, this time range is\n exclusive on start_time and inclusive on end_time. (This is admittedly\n counterintuitive and it may change in the future, so to be safe, use a\n start time strictly before a scheduled time.) Also note that an action\n nominally scheduled in the interval but with jitter that pushes it after\n end_time will not be included.",
            "format": "date-time"
          },
          "endTime": {
            "type": "string",
            "format": "date-time"
          },
          "overlapPolicy": {
            "enum": [
              "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
              "SCHEDULE_OVERLAP_POLICY_SKIP",
              "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
              "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
              "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
              "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
              "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL"
            ],
            "type": "string",
            "description": "If set, override overlap policy for this request.",
            "format": "enum"
          }
        }
      },
      "BadBinaries": {
        "type": "object",
        "properties": {
          "binaries": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/BadBinaryInfo"
            }
          }
        }
      },
      "BadBinaryInfo": {
        "type": "object",
        "properties": {
          "reason": {
            "type": "string"
          },
          "operator": {
            "type": "string"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "BatchOperationCancellation": {
        "type": "object",
        "properties": {
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        },
        "description": "BatchOperationCancellation sends cancel requests to batch workflows.\n Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.\n Ignore first_execution_run_id because this is used for single workflow operation."
      },
      "BatchOperationDeletion": {
        "type": "object",
        "properties": {
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        },
        "description": "BatchOperationDeletion sends deletion requests to batch workflows.\n Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest."
      },
      "BatchOperationInfo": {
        "type": "object",
        "properties": {
          "jobId": {
            "type": "string",
            "description": "Batch job ID"
          },
          "state": {
            "enum": [
              "BATCH_OPERATION_STATE_UNSPECIFIED",
              "BATCH_OPERATION_STATE_RUNNING",
              "BATCH_OPERATION_STATE_COMPLETED",
              "BATCH_OPERATION_STATE_FAILED"
            ],
            "type": "string",
            "description": "Batch operation state",
            "format": "enum"
          },
          "startTime": {
            "type": "string",
            "description": "Batch operation start time",
            "format": "date-time"
          },
          "closeTime": {
            "type": "string",
            "description": "Batch operation close time",
            "format": "date-time"
          }
        }
      },
      "BatchOperationReset": {
        "type": "object",
        "properties": {
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client."
          },
          "options": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ResetOptions"
              }
            ],
            "description": "Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored."
          },
          "resetType": {
            "enum": [
              "RESET_TYPE_UNSPECIFIED",
              "RESET_TYPE_FIRST_WORKFLOW_TASK",
              "RESET_TYPE_LAST_WORKFLOW_TASK"
            ],
            "type": "string",
            "description": "Reset type (deprecated, use `options`).",
            "format": "enum"
          },
          "resetReapplyType": {
            "enum": [
              "RESET_REAPPLY_TYPE_UNSPECIFIED",
              "RESET_REAPPLY_TYPE_SIGNAL",
              "RESET_REAPPLY_TYPE_NONE",
              "RESET_REAPPLY_TYPE_ALL_ELIGIBLE"
            ],
            "type": "string",
            "description": "History event reapply options (deprecated, use `options`).",
            "format": "enum"
          }
        },
        "description": "BatchOperationReset sends reset requests to batch workflows.\n Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest."
      },
      "BatchOperationSignal": {
        "type": "object",
        "properties": {
          "signal": {
            "type": "string",
            "description": "The workflow author-defined name of the signal to send to the workflow"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized value(s) to provide with the signal"
          },
          "header": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Header"
              }
            ],
            "description": "Headers that are passed with the signal to the processing workflow.\n These can include things like auth or tracing tokens."
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        },
        "description": "BatchOperationSignal sends signals to batch workflows.\n Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest."
      },
      "BatchOperationTermination": {
        "type": "object",
        "properties": {
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized value(s) to provide to the termination event"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        },
        "description": "BatchOperationTermination sends terminate requests to batch workflows.\n Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.\n Ignore first_execution_run_id because this is used for single workflow operation."
      },
      "BatchOperationUnpauseActivities": {
        "type": "object",
        "properties": {
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client."
          },
          "type": {
            "type": "string"
          },
          "matchAll": {
            "type": "boolean"
          },
          "resetAttempts": {
            "type": "boolean",
            "description": "Providing this flag will also reset the number of attempts."
          },
          "resetHeartbeat": {
            "type": "boolean",
            "description": "Providing this flag will also reset the heartbeat details."
          },
          "jitter": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "If set, the activity will start at a random time within the specified jitter\n duration, introducing variability to the start time."
          }
        },
        "description": "BatchOperationUnpauseActivities sends unpause requests to batch workflows."
      },
      "BatchOperationUpdateWorkflowExecutionOptions": {
        "type": "object",
        "properties": {
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client."
          },
          "workflowExecutionOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecutionOptions"
              }
            ],
            "description": "Workflow Execution options. Partial updates are accepted and controlled by update_mask."
          },
          "updateMask": {
            "type": "string",
            "description": "Controls which fields from `workflow_execution_options` will be applied.\n To unset a field, set it to null and use the update mask to indicate that it should be mutated.",
            "format": "field-mask"
          }
        },
        "description": "BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.\n Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest."
      },
      "BuildIdAssignmentRule": {
        "type": "object",
        "properties": {
          "targetBuildId": {
            "type": "string"
          },
          "percentageRamp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RampByPercentage"
              }
            ],
            "description": "This ramp is useful for gradual Blue/Green deployments (and similar)\n where you want to send a certain portion of the traffic to the target\n Build ID."
          }
        },
        "description": "Assignment rules are applied to *new* Workflow and Activity executions at\n schedule time to assign them to a Build ID.\n\n Assignment rules will not be used in the following cases:\n    - Child Workflows or Continue-As-New Executions who inherit their\n      parent/previous Workflow's assigned Build ID (by setting the\n      `inherit_build_id` flag - default behavior in SDKs when the same Task Queue\n      is used.)\n    - An Activity that inherits the assigned Build ID of its Workflow (by\n      setting the `use_workflow_build_id` flag - default behavior in SDKs\n      when the same Task Queue is used.)\n\n In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)\n the task will be dispatched to Workers of the Build ID determined by the\n assignment rules (or inherited). Otherwise, the final Build ID will be\n determined by the redirect rules.\n\n Once a Workflow completes its first Workflow Task in a particular Build ID it\n stays in that Build ID regardless of changes to assignment rules. Redirect\n rules can be used to move the workflow to another compatible Build ID.\n\n When using Worker Versioning on a Task Queue, in the steady state,\n there should typically be a single assignment rule to send all new executions\n to the latest Build ID. Existence of at least one such \"unconditional\"\n rule at all times is enforces by the system, unless the `force` flag is used\n by the user when replacing/deleting these rules (for exceptional cases).\n\n During a deployment, one or more additional rules can be added to assign a\n subset of the tasks to a new Build ID based on a \"ramp percentage\".\n\n When there are multiple assignment rules for a Task Queue, the rules are\n evaluated in order, starting from index 0. The first applicable rule will be\n applied and the rest will be ignored.\n\n In the event that no assignment rule is applicable on a task (or the Task\n Queue is simply not versioned), the tasks will be dispatched to an\n unversioned Worker."
      },
      "BuildIdReachability": {
        "type": "object",
        "properties": {
          "buildId": {
            "type": "string",
            "description": "A build id or empty if unversioned."
          },
          "taskQueueReachability": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TaskQueueReachability"
            },
            "description": "Reachability per task queue."
          }
        },
        "description": "Reachability of tasks for a worker by build id, in one or more task queues."
      },
      "CalendarSpec": {
        "type": "object",
        "properties": {
          "second": {
            "type": "string",
            "description": "Expression to match seconds. Default: 0"
          },
          "minute": {
            "type": "string",
            "description": "Expression to match minutes. Default: 0"
          },
          "hour": {
            "type": "string",
            "description": "Expression to match hours. Default: 0"
          },
          "dayOfMonth": {
            "type": "string",
            "description": "Expression to match days of the month. Default: *\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: standard name of field --)"
          },
          "month": {
            "type": "string",
            "description": "Expression to match months. Default: *"
          },
          "year": {
            "type": "string",
            "description": "Expression to match years. Default: *"
          },
          "dayOfWeek": {
            "type": "string",
            "description": "Expression to match days of the week. Default: *"
          },
          "comment": {
            "type": "string",
            "description": "Free-form comment describing the intention of this spec."
          }
        },
        "description": "CalendarSpec describes an event specification relative to the calendar,\n similar to a traditional cron specification, but with labeled fields. Each\n field can be one of:\n   *: matches always\n   x: matches when the field equals x\n   x/y : matches when the field equals x+n*y where n is an integer\n   x-z: matches when the field is between x and z inclusive\n   w,x,y,...: matches when the field is one of the listed values\n Each x, y, z, ... is either a decimal integer, or a month or day of week name\n or abbreviation (in the appropriate fields).\n A timestamp matches if all fields match.\n Note that fields have different default values, for convenience.\n Note that the special case that some cron implementations have for treating\n day_of_month and day_of_week as \"or\" instead of \"and\" when both are set is\n not implemented.\n day_of_week can accept 0 or 7 as Sunday\n CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be\n returned if you describe the schedule."
      },
      "Callback": {
        "type": "object",
        "properties": {
          "nexus": {
            "$ref": "#/components/schemas/Callback_Nexus"
          },
          "internal": {
            "$ref": "#/components/schemas/Callback_Internal"
          }
        },
        "description": "Callback to attach to various events in the system, e.g. workflow run completion."
      },
      "CallbackInfo": {
        "type": "object",
        "properties": {
          "callback": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Callback"
              }
            ],
            "description": "Information on how this callback should be invoked (e.g. its URL and type)."
          },
          "trigger": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CallbackInfo_Trigger"
              }
            ],
            "description": "Trigger for this callback."
          },
          "registrationTime": {
            "type": "string",
            "description": "The time when the callback was registered.",
            "format": "date-time"
          },
          "state": {
            "enum": [
              "CALLBACK_STATE_UNSPECIFIED",
              "CALLBACK_STATE_STANDBY",
              "CALLBACK_STATE_SCHEDULED",
              "CALLBACK_STATE_BACKING_OFF",
              "CALLBACK_STATE_FAILED",
              "CALLBACK_STATE_SUCCEEDED",
              "CALLBACK_STATE_BLOCKED"
            ],
            "type": "string",
            "format": "enum"
          },
          "attempt": {
            "type": "integer",
            "description": "The number of attempts made to deliver the callback.\n This number represents a minimum bound since the attempt is incremented after the callback request completes.",
            "format": "int32"
          },
          "lastAttemptCompleteTime": {
            "type": "string",
            "description": "The time when the last attempt completed.",
            "format": "date-time"
          },
          "lastAttemptFailure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "The last attempt's failure, if any."
          },
          "nextAttemptScheduleTime": {
            "type": "string",
            "description": "The time when the next attempt is scheduled.",
            "format": "date-time"
          },
          "blockedReason": {
            "type": "string",
            "description": "If the state is BLOCKED, blocked reason provides additional information."
          }
        },
        "description": "CallbackInfo contains the state of an attached workflow callback."
      },
      "CallbackInfo_Trigger": {
        "type": "object",
        "properties": {
          "workflowClosed": {
            "$ref": "#/components/schemas/CallbackInfo_WorkflowClosed"
          }
        }
      },
      "CallbackInfo_WorkflowClosed": {
        "type": "object",
        "properties": {},
        "description": "Trigger for when the workflow is closed."
      },
      "Callback_Internal": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "description": "Opaque internal data.",
            "format": "bytes"
          }
        },
        "description": "Callbacks to be delivered internally within the system.\n This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.\n The only reason that this is exposed is because callbacks are replicated across clusters via the\n WorkflowExecutionStarted event, which is defined in the public API."
      },
      "Callback_Nexus": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "Callback URL."
          },
          "header": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Header to attach to callback request."
          }
        }
      },
      "CanceledFailureInfo": {
        "type": "object",
        "properties": {
          "details": {
            "$ref": "#/components/schemas/Payloads"
          }
        }
      },
      "ChildWorkflowExecutionCanceledEventAttributes": {
        "type": "object",
        "properties": {
          "details": {
            "$ref": "#/components/schemas/Payloads"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
          }
        }
      },
      "ChildWorkflowExecutionCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "result": {
            "$ref": "#/components/schemas/Payloads"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
          }
        }
      },
      "ChildWorkflowExecutionFailedEventAttributes": {
        "type": "object",
        "properties": {
          "failure": {
            "$ref": "#/components/schemas/Failure"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "ChildWorkflowExecutionFailureInfo": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "initiatedEventId": {
            "type": "string"
          },
          "startedEventId": {
            "type": "string"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "ChildWorkflowExecutionStartedEventAttributes": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          }
        }
      },
      "ChildWorkflowExecutionTerminatedEventAttributes": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
          }
        }
      },
      "ChildWorkflowExecutionTimedOutEventAttributes": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "ClusterReplicationConfig": {
        "type": "object",
        "properties": {
          "clusterName": {
            "type": "string"
          }
        }
      },
      "CompatibleBuildIdRedirectRule": {
        "type": "object",
        "properties": {
          "sourceBuildId": {
            "type": "string"
          },
          "targetBuildId": {
            "type": "string",
            "description": "Target Build ID must be compatible with the Source Build ID; that is it\n must be able to process event histories made by the Source Build ID by\n using [Patching](https://docs.temporal.io/workflows#patching) or other\n means."
          }
        },
        "description": "These rules apply to tasks assigned to a particular Build ID\n (`source_build_id`) to redirect them to another *compatible* Build ID\n (`target_build_id`).\n\n It is user's responsibility to ensure that the target Build ID is compatible\n with the source Build ID (e.g. by using the Patching API).\n\n Most deployments are not expected to need these rules, however following\n situations can greatly benefit from redirects:\n  - Need to move long-running Workflow Executions from an old Build ID to a\n    newer one.\n  - Need to hotfix some broken or stuck Workflow Executions.\n\n In steady state, redirect rules are beneficial when dealing with old\n Executions ran on now-decommissioned Build IDs:\n  - To redirecting the Workflow Queries to the current (compatible) Build ID.\n  - To be able to Reset an old Execution so it can run on the current\n    (compatible) Build ID.\n\n Redirect rules can be chained."
      },
      "CompatibleVersionSet": {
        "type": "object",
        "properties": {
          "buildIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "All the compatible versions, unordered, except for the last element, which is considered the set \"default\"."
          }
        },
        "description": "Used by the worker versioning APIs, represents an unordered set of one or more versions which are\n considered to be compatible with each other. Currently the versions are always worker build IDs."
      },
      "CountWorkflowExecutionsResponse": {
        "type": "object",
        "properties": {
          "count": {
            "type": "string",
            "description": "If `query` is not grouping by any field, the count is an approximate number\n of workflows that matches the query.\n If `query` is grouping by a field, the count is simply the sum of the counts\n of the groups returned in the response. This number can be smaller than the\n total number of workflows matching the query."
          },
          "groups": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CountWorkflowExecutionsResponse_AggregationGroup"
            },
            "description": "`groups` contains the groups if the request is grouping by a field.\n The list might not be complete, and the counts of each group is approximate."
          }
        }
      },
      "CountWorkflowExecutionsResponse_AggregationGroup": {
        "type": "object",
        "properties": {
          "groupValues": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Payload"
            }
          },
          "count": {
            "type": "string"
          }
        }
      },
      "CreateNexusEndpointRequest": {
        "type": "object",
        "properties": {
          "spec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EndpointSpec"
              }
            ],
            "description": "Endpoint definition to create."
          }
        }
      },
      "CreateNexusEndpointResponse": {
        "type": "object",
        "properties": {
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Endpoint"
              }
            ],
            "description": "Data post acceptance. Can be used to issue additional updates to this record."
          }
        }
      },
      "CreateScheduleRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace the schedule should be created in."
          },
          "scheduleId": {
            "type": "string",
            "description": "The id of the new schedule."
          },
          "schedule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Schedule"
              }
            ],
            "description": "The schedule spec, policies, action, and initial state."
          },
          "initialPatch": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SchedulePatch"
              }
            ],
            "description": "Optional initial patch (e.g. to run the action once immediately)."
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request."
          },
          "requestId": {
            "type": "string",
            "description": "A unique identifier for this create request for idempotence. Typically UUIDv4."
          },
          "memo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Memo"
              }
            ],
            "description": "Memo and search attributes to attach to the schedule itself."
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          }
        },
        "description": "(-- api-linter: core::0203::optional=disabled\n     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)"
      },
      "CreateScheduleResponse": {
        "type": "object",
        "properties": {
          "conflictToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "CreateWorkflowRuleRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "spec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowRuleSpec"
              }
            ],
            "description": "The rule specification ."
          },
          "forceScan": {
            "type": "boolean",
            "description": "If true, the rule will be applied to the currently running workflows via batch job.\n If not set , the rule will only be applied when triggering condition is satisfied.\n visibility_query in the rule will be used to select the workflows to apply the rule to."
          },
          "requestId": {
            "type": "string",
            "description": "Used to de-dupe requests. Typically should be UUID."
          }
        }
      },
      "CreateWorkflowRuleResponse": {
        "type": "object",
        "properties": {
          "rule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowRule"
              }
            ],
            "description": "Created rule."
          },
          "jobId": {
            "type": "string",
            "description": "Batch Job ID if force-scan flag was provided. Otherwise empty."
          }
        }
      },
      "DataBlob": {
        "type": "object",
        "properties": {
          "encodingType": {
            "enum": [
              "ENCODING_TYPE_UNSPECIFIED",
              "ENCODING_TYPE_PROTO3",
              "ENCODING_TYPE_JSON"
            ],
            "type": "string",
            "format": "enum"
          },
          "data": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "DeleteNexusEndpointResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteScheduleResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteWorkerDeploymentResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteWorkerDeploymentVersionResponse": {
        "type": "object",
        "properties": {}
      },
      "DeleteWorkflowRuleResponse": {
        "type": "object",
        "properties": {}
      },
      "Deployment": {
        "type": "object",
        "properties": {
          "seriesName": {
            "type": "string",
            "description": "Different versions of the same worker service/application are related together by having a\n shared series name.\n Out of all deployments of a series, one can be designated as the current deployment, which\n receives new workflow executions and new tasks of workflows with\n `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior."
          },
          "buildId": {
            "type": "string",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\n changes."
          }
        },
        "description": "`Deployment` identifies a deployment of Temporal workers. The combination of deployment series\n name + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker\n programs to specify these values.\n Deprecated."
      },
      "DeploymentInfo": {
        "type": "object",
        "properties": {
          "deployment": {
            "$ref": "#/components/schemas/Deployment"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "taskQueueInfos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeploymentInfo_TaskQueueInfo"
            }
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            },
            "description": "A user-defined set of key-values. Can be updated as part of write operations to the\n deployment, such as `SetCurrentDeployment`."
          },
          "isCurrent": {
            "type": "boolean",
            "description": "If this deployment is the current deployment of its deployment series."
          }
        },
        "description": "`DeploymentInfo` holds information about a deployment. Deployment information is tracked\n automatically by server as soon as the first poll from that deployment reaches the server. There\n can be multiple task queue workers in a single deployment which are listed in this message.\n Deprecated."
      },
      "DeploymentInfo_TaskQueueInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY",
              "TASK_QUEUE_TYPE_NEXUS"
            ],
            "type": "string",
            "format": "enum"
          },
          "firstPollerTime": {
            "type": "string",
            "description": "When server saw the first poller for this task queue in this deployment.",
            "format": "date-time"
          }
        }
      },
      "DeploymentListInfo": {
        "type": "object",
        "properties": {
          "deployment": {
            "$ref": "#/components/schemas/Deployment"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "isCurrent": {
            "type": "boolean",
            "description": "If this deployment is the current deployment of its deployment series."
          }
        },
        "description": "DeploymentListInfo is an abbreviated set of fields from DeploymentInfo that's returned in\n ListDeployments.\n Deprecated."
      },
      "DeploymentTransition": {
        "type": "object",
        "properties": {
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "The target deployment of the transition. Null means a so-far-versioned workflow is\n transitioning to unversioned workers."
          }
        },
        "description": "Holds information about ongoing transition of a workflow execution from one deployment to another.\n Deprecated. Use DeploymentVersionTransition."
      },
      "DeploymentVersionTransition": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "description": "Required. The target Version of the transition. May be `__unversioned__` which means a\n so-far-versioned workflow is transitioning to unversioned workers."
          }
        },
        "description": "Holds information about ongoing transition of a workflow execution from one worker\n deployment version to another.\n Experimental. Might change in the future."
      },
      "DescribeBatchOperationResponse": {
        "type": "object",
        "properties": {
          "operationType": {
            "enum": [
              "BATCH_OPERATION_TYPE_UNSPECIFIED",
              "BATCH_OPERATION_TYPE_TERMINATE",
              "BATCH_OPERATION_TYPE_CANCEL",
              "BATCH_OPERATION_TYPE_SIGNAL",
              "BATCH_OPERATION_TYPE_DELETE",
              "BATCH_OPERATION_TYPE_RESET",
              "BATCH_OPERATION_TYPE_UPDATE_EXECUTION_OPTIONS"
            ],
            "type": "string",
            "description": "Batch operation type",
            "format": "enum"
          },
          "jobId": {
            "type": "string",
            "description": "Batch job ID"
          },
          "state": {
            "enum": [
              "BATCH_OPERATION_STATE_UNSPECIFIED",
              "BATCH_OPERATION_STATE_RUNNING",
              "BATCH_OPERATION_STATE_COMPLETED",
              "BATCH_OPERATION_STATE_FAILED"
            ],
            "type": "string",
            "description": "Batch operation state",
            "format": "enum"
          },
          "startTime": {
            "type": "string",
            "description": "Batch operation start time",
            "format": "date-time"
          },
          "closeTime": {
            "type": "string",
            "description": "Batch operation close time",
            "format": "date-time"
          },
          "totalOperationCount": {
            "type": "string",
            "description": "Total operation count"
          },
          "completeOperationCount": {
            "type": "string",
            "description": "Complete operation count"
          },
          "failureOperationCount": {
            "type": "string",
            "description": "Failure operation count"
          },
          "identity": {
            "type": "string",
            "description": "Identity indicates the operator identity"
          },
          "reason": {
            "type": "string",
            "description": "Reason indicates the reason to stop a operation"
          }
        }
      },
      "DescribeDeploymentResponse": {
        "type": "object",
        "properties": {
          "deploymentInfo": {
            "$ref": "#/components/schemas/DeploymentInfo"
          }
        },
        "description": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
      },
      "DescribeNamespaceResponse": {
        "type": "object",
        "properties": {
          "namespaceInfo": {
            "$ref": "#/components/schemas/NamespaceInfo"
          },
          "config": {
            "$ref": "#/components/schemas/NamespaceConfig"
          },
          "replicationConfig": {
            "$ref": "#/components/schemas/NamespaceReplicationConfig"
          },
          "failoverVersion": {
            "type": "string"
          },
          "isGlobalNamespace": {
            "type": "boolean"
          },
          "failoverHistory": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FailoverStatus"
            },
            "description": "Contains the historical state of failover_versions for the cluster, truncated to contain only the last N\n states to ensure that the list does not grow unbounded."
          }
        }
      },
      "DescribeScheduleResponse": {
        "type": "object",
        "properties": {
          "schedule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Schedule"
              }
            ],
            "description": "The complete current schedule details. This may not match the schedule as\n created because:\n - some types of schedule specs may get compiled into others (e.g.\n   CronString into StructuredCalendarSpec)\n - some unspecified fields may be replaced by defaults\n - some fields in the state are modified automatically\n - the schedule may have been modified by UpdateSchedule or PatchSchedule"
          },
          "info": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleInfo"
              }
            ],
            "description": "Extra schedule state info."
          },
          "memo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Memo"
              }
            ],
            "description": "The memo and search attributes that the schedule was created with."
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "conflictToken": {
            "type": "string",
            "description": "This value can be passed back to UpdateSchedule to ensure that the\n schedule was not modified between a Describe and an Update, which could\n lead to lost updates and other confusion.",
            "format": "bytes"
          }
        }
      },
      "DescribeTaskQueueResponse": {
        "type": "object",
        "properties": {
          "pollers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PollerInfo"
            },
            "description": "Deprecated. Use `versions_info.types_info.pollers` with `ENHANCED` mode instead.\n Not set in `ENHANCED` mode."
          },
          "taskQueueStatus": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskQueueStatus"
              }
            ],
            "description": "Deprecated. Not set in `ENHANCED` mode."
          },
          "versionsInfo": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TaskQueueVersionInfo"
            },
            "description": "This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.\n Only set in `ENHANCED` mode."
          },
          "versioningInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskQueueVersioningInfo"
              }
            ],
            "description": "Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.\n When not present, it means the tasks are routed to Unversioned workers (workers with\n UNVERSIONED or unspecified WorkerVersioningMode.)\n Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion\n and SetWorkerDeploymentRampingVersion on Worker Deployments.\n Note: This information is not relevant to Pinned workflow executions and their activities as\n they are always routed to their Pinned Deployment Version. However, new workflow executions\n are typically not Pinned until they complete their first task (unless they are started with\n a Pinned VersioningOverride or are Child Workflows of a Pinned parent)."
          }
        }
      },
      "DescribeWorkerDeploymentResponse": {
        "type": "object",
        "properties": {
          "conflictToken": {
            "type": "string",
            "description": "This value is returned so that it can be optionally passed to APIs\n that write to the Worker Deployment state to ensure that the state\n did not change between this read and a future write.",
            "format": "bytes"
          },
          "workerDeploymentInfo": {
            "$ref": "#/components/schemas/WorkerDeploymentInfo"
          }
        }
      },
      "DescribeWorkerDeploymentVersionResponse": {
        "type": "object",
        "properties": {
          "workerDeploymentVersionInfo": {
            "$ref": "#/components/schemas/WorkerDeploymentVersionInfo"
          }
        }
      },
      "DescribeWorkflowExecutionResponse": {
        "type": "object",
        "properties": {
          "executionConfig": {
            "$ref": "#/components/schemas/WorkflowExecutionConfig"
          },
          "workflowExecutionInfo": {
            "$ref": "#/components/schemas/WorkflowExecutionInfo"
          },
          "pendingActivities": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingActivityInfo"
            }
          },
          "pendingChildren": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingChildExecutionInfo"
            }
          },
          "pendingWorkflowTask": {
            "$ref": "#/components/schemas/PendingWorkflowTaskInfo"
          },
          "callbacks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CallbackInfo"
            }
          },
          "pendingNexusOperations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PendingNexusOperationInfo"
            }
          },
          "workflowExtendedInfo": {
            "$ref": "#/components/schemas/WorkflowExecutionExtendedInfo"
          }
        }
      },
      "DescribeWorkflowRuleResponse": {
        "type": "object",
        "properties": {
          "rule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowRule"
              }
            ],
            "description": "The rule that was read."
          }
        }
      },
      "Endpoint": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "description": "Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API."
          },
          "id": {
            "type": "string",
            "description": "Unique server-generated endpoint ID."
          },
          "spec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EndpointSpec"
              }
            ],
            "description": "Spec for the endpoint."
          },
          "createdTime": {
            "type": "string",
            "description": "The date and time when the endpoint was created.\n (-- api-linter: core::0142::time-field-names=disabled\n     aip.dev/not-precedent: Not following linter rules. --)",
            "format": "date-time"
          },
          "lastModifiedTime": {
            "type": "string",
            "description": "The date and time when the endpoint was last modified.\n Will not be set if the endpoint has never been modified.\n (-- api-linter: core::0142::time-field-names=disabled\n     aip.dev/not-precedent: Not following linter rules. --)",
            "format": "date-time"
          },
          "urlPrefix": {
            "type": "string",
            "description": "Server exposed URL prefix for invocation of operations on this endpoint.\n This doesn't include the protocol, hostname or port as the server does not know how it should be accessed\n publicly. The URL is stable in the face of endpoint renames."
          }
        },
        "description": "A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests."
      },
      "EndpointSpec": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.\n Renaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail."
          },
          "description": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payload"
              }
            ],
            "description": "Markdown description serialized as a single JSON string.\n If the Payload is encrypted, the UI and CLI may decrypt with the configured codec server endpoint.\n By default, the server enforces a limit of 20,000 bytes for this entire payload."
          },
          "target": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EndpointTarget"
              }
            ],
            "description": "Target to route requests to."
          }
        },
        "description": "Contains mutable fields for an Endpoint."
      },
      "EndpointTarget": {
        "type": "object",
        "properties": {
          "worker": {
            "$ref": "#/components/schemas/EndpointTarget_Worker"
          },
          "external": {
            "$ref": "#/components/schemas/EndpointTarget_External"
          }
        },
        "description": "Target to route requests to."
      },
      "EndpointTarget_External": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL to call."
          }
        },
        "description": "Target an external server by URL.\n At a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected\n into the server to modify the request."
      },
      "EndpointTarget_Worker": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace to route requests to."
          },
          "taskQueue": {
            "type": "string",
            "description": "Nexus task queue to route requests to."
          }
        },
        "description": "Target a worker polling on a Nexus task queue in a specific namespace."
      },
      "ExecuteMultiOperationRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "operations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExecuteMultiOperationRequest_Operation"
            },
            "description": "List of operations to execute within a single workflow.\n\n Preconditions:\n - The list of operations must not be empty.\n - The workflow ids must match across operations.\n - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.\n\n Note that additional operation-specific restrictions have to be considered."
          }
        }
      },
      "ExecuteMultiOperationRequest_Operation": {
        "type": "object",
        "properties": {
          "startWorkflow": {
            "allOf": [
              {
                "$ref": "#/components/schemas/StartWorkflowExecutionRequest"
              }
            ],
            "description": "Additional restrictions:\n - setting `cron_schedule` is invalid\n - setting `request_eager_execution` is invalid\n - setting `workflow_start_delay` is invalid"
          },
          "updateWorkflow": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UpdateWorkflowExecutionRequest"
              }
            ],
            "description": "Additional restrictions:\n - setting `first_execution_run_id` is invalid\n - setting `workflow_execution.run_id` is invalid"
          }
        }
      },
      "ExecuteMultiOperationResponse": {
        "type": "object",
        "properties": {
          "responses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExecuteMultiOperationResponse_Response"
            }
          }
        }
      },
      "ExecuteMultiOperationResponse_Response": {
        "type": "object",
        "properties": {
          "startWorkflow": {
            "$ref": "#/components/schemas/StartWorkflowExecutionResponse"
          },
          "updateWorkflow": {
            "$ref": "#/components/schemas/UpdateWorkflowExecutionResponse"
          }
        }
      },
      "ExternalWorkflowExecutionCancelRequestedEventAttributes": {
        "type": "object",
        "properties": {
          "initiatedEventId": {
            "type": "string",
            "description": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds\n to"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the to-be-cancelled workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          }
        }
      },
      "ExternalWorkflowExecutionSignaledEventAttributes": {
        "type": "object",
        "properties": {
          "initiatedEventId": {
            "type": "string",
            "description": "id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which was signaled.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          }
        }
      },
      "FailoverStatus": {
        "type": "object",
        "properties": {
          "failoverTime": {
            "type": "string",
            "description": "Timestamp when the Cluster switched to the following failover_version",
            "format": "date-time"
          },
          "failoverVersion": {
            "type": "string"
          }
        },
        "description": "Represents a historical replication status of a Namespace"
      },
      "Failure": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "source": {
            "type": "string",
            "description": "The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK\n In some SDKs this is used to rehydrate the stack trace into an exception object."
          },
          "stackTrace": {
            "type": "string"
          },
          "encodedAttributes": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payload"
              }
            ],
            "description": "Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of\n errors originating in user code which might contain sensitive information.\n The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto\n message.\n\n SDK authors:\n - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:\n   - Uses a JSON object to represent `{ message, stack_trace }`.\n   - Overwrites the original message with \"Encoded failure\" to indicate that more information could be extracted.\n   - Overwrites the original stack_trace with an empty string.\n   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed\n     by the user-provided PayloadCodec\n\n - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes."
          },
          "cause": {
            "$ref": "#/components/schemas/Failure"
          },
          "applicationFailureInfo": {
            "$ref": "#/components/schemas/ApplicationFailureInfo"
          },
          "timeoutFailureInfo": {
            "$ref": "#/components/schemas/TimeoutFailureInfo"
          },
          "canceledFailureInfo": {
            "$ref": "#/components/schemas/CanceledFailureInfo"
          },
          "terminatedFailureInfo": {
            "$ref": "#/components/schemas/TerminatedFailureInfo"
          },
          "serverFailureInfo": {
            "$ref": "#/components/schemas/ServerFailureInfo"
          },
          "resetWorkflowFailureInfo": {
            "$ref": "#/components/schemas/ResetWorkflowFailureInfo"
          },
          "activityFailureInfo": {
            "$ref": "#/components/schemas/ActivityFailureInfo"
          },
          "childWorkflowExecutionFailureInfo": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionFailureInfo"
          },
          "nexusOperationExecutionFailureInfo": {
            "$ref": "#/components/schemas/NexusOperationFailureInfo"
          },
          "nexusHandlerFailureInfo": {
            "$ref": "#/components/schemas/NexusHandlerFailureInfo"
          }
        }
      },
      "GetClusterInfoResponse": {
        "type": "object",
        "properties": {
          "supportedClients": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Key is client name i.e \"temporal-go\", \"temporal-java\", or \"temporal-cli\".\n Value is ranges of supported versions of this client i.e \">1.1.1 <=1.4.0 || ^5.0.0\"."
          },
          "serverVersion": {
            "type": "string"
          },
          "clusterId": {
            "type": "string"
          },
          "versionInfo": {
            "$ref": "#/components/schemas/VersionInfo"
          },
          "clusterName": {
            "type": "string"
          },
          "historyShardCount": {
            "type": "integer",
            "format": "int32"
          },
          "persistenceStore": {
            "type": "string"
          },
          "visibilityStore": {
            "type": "string"
          }
        },
        "description": "GetClusterInfoResponse contains information about Temporal cluster."
      },
      "GetCurrentDeploymentResponse": {
        "type": "object",
        "properties": {
          "currentDeploymentInfo": {
            "$ref": "#/components/schemas/DeploymentInfo"
          }
        },
        "description": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
      },
      "GetDeploymentReachabilityResponse": {
        "type": "object",
        "properties": {
          "deploymentInfo": {
            "$ref": "#/components/schemas/DeploymentInfo"
          },
          "reachability": {
            "enum": [
              "DEPLOYMENT_REACHABILITY_UNSPECIFIED",
              "DEPLOYMENT_REACHABILITY_REACHABLE",
              "DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
              "DEPLOYMENT_REACHABILITY_UNREACHABLE"
            ],
            "type": "string",
            "format": "enum"
          },
          "lastUpdateTime": {
            "type": "string",
            "description": "Reachability level might come from server cache. This timestamp specifies when the value\n was actually calculated.",
            "format": "date-time"
          }
        },
        "description": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
      },
      "GetNexusEndpointResponse": {
        "type": "object",
        "properties": {
          "endpoint": {
            "$ref": "#/components/schemas/Endpoint"
          }
        }
      },
      "GetSystemInfoResponse": {
        "type": "object",
        "properties": {
          "serverVersion": {
            "type": "string",
            "description": "Version of the server."
          },
          "capabilities": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GetSystemInfoResponse_Capabilities"
              }
            ],
            "description": "All capabilities the system supports."
          }
        }
      },
      "GetSystemInfoResponse_Capabilities": {
        "type": "object",
        "properties": {
          "signalAndQueryHeader": {
            "type": "boolean",
            "description": "True if signal and query headers are supported."
          },
          "internalErrorDifferentiation": {
            "type": "boolean",
            "description": "True if internal errors are differentiated from other types of errors for purposes of\n retrying non-internal errors.\n\n When unset/false, clients retry all failures. When true, clients should only retry\n non-internal errors."
          },
          "activityFailureIncludeHeartbeat": {
            "type": "boolean",
            "description": "True if RespondActivityTaskFailed API supports including heartbeat details"
          },
          "supportsSchedules": {
            "type": "boolean",
            "description": "Supports scheduled workflow features."
          },
          "encodedFailureAttributes": {
            "type": "boolean",
            "description": "True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes"
          },
          "buildIdBasedVersioning": {
            "type": "boolean",
            "description": "True if server supports dispatching Workflow and Activity tasks based on a worker's build_id\n (see:\n https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)"
          },
          "upsertMemo": {
            "type": "boolean",
            "description": "True if server supports upserting workflow memo"
          },
          "eagerWorkflowStart": {
            "type": "boolean",
            "description": "True if server supports eager workflow task dispatching for the StartWorkflowExecution API"
          },
          "sdkMetadata": {
            "type": "boolean",
            "description": "True if the server knows about the sdk metadata field on WFT completions and will record\n it in history"
          },
          "countGroupByExecutionStatus": {
            "type": "boolean",
            "description": "True if the server supports count group by execution status"
          },
          "nexus": {
            "type": "boolean",
            "description": "True if the server supports Nexus operations.\n This flag is dependent both on server version and for Nexus to be enabled via server configuration."
          }
        },
        "description": "System capability details."
      },
      "GetWorkerBuildIdCompatibilityResponse": {
        "type": "object",
        "properties": {
          "majorVersionSets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CompatibleVersionSet"
            },
            "description": "Major version sets, in order from oldest to newest. The last element of the list will always\n be the current default major version. IE: New workflows will target the most recent version\n in that version set.\n\n There may be fewer sets returned than exist, if the request chose to limit this response."
          }
        },
        "description": "[cleanup-wv-pre-release]"
      },
      "GetWorkerTaskReachabilityResponse": {
        "type": "object",
        "properties": {
          "buildIdReachability": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BuildIdReachability"
            },
            "description": "Task reachability, broken down by build id and then task queue.\n When requesting a large number of task queues or all task queues associated with the given build ids in a\n namespace, all task queues will be listed in the response but some of them may not contain reachability\n information due to a server enforced limit. When reaching the limit, task queues that reachability information\n could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\n another call to get the reachability for those task queues.\n\n Open source users can adjust this limit by setting the server's dynamic config value for\n `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store."
          }
        },
        "description": "[cleanup-wv-pre-release]\n Deprecated. Use `DescribeTaskQueue`."
      },
      "GetWorkerVersioningRulesResponse": {
        "type": "object",
        "properties": {
          "assignmentRules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimestampedBuildIdAssignmentRule"
            }
          },
          "compatibleRedirectRules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TimestampedCompatibleBuildIdRedirectRule"
            }
          },
          "conflictToken": {
            "type": "string",
            "description": "This value can be passed back to UpdateWorkerVersioningRulesRequest to\n ensure that the rules were not modified between this List and the Update,\n which could lead to lost updates and other confusion.",
            "format": "bytes"
          }
        },
        "description": "[cleanup-wv-pre-release]"
      },
      "GetWorkflowExecutionHistoryResponse": {
        "type": "object",
        "properties": {
          "history": {
            "$ref": "#/components/schemas/History"
          },
          "rawHistory": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataBlob"
            },
            "description": "Raw history is an alternate representation of history that may be returned if configured on\n the frontend. This is not supported by all SDKs. Either this or `history` will be set."
          },
          "nextPageToken": {
            "type": "string",
            "description": "Will be set if there are more history events than were included in this response",
            "format": "bytes"
          },
          "archived": {
            "type": "boolean"
          }
        }
      },
      "GetWorkflowExecutionHistoryReverseResponse": {
        "type": "object",
        "properties": {
          "history": {
            "$ref": "#/components/schemas/History"
          },
          "nextPageToken": {
            "type": "string",
            "description": "Will be set if there are more history events than were included in this response",
            "format": "bytes"
          }
        }
      },
      "GoogleProtobufAny": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "The type of the serialized message."
          }
        },
        "additionalProperties": true,
        "description": "Contains an arbitrary serialized message along with a @type that describes the type of the serialized message."
      },
      "Header": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            }
          }
        },
        "description": "Contains metadata that can be attached to a variety of requests, like starting a workflow, and\n can be propagated between, for example, workflows and activities."
      },
      "History": {
        "type": "object",
        "properties": {
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HistoryEvent"
            }
          }
        }
      },
      "HistoryEvent": {
        "type": "object",
        "properties": {
          "eventId": {
            "type": "string",
            "description": "Monotonically increasing event number, starts at 1."
          },
          "eventTime": {
            "type": "string",
            "format": "date-time"
          },
          "eventType": {
            "enum": [
              "EVENT_TYPE_UNSPECIFIED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT",
              "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED",
              "EVENT_TYPE_WORKFLOW_TASK_STARTED",
              "EVENT_TYPE_WORKFLOW_TASK_COMPLETED",
              "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT",
              "EVENT_TYPE_WORKFLOW_TASK_FAILED",
              "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED",
              "EVENT_TYPE_ACTIVITY_TASK_STARTED",
              "EVENT_TYPE_ACTIVITY_TASK_COMPLETED",
              "EVENT_TYPE_ACTIVITY_TASK_FAILED",
              "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT",
              "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED",
              "EVENT_TYPE_ACTIVITY_TASK_CANCELED",
              "EVENT_TYPE_TIMER_STARTED",
              "EVENT_TYPE_TIMER_FIRED",
              "EVENT_TYPE_TIMER_CANCELED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED",
              "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
              "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
              "EVENT_TYPE_MARKER_RECORDED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW",
              "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED",
              "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED",
              "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
              "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED",
              "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED",
              "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY",
              "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY",
              "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED",
              "EVENT_TYPE_NEXUS_OPERATION_SCHEDULED",
              "EVENT_TYPE_NEXUS_OPERATION_STARTED",
              "EVENT_TYPE_NEXUS_OPERATION_COMPLETED",
              "EVENT_TYPE_NEXUS_OPERATION_FAILED",
              "EVENT_TYPE_NEXUS_OPERATION_CANCELED",
              "EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT",
              "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED",
              "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED",
              "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED"
            ],
            "type": "string",
            "format": "enum"
          },
          "version": {
            "type": "string",
            "description": "TODO: What is this? Appears unused by SDKs"
          },
          "taskId": {
            "type": "string",
            "description": "TODO: What is this? Appears unused by SDKs"
          },
          "workerMayIgnore": {
            "type": "boolean",
            "description": "Set to true when the SDK may ignore the event as it does not impact workflow state or\n information in any way that the SDK need be concerned with. If an SDK encounters an event\n type which it does not understand, it must error unless this is true. If it is true, it's\n acceptable for the event type and/or attributes to be uninterpretable."
          },
          "userMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserMetadata"
              }
            ],
            "description": "Metadata on the event. This is often carried over from commands and client calls. Most events\n won't have this information, and how this information is used is dependent upon the interface\n that reads it.\n\n Current well-known uses:\n  * workflow_execution_started_event_attributes - summary and details from start workflow.\n  * timer_started_event_attributes - summary represents an identifier for the timer for use by\n    user interfaces."
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Links associated with the event."
          },
          "workflowExecutionStartedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionStartedEventAttributes"
          },
          "workflowExecutionCompletedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionCompletedEventAttributes"
          },
          "workflowExecutionFailedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionFailedEventAttributes"
          },
          "workflowExecutionTimedOutEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionTimedOutEventAttributes"
          },
          "workflowTaskScheduledEventAttributes": {
            "$ref": "#/components/schemas/WorkflowTaskScheduledEventAttributes"
          },
          "workflowTaskStartedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowTaskStartedEventAttributes"
          },
          "workflowTaskCompletedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowTaskCompletedEventAttributes"
          },
          "workflowTaskTimedOutEventAttributes": {
            "$ref": "#/components/schemas/WorkflowTaskTimedOutEventAttributes"
          },
          "workflowTaskFailedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowTaskFailedEventAttributes"
          },
          "activityTaskScheduledEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskScheduledEventAttributes"
          },
          "activityTaskStartedEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskStartedEventAttributes"
          },
          "activityTaskCompletedEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskCompletedEventAttributes"
          },
          "activityTaskFailedEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskFailedEventAttributes"
          },
          "activityTaskTimedOutEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskTimedOutEventAttributes"
          },
          "timerStartedEventAttributes": {
            "$ref": "#/components/schemas/TimerStartedEventAttributes"
          },
          "timerFiredEventAttributes": {
            "$ref": "#/components/schemas/TimerFiredEventAttributes"
          },
          "activityTaskCancelRequestedEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskCancelRequestedEventAttributes"
          },
          "activityTaskCanceledEventAttributes": {
            "$ref": "#/components/schemas/ActivityTaskCanceledEventAttributes"
          },
          "timerCanceledEventAttributes": {
            "$ref": "#/components/schemas/TimerCanceledEventAttributes"
          },
          "markerRecordedEventAttributes": {
            "$ref": "#/components/schemas/MarkerRecordedEventAttributes"
          },
          "workflowExecutionSignaledEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionSignaledEventAttributes"
          },
          "workflowExecutionTerminatedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionTerminatedEventAttributes"
          },
          "workflowExecutionCancelRequestedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionCancelRequestedEventAttributes"
          },
          "workflowExecutionCanceledEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionCanceledEventAttributes"
          },
          "requestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
            "$ref": "#/components/schemas/RequestCancelExternalWorkflowExecutionInitiatedEventAttributes"
          },
          "requestCancelExternalWorkflowExecutionFailedEventAttributes": {
            "$ref": "#/components/schemas/RequestCancelExternalWorkflowExecutionFailedEventAttributes"
          },
          "externalWorkflowExecutionCancelRequestedEventAttributes": {
            "$ref": "#/components/schemas/ExternalWorkflowExecutionCancelRequestedEventAttributes"
          },
          "workflowExecutionContinuedAsNewEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionContinuedAsNewEventAttributes"
          },
          "startChildWorkflowExecutionInitiatedEventAttributes": {
            "$ref": "#/components/schemas/StartChildWorkflowExecutionInitiatedEventAttributes"
          },
          "startChildWorkflowExecutionFailedEventAttributes": {
            "$ref": "#/components/schemas/StartChildWorkflowExecutionFailedEventAttributes"
          },
          "childWorkflowExecutionStartedEventAttributes": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionStartedEventAttributes"
          },
          "childWorkflowExecutionCompletedEventAttributes": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionCompletedEventAttributes"
          },
          "childWorkflowExecutionFailedEventAttributes": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionFailedEventAttributes"
          },
          "childWorkflowExecutionCanceledEventAttributes": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionCanceledEventAttributes"
          },
          "childWorkflowExecutionTimedOutEventAttributes": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionTimedOutEventAttributes"
          },
          "childWorkflowExecutionTerminatedEventAttributes": {
            "$ref": "#/components/schemas/ChildWorkflowExecutionTerminatedEventAttributes"
          },
          "signalExternalWorkflowExecutionInitiatedEventAttributes": {
            "$ref": "#/components/schemas/SignalExternalWorkflowExecutionInitiatedEventAttributes"
          },
          "signalExternalWorkflowExecutionFailedEventAttributes": {
            "$ref": "#/components/schemas/SignalExternalWorkflowExecutionFailedEventAttributes"
          },
          "externalWorkflowExecutionSignaledEventAttributes": {
            "$ref": "#/components/schemas/ExternalWorkflowExecutionSignaledEventAttributes"
          },
          "upsertWorkflowSearchAttributesEventAttributes": {
            "$ref": "#/components/schemas/UpsertWorkflowSearchAttributesEventAttributes"
          },
          "workflowExecutionUpdateAcceptedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionUpdateAcceptedEventAttributes"
          },
          "workflowExecutionUpdateRejectedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionUpdateRejectedEventAttributes"
          },
          "workflowExecutionUpdateCompletedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionUpdateCompletedEventAttributes"
          },
          "workflowPropertiesModifiedExternallyEventAttributes": {
            "$ref": "#/components/schemas/WorkflowPropertiesModifiedExternallyEventAttributes"
          },
          "activityPropertiesModifiedExternallyEventAttributes": {
            "$ref": "#/components/schemas/ActivityPropertiesModifiedExternallyEventAttributes"
          },
          "workflowPropertiesModifiedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowPropertiesModifiedEventAttributes"
          },
          "workflowExecutionUpdateAdmittedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionUpdateAdmittedEventAttributes"
          },
          "nexusOperationScheduledEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationScheduledEventAttributes"
          },
          "nexusOperationStartedEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationStartedEventAttributes"
          },
          "nexusOperationCompletedEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationCompletedEventAttributes"
          },
          "nexusOperationFailedEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationFailedEventAttributes"
          },
          "nexusOperationCanceledEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationCanceledEventAttributes"
          },
          "nexusOperationTimedOutEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationTimedOutEventAttributes"
          },
          "nexusOperationCancelRequestedEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationCancelRequestedEventAttributes"
          },
          "workflowExecutionOptionsUpdatedEventAttributes": {
            "$ref": "#/components/schemas/WorkflowExecutionOptionsUpdatedEventAttributes"
          },
          "nexusOperationCancelRequestCompletedEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationCancelRequestCompletedEventAttributes"
          },
          "nexusOperationCancelRequestFailedEventAttributes": {
            "$ref": "#/components/schemas/NexusOperationCancelRequestFailedEventAttributes"
          }
        },
        "description": "History events are the method by which Temporal SDKs advance (or recreate) workflow state.\n See the `EventType` enum for more info about what each event is for."
      },
      "Input": {
        "type": "object",
        "properties": {
          "header": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Header"
              }
            ],
            "description": "Headers that are passed with the Update from the requesting entity.\n These can include things like auth or tracing tokens."
          },
          "name": {
            "type": "string",
            "description": "The name of the Update handler to invoke on the target Workflow."
          },
          "args": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "The arguments to pass to the named Update handler."
          }
        }
      },
      "IntervalSpec": {
        "type": "object",
        "properties": {
          "interval": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          },
          "phase": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          }
        },
        "description": "IntervalSpec matches times that can be expressed as:\n epoch + n * interval + phase\n where n is an integer.\n phase defaults to zero if missing. interval is required.\n Both interval and phase must be non-negative and are truncated to the nearest\n second before any calculations.\n For example, an interval of 1 hour with phase of zero would match every hour,\n on the hour. The same interval but a phase of 19 minutes would match every\n xx:19:00. An interval of 28 days with phase zero would match\n 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3\n days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead."
      },
      "Link": {
        "type": "object",
        "properties": {
          "workflowEvent": {
            "$ref": "#/components/schemas/Link_WorkflowEvent"
          },
          "batchJob": {
            "$ref": "#/components/schemas/Link_BatchJob"
          }
        },
        "description": "Link can be associated with history events. It might contain information about an external entity\n related to the history event. For example, workflow A makes a Nexus call that starts workflow B:\n in this case, a history event in workflow A could contain a Link to the workflow started event in\n workflow B, and vice-versa."
      },
      "Link_BatchJob": {
        "type": "object",
        "properties": {
          "jobId": {
            "type": "string"
          }
        },
        "description": "A link to a built-in batch job.\n Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).\n This link can be put on workflow history events generated by actions taken by a batch job."
      },
      "Link_WorkflowEvent": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowId": {
            "type": "string"
          },
          "runId": {
            "type": "string"
          },
          "eventRef": {
            "$ref": "#/components/schemas/WorkflowEvent_EventReference"
          }
        }
      },
      "ListArchivedWorkflowExecutionsResponse": {
        "type": "object",
        "properties": {
          "executions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowExecutionInfo"
            }
          },
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "ListBatchOperationsResponse": {
        "type": "object",
        "properties": {
          "operationInfo": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BatchOperationInfo"
            },
            "description": "BatchOperationInfo contains the basic info about batch operation"
          },
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "ListDeploymentsResponse": {
        "type": "object",
        "properties": {
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          },
          "deployments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DeploymentListInfo"
            }
          }
        },
        "description": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
      },
      "ListNamespacesResponse": {
        "type": "object",
        "properties": {
          "namespaces": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DescribeNamespaceResponse"
            }
          },
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "ListNexusEndpointsResponse": {
        "type": "object",
        "properties": {
          "nextPageToken": {
            "type": "string",
            "description": "Token for getting the next page.",
            "format": "bytes"
          },
          "endpoints": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Endpoint"
            }
          }
        }
      },
      "ListScheduleMatchingTimesResponse": {
        "type": "object",
        "properties": {
          "startTime": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "date-time"
            }
          }
        }
      },
      "ListSchedulesResponse": {
        "type": "object",
        "properties": {
          "schedules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduleListEntry"
            }
          },
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "ListSearchAttributesResponse": {
        "type": "object",
        "properties": {
          "customAttributes": {
            "type": "object",
            "additionalProperties": {
              "enum": [
                "INDEXED_VALUE_TYPE_UNSPECIFIED",
                "INDEXED_VALUE_TYPE_TEXT",
                "INDEXED_VALUE_TYPE_KEYWORD",
                "INDEXED_VALUE_TYPE_INT",
                "INDEXED_VALUE_TYPE_DOUBLE",
                "INDEXED_VALUE_TYPE_BOOL",
                "INDEXED_VALUE_TYPE_DATETIME",
                "INDEXED_VALUE_TYPE_KEYWORD_LIST"
              ],
              "type": "string",
              "format": "enum"
            },
            "description": "Mapping between custom (user-registered) search attribute name to its IndexedValueType."
          },
          "systemAttributes": {
            "type": "object",
            "additionalProperties": {
              "enum": [
                "INDEXED_VALUE_TYPE_UNSPECIFIED",
                "INDEXED_VALUE_TYPE_TEXT",
                "INDEXED_VALUE_TYPE_KEYWORD",
                "INDEXED_VALUE_TYPE_INT",
                "INDEXED_VALUE_TYPE_DOUBLE",
                "INDEXED_VALUE_TYPE_BOOL",
                "INDEXED_VALUE_TYPE_DATETIME",
                "INDEXED_VALUE_TYPE_KEYWORD_LIST"
              ],
              "type": "string",
              "format": "enum"
            },
            "description": "Mapping between system (predefined) search attribute name to its IndexedValueType."
          },
          "storageSchema": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Mapping from the attribute name to the visibility storage native type."
          }
        }
      },
      "ListWorkerDeploymentsResponse": {
        "type": "object",
        "properties": {
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          },
          "workerDeployments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ListWorkerDeploymentsResponse_WorkerDeploymentSummary"
            },
            "description": "The list of worker deployments."
          }
        }
      },
      "ListWorkerDeploymentsResponse_WorkerDeploymentSummary": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "routingConfig": {
            "$ref": "#/components/schemas/RoutingConfig"
          }
        },
        "description": "A subset of WorkerDeploymentInfo"
      },
      "ListWorkflowExecutionsResponse": {
        "type": "object",
        "properties": {
          "executions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowExecutionInfo"
            }
          },
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "ListWorkflowRulesResponse": {
        "type": "object",
        "properties": {
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowRule"
            }
          },
          "nextPageToken": {
            "type": "string",
            "format": "bytes"
          }
        }
      },
      "MarkerRecordedEventAttributes": {
        "type": "object",
        "properties": {
          "markerName": {
            "type": "string",
            "description": "Workers use this to identify the \"types\" of various markers. Ex: Local activity, side effect."
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payloads"
            },
            "description": "Serialized information recorded in the marker"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Some uses of markers, like a local activity, could \"fail\". If they did that is recorded here."
          }
        }
      },
      "Memo": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            }
          }
        },
        "description": "A user-defined set of *unindexed* fields that are exposed when listing/searching workflows"
      },
      "Message": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "An ID for this specific message."
          },
          "protocolInstanceId": {
            "type": "string",
            "description": "Identifies the specific instance of a protocol to which this message\n belongs."
          },
          "eventId": {
            "type": "string"
          },
          "commandIndex": {
            "type": "string"
          },
          "body": {
            "allOf": [
              {
                "$ref": "#/components/schemas/GoogleProtobufAny"
              }
            ],
            "description": "The opaque data carried by this message. The protocol type can be\n extracted from the package name of the message carried inside the Any."
          }
        },
        "description": "(-- api-linter: core::0146::any=disabled\n     aip.dev/not-precedent: We want runtime extensibility for the body field --)"
      },
      "Meta": {
        "type": "object",
        "properties": {
          "updateId": {
            "type": "string",
            "description": "An ID with workflow-scoped uniqueness for this Update."
          },
          "identity": {
            "type": "string",
            "description": "A string identifying the agent that requested this Update."
          }
        },
        "description": "Metadata about a Workflow Update."
      },
      "MeteringMetadata": {
        "type": "object",
        "properties": {
          "nonfirstLocalActivityExecutionAttempts": {
            "type": "integer",
            "description": "Count of local activities which have begun an execution attempt during this workflow task,\n and whose first attempt occurred in some previous task. This is used for metering\n purposes, and does not affect workflow state.\n\n (-- api-linter: core::0141::forbidden-types=disabled\n     aip.dev/not-precedent: Negative values make no sense to represent. --)",
            "format": "uint32"
          }
        },
        "description": "Metadata relevant for metering purposes"
      },
      "NamespaceConfig": {
        "type": "object",
        "properties": {
          "workflowExecutionRetentionTtl": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          },
          "badBinaries": {
            "$ref": "#/components/schemas/BadBinaries"
          },
          "historyArchivalState": {
            "enum": [
              "ARCHIVAL_STATE_UNSPECIFIED",
              "ARCHIVAL_STATE_DISABLED",
              "ARCHIVAL_STATE_ENABLED"
            ],
            "type": "string",
            "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.",
            "format": "enum"
          },
          "historyArchivalUri": {
            "type": "string"
          },
          "visibilityArchivalState": {
            "enum": [
              "ARCHIVAL_STATE_UNSPECIFIED",
              "ARCHIVAL_STATE_DISABLED",
              "ARCHIVAL_STATE_ENABLED"
            ],
            "type": "string",
            "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.",
            "format": "enum"
          },
          "visibilityArchivalUri": {
            "type": "string"
          },
          "customSearchAttributeAliases": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map from field name to alias."
          }
        }
      },
      "NamespaceInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "state": {
            "enum": [
              "NAMESPACE_STATE_UNSPECIFIED",
              "NAMESPACE_STATE_REGISTERED",
              "NAMESPACE_STATE_DEPRECATED",
              "NAMESPACE_STATE_DELETED"
            ],
            "type": "string",
            "format": "enum"
          },
          "description": {
            "type": "string"
          },
          "ownerEmail": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A key-value map for any customized purpose."
          },
          "id": {
            "type": "string"
          },
          "capabilities": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NamespaceInfo_Capabilities"
              }
            ],
            "description": "All capabilities the namespace supports."
          },
          "supportsSchedules": {
            "type": "boolean",
            "description": "Whether scheduled workflows are supported on this namespace. This is only needed\n temporarily while the feature is experimental, so we can give it a high tag."
          }
        }
      },
      "NamespaceInfo_Capabilities": {
        "type": "object",
        "properties": {
          "eagerWorkflowStart": {
            "type": "boolean",
            "description": "True if the namespace supports eager workflow start."
          },
          "syncUpdate": {
            "type": "boolean",
            "description": "True if the namespace supports sync update"
          },
          "asyncUpdate": {
            "type": "boolean",
            "description": "True if the namespace supports async update"
          }
        },
        "description": "Namespace capability details. Should contain what features are enabled in a namespace."
      },
      "NamespaceReplicationConfig": {
        "type": "object",
        "properties": {
          "activeClusterName": {
            "type": "string"
          },
          "clusters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClusterReplicationConfig"
            }
          },
          "state": {
            "enum": [
              "REPLICATION_STATE_UNSPECIFIED",
              "REPLICATION_STATE_NORMAL",
              "REPLICATION_STATE_HANDOVER"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "NewWorkflowExecutionInfo": {
        "type": "object",
        "properties": {
          "workflowId": {
            "type": "string"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized arguments to the workflow."
          },
          "workflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Total workflow execution timeout including retries and continue as new."
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow run."
          },
          "workflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow task."
          },
          "workflowIdReusePolicy": {
            "enum": [
              "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
              "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
            ],
            "type": "string",
            "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.",
            "format": "enum"
          },
          "retryPolicy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RetryPolicy"
              }
            ],
            "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
          },
          "cronSchedule": {
            "type": "string",
            "description": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "userMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserMetadata"
              }
            ],
            "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig\n for use by user interfaces to display the fixed as-of-start summary and details of the\n workflow."
          },
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\n To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        },
        "description": "NewWorkflowExecutionInfo is a shared message that encapsulates all the\n required arguments to starting a workflow in different contexts."
      },
      "NexusHandlerFailureInfo": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "The Nexus error type as defined in the spec:\n https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors."
          },
          "retryBehavior": {
            "enum": [
              "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED",
              "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE",
              "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE"
            ],
            "type": "string",
            "description": "Retry behavior, defaults to the retry behavior of the error type as defined in the spec.",
            "format": "enum"
          }
        }
      },
      "NexusOperationCancelRequestCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "requestedEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event."
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\n with."
          }
        }
      },
      "NexusOperationCancelRequestFailedEventAttributes": {
        "type": "object",
        "properties": {
          "requestedEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event."
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\n with."
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo."
          }
        }
      },
      "NexusOperationCancelRequestedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to."
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\n with."
          }
        }
      },
      "NexusOperationCanceledEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Cancellation details."
          },
          "requestId": {
            "type": "string",
            "description": "The request ID allocated at schedule time."
          }
        },
        "description": "Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow."
      },
      "NexusOperationCancellationInfo": {
        "type": "object",
        "properties": {
          "requestedTime": {
            "type": "string",
            "description": "The time when cancellation was requested.",
            "format": "date-time"
          },
          "state": {
            "enum": [
              "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED",
              "NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED",
              "NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF",
              "NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED",
              "NEXUS_OPERATION_CANCELLATION_STATE_FAILED",
              "NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT",
              "NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED"
            ],
            "type": "string",
            "format": "enum"
          },
          "attempt": {
            "type": "integer",
            "description": "The number of attempts made to deliver the cancel operation request.\n This number represents a minimum bound since the attempt is incremented after the request completes.",
            "format": "int32"
          },
          "lastAttemptCompleteTime": {
            "type": "string",
            "description": "The time when the last attempt completed.",
            "format": "date-time"
          },
          "lastAttemptFailure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "The last attempt's failure, if any."
          },
          "nextAttemptScheduleTime": {
            "type": "string",
            "description": "The time when the next attempt is scheduled.",
            "format": "date-time"
          },
          "blockedReason": {
            "type": "string",
            "description": "If the state is BLOCKED, blocked reason provides additional information."
          }
        },
        "description": "NexusOperationCancellationInfo contains the state of a nexus operation cancellation."
      },
      "NexusOperationCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
          },
          "result": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payload"
              }
            ],
            "description": "Serialized result of the Nexus operation. The response of the Nexus handler.\n Delivered either via a completion callback or as a response to a synchronous operation."
          },
          "requestId": {
            "type": "string",
            "description": "The request ID allocated at schedule time."
          }
        },
        "description": "Nexus operation completed successfully."
      },
      "NexusOperationFailedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo."
          },
          "requestId": {
            "type": "string",
            "description": "The request ID allocated at schedule time."
          }
        },
        "description": "Nexus operation failed."
      },
      "NexusOperationFailureInfo": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The NexusOperationScheduled event ID."
          },
          "endpoint": {
            "type": "string",
            "description": "Endpoint name."
          },
          "service": {
            "type": "string",
            "description": "Service name."
          },
          "operation": {
            "type": "string",
            "description": "Operation name."
          },
          "operationId": {
            "type": "string",
            "description": "Operation ID - may be empty if the operation completed synchronously.\n\n Deprecated: Renamed to operation_token."
          },
          "operationToken": {
            "type": "string",
            "description": "Operation token - may be empty if the operation completed synchronously."
          }
        }
      },
      "NexusOperationScheduledEventAttributes": {
        "type": "object",
        "properties": {
          "endpoint": {
            "type": "string",
            "description": "Endpoint name, must exist in the endpoint registry."
          },
          "service": {
            "type": "string",
            "description": "Service name."
          },
          "operation": {
            "type": "string",
            "description": "Operation name."
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payload"
              }
            ],
            "description": "Input for the operation. The server converts this into Nexus request content and the appropriate content headers\n internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the\n content is transformed back to the original Payload stored in this event."
          },
          "scheduleToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Schedule-to-close timeout for this operation.\n Indicates how long the caller is willing to wait for operation completion.\n Calls are retried internally by the server.\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "nexusHeader": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal\n activities and child workflows, these are transmitted to Nexus operations that may be external and are not\n traditional payloads."
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with."
          },
          "requestId": {
            "type": "string",
            "description": "A unique ID generated by the history service upon creation of this event.\n The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key."
          },
          "endpointId": {
            "type": "string",
            "description": "Endpoint ID as resolved in the endpoint registry at the time this event was generated.\n This is stored on the event and used internally by the server in case the endpoint is renamed from the time the\n event was originally scheduled."
          }
        },
        "description": "Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command."
      },
      "NexusOperationStartedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to."
          },
          "operationId": {
            "type": "string",
            "description": "The operation ID returned by the Nexus handler in the response to the StartOperation request.\n This ID is used when canceling the operation.\n\n Deprecated: Renamed to operation_token."
          },
          "requestId": {
            "type": "string",
            "description": "The request ID allocated at schedule time."
          },
          "operationToken": {
            "type": "string",
            "description": "The operation token returned by the Nexus handler in the response to the StartOperation request.\n This token is used when canceling the operation."
          }
        },
        "description": "Event marking an asynchronous operation was started by the responding Nexus handler.\n If the operation completes synchronously, this event is not generated.\n In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate\n this event upon receiving the operation completion via callback."
      },
      "NexusOperationTimedOutEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo."
          },
          "requestId": {
            "type": "string",
            "description": "The request ID allocated at schedule time."
          }
        },
        "description": "Nexus operation timed out."
      },
      "OnConflictOptions": {
        "type": "object",
        "properties": {
          "attachRequestId": {
            "type": "boolean",
            "description": "Attaches the request ID to the running workflow."
          },
          "attachCompletionCallbacks": {
            "type": "boolean",
            "description": "Attaches the completion callbacks to the running workflow."
          },
          "attachLinks": {
            "type": "boolean",
            "description": "Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event."
          }
        },
        "description": "When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and\n there is already an existing running workflow, OnConflictOptions defines actions to be taken on\n the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent\n history event in the running workflow with the changes requested in this object."
      },
      "Outcome": {
        "type": "object",
        "properties": {
          "success": {
            "$ref": "#/components/schemas/Payloads"
          },
          "failure": {
            "$ref": "#/components/schemas/Failure"
          }
        },
        "description": "The outcome of a Workflow Update: success or failure."
      },
      "PatchScheduleRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace of the schedule to patch."
          },
          "scheduleId": {
            "type": "string",
            "description": "The id of the schedule to patch."
          },
          "patch": {
            "$ref": "#/components/schemas/SchedulePatch"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request."
          },
          "requestId": {
            "type": "string",
            "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
          }
        }
      },
      "PatchScheduleResponse": {
        "type": "object",
        "properties": {}
      },
      "PauseActivityRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity."
          },
          "execution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Execution info of the workflow which scheduled this activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request."
          },
          "id": {
            "type": "string",
            "description": "Only the activity with this ID will be paused."
          },
          "type": {
            "type": "string",
            "description": "Pause all running activities of this type."
          }
        }
      },
      "PauseActivityResponse": {
        "type": "object",
        "properties": {}
      },
      "Payload": {
        "description": "Represents some binary (byte array) data (ex: activity input parameters or workflow result) with\n metadata which describes this binary data (format, encoding, encryption, etc). Serialization\n of the data may be user-defined."
      },
      "Payloads": {
        "type": "object",
        "properties": {
          "payloads": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Payload"
            }
          }
        },
        "description": "See `Payload`"
      },
      "PendingActivityInfo": {
        "type": "object",
        "properties": {
          "activityId": {
            "type": "string"
          },
          "activityType": {
            "$ref": "#/components/schemas/ActivityType"
          },
          "state": {
            "enum": [
              "PENDING_ACTIVITY_STATE_UNSPECIFIED",
              "PENDING_ACTIVITY_STATE_SCHEDULED",
              "PENDING_ACTIVITY_STATE_STARTED",
              "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED",
              "PENDING_ACTIVITY_STATE_PAUSED",
              "PENDING_ACTIVITY_STATE_PAUSE_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          },
          "heartbeatDetails": {
            "$ref": "#/components/schemas/Payloads"
          },
          "lastHeartbeatTime": {
            "type": "string",
            "format": "date-time"
          },
          "lastStartedTime": {
            "type": "string",
            "format": "date-time"
          },
          "attempt": {
            "type": "integer",
            "format": "int32"
          },
          "maximumAttempts": {
            "type": "integer",
            "format": "int32"
          },
          "scheduledTime": {
            "type": "string",
            "format": "date-time"
          },
          "expirationTime": {
            "type": "string",
            "format": "date-time"
          },
          "lastFailure": {
            "$ref": "#/components/schemas/Failure"
          },
          "lastWorkerIdentity": {
            "type": "string"
          },
          "lastIndependentlyAssignedBuildId": {
            "type": "string",
            "description": "This means the activity is independently versioned and not bound to the build ID of its workflow.\n The activity will use the build id in this field instead.\n If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning\n rules."
          },
          "lastWorkerVersionStamp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "The version stamp of the worker to whom this activity was most recently dispatched\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "currentRetryInterval": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "The time activity will wait until the next retry.\n If activity is currently running it will be next retry interval if activity failed.\n If activity is currently waiting it will be current retry interval.\n If there will be no retry it will be null."
          },
          "lastAttemptCompleteTime": {
            "type": "string",
            "description": "The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.",
            "format": "date-time"
          },
          "nextAttemptScheduleTime": {
            "type": "string",
            "description": "Next time when activity will be scheduled.\n If activity is currently scheduled or started it will be null.",
            "format": "date-time"
          },
          "paused": {
            "type": "boolean",
            "description": "Indicates if activity is paused."
          },
          "lastDeployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "The deployment this activity was dispatched to most recently. Present only if the activity\n was dispatched to a versioned worker.\n Deprecated. Use `last_worker_deployment_version`."
          },
          "lastWorkerDeploymentVersion": {
            "type": "string",
            "description": "The Worker Deployment Version this activity was dispatched to most recently."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        }
      },
      "PendingChildExecutionInfo": {
        "type": "object",
        "properties": {
          "workflowId": {
            "type": "string"
          },
          "runId": {
            "type": "string"
          },
          "workflowTypeName": {
            "type": "string"
          },
          "initiatedId": {
            "type": "string"
          },
          "parentClosePolicy": {
            "enum": [
              "PARENT_CLOSE_POLICY_UNSPECIFIED",
              "PARENT_CLOSE_POLICY_TERMINATE",
              "PARENT_CLOSE_POLICY_ABANDON",
              "PARENT_CLOSE_POLICY_REQUEST_CANCEL"
            ],
            "type": "string",
            "description": "Default: PARENT_CLOSE_POLICY_TERMINATE.",
            "format": "enum"
          }
        }
      },
      "PendingNexusOperationInfo": {
        "type": "object",
        "properties": {
          "endpoint": {
            "type": "string",
            "description": "Endpoint name.\n Resolved to a URL via the cluster's endpoint registry."
          },
          "service": {
            "type": "string",
            "description": "Service name."
          },
          "operation": {
            "type": "string",
            "description": "Operation name."
          },
          "operationId": {
            "type": "string",
            "description": "Operation ID. Only set for asynchronous operations after a successful StartOperation call.\n\n Deprecated: Renamed to operation_token."
          },
          "scheduleToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Schedule-to-close timeout for this operation.\n This is the only timeout settable by a workflow.\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "scheduledTime": {
            "type": "string",
            "description": "The time when the operation was scheduled.",
            "format": "date-time"
          },
          "state": {
            "enum": [
              "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED",
              "PENDING_NEXUS_OPERATION_STATE_SCHEDULED",
              "PENDING_NEXUS_OPERATION_STATE_BACKING_OFF",
              "PENDING_NEXUS_OPERATION_STATE_STARTED",
              "PENDING_NEXUS_OPERATION_STATE_BLOCKED"
            ],
            "type": "string",
            "format": "enum"
          },
          "attempt": {
            "type": "integer",
            "description": "The number of attempts made to deliver the start operation request.\n This number represents a minimum bound since the attempt is incremented after the request completes.",
            "format": "int32"
          },
          "lastAttemptCompleteTime": {
            "type": "string",
            "description": "The time when the last attempt completed.",
            "format": "date-time"
          },
          "lastAttemptFailure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "The last attempt's failure, if any."
          },
          "nextAttemptScheduleTime": {
            "type": "string",
            "description": "The time when the next attempt is scheduled.",
            "format": "date-time"
          },
          "cancellationInfo": {
            "$ref": "#/components/schemas/NexusOperationCancellationInfo"
          },
          "scheduledEventId": {
            "type": "string",
            "description": "The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the\n DescribeWorkflowExecution response with workflow history."
          },
          "blockedReason": {
            "type": "string",
            "description": "If the state is BLOCKED, blocked reason provides additional information."
          },
          "operationToken": {
            "type": "string",
            "description": "Operation token. Only set for asynchronous operations after a successful StartOperation call."
          }
        },
        "description": "PendingNexusOperationInfo contains the state of a pending Nexus operation."
      },
      "PendingWorkflowTaskInfo": {
        "type": "object",
        "properties": {
          "state": {
            "enum": [
              "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED",
              "PENDING_WORKFLOW_TASK_STATE_SCHEDULED",
              "PENDING_WORKFLOW_TASK_STATE_STARTED"
            ],
            "type": "string",
            "format": "enum"
          },
          "scheduledTime": {
            "type": "string",
            "format": "date-time"
          },
          "originalScheduledTime": {
            "type": "string",
            "description": "original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.\n Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command\n In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds\n some threshold, the workflow task will be forced timeout.",
            "format": "date-time"
          },
          "startedTime": {
            "type": "string",
            "format": "date-time"
          },
          "attempt": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "PollWorkflowTaskQueueResponse": {
        "type": "object",
        "properties": {
          "taskToken": {
            "type": "string",
            "description": "A unique identifier for this task",
            "format": "bytes"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "previousStartedEventId": {
            "type": "string",
            "description": "The last workflow task started event which was processed by some worker for this execution.\n Will be zero if no task has ever started."
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the most recent workflow task started event, which will have been generated as a\n result of this poll request being served. Will be zero if the task\n does not contain any events which would advance history (no new WFT started).\n Currently this can happen for queries."
          },
          "attempt": {
            "type": "integer",
            "description": "Starting at 1, the number of attempts to complete this task by any worker.",
            "format": "int32"
          },
          "backlogCountHint": {
            "type": "string",
            "description": "A hint that there are more tasks already present in this task queue\n partition. Can be used to prioritize draining a sticky queue.\n\n Specifically, the returned number is the number of tasks remaining in\n the in-memory buffer for this partition, which is currently capped at\n 1000. Because sticky queues only have one partition, this number is\n more useful when draining them. Normal queues, typically having more than one\n partition, will return a number representing only some portion of the\n overall backlog. Subsequent RPCs may not hit the same partition as\n this call."
          },
          "history": {
            "allOf": [
              {
                "$ref": "#/components/schemas/History"
              }
            ],
            "description": "The history for this workflow, which will either be complete or partial. Partial histories\n are sent to workers who have signaled that they are using a sticky queue when completing\n a workflow task."
          },
          "nextPageToken": {
            "type": "string",
            "description": "Will be set if there are more history events than were included in this response. Such events\n should be fetched via `GetWorkflowExecutionHistory`.",
            "format": "bytes"
          },
          "query": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowQuery"
              }
            ],
            "description": "Legacy queries appear in this field. The query must be responded to via\n `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on\n closed workflows) then the `history` field will be populated with the entire history. It\n may also be populated if this task originates on a non-sticky queue."
          },
          "workflowExecutionTaskQueue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskQueue"
              }
            ],
            "description": "The task queue this task originated from, which will always be the original non-sticky name\n for the queue, even if this response came from polling a sticky queue."
          },
          "scheduledTime": {
            "type": "string",
            "description": "When this task was scheduled by the server",
            "format": "date-time"
          },
          "startedTime": {
            "type": "string",
            "description": "When the current workflow task started event was generated, meaning the current attempt.",
            "format": "date-time"
          },
          "queries": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/WorkflowQuery"
            },
            "description": "Queries that should be executed after applying the history in this task. Responses should be\n attached to `RespondWorkflowTaskCompletedRequest::query_results`"
          },
          "messages": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Message"
            },
            "description": "Protocol messages piggybacking on a WFT as a transport"
          },
          "pollerScalingDecision": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PollerScalingDecision"
              }
            ],
            "description": "Server-advised information the SDK may use to adjust its poller count."
          }
        }
      },
      "PollerInfo": {
        "type": "object",
        "properties": {
          "lastAccessTime": {
            "type": "string",
            "format": "date-time"
          },
          "identity": {
            "type": "string"
          },
          "ratePerSecond": {
            "type": "number",
            "format": "double"
          },
          "workerVersionCapabilities": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionCapabilities"
              }
            ],
            "description": "If a worker has opted into the worker versioning feature while polling, its capabilities will\n appear here.\n Deprecated. Replaced by deployment_options."
          },
          "deploymentOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerDeploymentOptions"
              }
            ],
            "description": "Worker deployment options that SDK sent to server."
          }
        }
      },
      "PollerScalingDecision": {
        "type": "object",
        "properties": {
          "pollRequestDeltaSuggestion": {
            "type": "integer",
            "description": "How many poll requests to suggest should be added or removed, if any. As of now, server only\n scales up or down by 1. However, SDKs should allow for other values (while staying within\n defined min/max).\n\n The SDK is free to ignore this suggestion, EX: making more polls would not make sense because\n all slots are already occupied.",
            "format": "int32"
          }
        },
        "description": "Attached to task responses to give hints to the SDK about how it may adjust its number of\n pollers."
      },
      "Priority": {
        "type": "object",
        "properties": {
          "priorityKey": {
            "type": "integer",
            "description": "Priority key is a positive integer from 1 to n, where smaller integers\n correspond to higher priorities (tasks run sooner). In general, tasks in\n a queue should be processed in close to priority order, although small\n deviations are possible.\n\n The maximum priority value (minimum priority) is determined by server\n configuration, and defaults to 5.\n\n The default priority is (min+max)/2. With the default max of 5 and min of\n 1, that comes out to 3.",
            "format": "int32"
          }
        },
        "description": "Priority contains metadata that controls relative ordering of task processing\n when tasks are backlogged in a queue. Initially, Priority will be used in\n activity and workflow task queues, which are typically where backlogs exist.\n Other queues in the server (such as transfer and timer queues) and rate\n limiting decisions do not use Priority, but may in the future.\n\n Priority is attached to workflows and activities. Activities and child\n workflows inherit Priority from the workflow that created them, but may\n override fields when they are started or modified. For each field of a\n Priority on an activity/workflow, not present or equal to zero/empty string\n means to inherit the value from the calling workflow, or if there is no\n calling workflow, then use the default (documented below).\n\n Despite being named \"Priority\", this message will also contains fields that\n control \"fairness\" mechanisms.\n\n The overall semantics of Priority are:\n 1. First, consider \"priority_key\": lower number goes first.\n (more will be added here later)"
      },
      "QueryRejected": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
              "WORKFLOW_EXECUTION_STATUS_RUNNING",
              "WORKFLOW_EXECUTION_STATUS_COMPLETED",
              "WORKFLOW_EXECUTION_STATUS_FAILED",
              "WORKFLOW_EXECUTION_STATUS_CANCELED",
              "WORKFLOW_EXECUTION_STATUS_TERMINATED",
              "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
              "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "QueryWorkflowRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "execution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "query": {
            "$ref": "#/components/schemas/WorkflowQuery"
          },
          "queryRejectCondition": {
            "enum": [
              "QUERY_REJECT_CONDITION_UNSPECIFIED",
              "QUERY_REJECT_CONDITION_NONE",
              "QUERY_REJECT_CONDITION_NOT_OPEN",
              "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY"
            ],
            "type": "string",
            "description": "QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.\n Default: QUERY_REJECT_CONDITION_NONE.",
            "format": "enum"
          }
        }
      },
      "QueryWorkflowResponse": {
        "type": "object",
        "properties": {
          "queryResult": {
            "$ref": "#/components/schemas/Payloads"
          },
          "queryRejected": {
            "$ref": "#/components/schemas/QueryRejected"
          }
        }
      },
      "RampByPercentage": {
        "type": "object",
        "properties": {
          "rampPercentage": {
            "type": "number",
            "description": "Acceptable range is [0,100).",
            "format": "float"
          }
        }
      },
      "Range": {
        "type": "object",
        "properties": {
          "start": {
            "type": "integer",
            "description": "Start of range (inclusive).",
            "format": "int32"
          },
          "end": {
            "type": "integer",
            "description": "End of range (inclusive).",
            "format": "int32"
          },
          "step": {
            "type": "integer",
            "description": "Step (optional, default 1).",
            "format": "int32"
          }
        },
        "description": "Range represents a set of integer values, used to match fields of a calendar\n time in StructuredCalendarSpec. If end < start, then end is interpreted as\n equal to start. This means you can use a Range with start set to a value, and\n end and step unset (defaulting to 0) to represent a single value."
      },
      "RecordActivityTaskHeartbeatByIdRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity"
          },
          "workflowId": {
            "type": "string",
            "description": "Id of the workflow which scheduled this activity"
          },
          "runId": {
            "type": "string",
            "description": "Run Id of the workflow which scheduled this activity"
          },
          "activityId": {
            "type": "string",
            "description": "Id of the activity we're heartbeating"
          },
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Arbitrary data, of which the most recent call is kept, to store for this activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        }
      },
      "RecordActivityTaskHeartbeatByIdResponse": {
        "type": "object",
        "properties": {
          "cancelRequested": {
            "type": "boolean",
            "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\n notify the activity of cancellation if it is still running."
          },
          "activityPaused": {
            "type": "boolean",
            "description": "Will be set to true if the activity is paused."
          }
        }
      },
      "RecordActivityTaskHeartbeatRequest": {
        "type": "object",
        "properties": {
          "taskToken": {
            "type": "string",
            "description": "The task token as received in `PollActivityTaskQueueResponse`",
            "format": "bytes"
          },
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Arbitrary data, of which the most recent call is kept, to store for this activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "namespace": {
            "type": "string"
          }
        }
      },
      "RecordActivityTaskHeartbeatResponse": {
        "type": "object",
        "properties": {
          "cancelRequested": {
            "type": "boolean",
            "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\n notify the activity of cancellation if it is still running."
          },
          "activityPaused": {
            "type": "boolean",
            "description": "Will be set to true if the activity is paused."
          }
        }
      },
      "RegisterNamespaceRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "ownerEmail": {
            "type": "string"
          },
          "workflowExecutionRetentionPeriod": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          },
          "clusters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClusterReplicationConfig"
            }
          },
          "activeClusterName": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A key-value map for any customized purpose."
          },
          "securityToken": {
            "type": "string"
          },
          "isGlobalNamespace": {
            "type": "boolean"
          },
          "historyArchivalState": {
            "enum": [
              "ARCHIVAL_STATE_UNSPECIFIED",
              "ARCHIVAL_STATE_DISABLED",
              "ARCHIVAL_STATE_ENABLED"
            ],
            "type": "string",
            "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.",
            "format": "enum"
          },
          "historyArchivalUri": {
            "type": "string"
          },
          "visibilityArchivalState": {
            "enum": [
              "ARCHIVAL_STATE_UNSPECIFIED",
              "ARCHIVAL_STATE_DISABLED",
              "ARCHIVAL_STATE_ENABLED"
            ],
            "type": "string",
            "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.",
            "format": "enum"
          },
          "visibilityArchivalUri": {
            "type": "string"
          }
        }
      },
      "RegisterNamespaceResponse": {
        "type": "object",
        "properties": {}
      },
      "ReleaseInfo": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string"
          },
          "releaseTime": {
            "type": "string",
            "format": "date-time"
          },
          "notes": {
            "type": "string"
          }
        },
        "description": "ReleaseInfo contains information about specific version of temporal."
      },
      "Request": {
        "type": "object",
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "input": {
            "$ref": "#/components/schemas/Input"
          }
        },
        "description": "The client request that triggers a Workflow Update."
      },
      "RequestCancelExternalWorkflowExecutionFailedEventAttributes": {
        "type": "object",
        "properties": {
          "cause": {
            "enum": [
              "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
              "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
              "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
            ],
            "type": "string",
            "format": "enum"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which failed to cancel.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure\n corresponds to"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          }
        }
      },
      "RequestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
        "type": "object",
        "properties": {
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "namespace": {
            "type": "string",
            "description": "The namespace the workflow to be cancelled lives in.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          },
          "childWorkflowOnly": {
            "type": "boolean",
            "description": "Workers are expected to set this to true if the workflow they are requesting to cancel is\n a child of the workflow which issued the request"
          },
          "reason": {
            "type": "string",
            "description": "Reason for requesting the cancellation"
          }
        }
      },
      "RequestCancelWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "requestId": {
            "type": "string",
            "description": "Used to de-dupe cancellation requests"
          },
          "firstExecutionRunId": {
            "type": "string",
            "description": "If set, this call will error if the most recent (if no run id is set on\n `workflow_execution`), or specified (if it is) workflow execution is not part of the same\n execution chain as this id."
          },
          "reason": {
            "type": "string",
            "description": "Reason for requesting the cancellation"
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Links to be associated with the WorkflowExecutionCanceled event."
          }
        }
      },
      "RequestCancelWorkflowExecutionResponse": {
        "type": "object",
        "properties": {}
      },
      "ResetActivityRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity."
          },
          "execution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Execution info of the workflow which scheduled this activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request."
          },
          "id": {
            "type": "string",
            "description": "Only activity with this ID will be reset."
          },
          "type": {
            "type": "string",
            "description": "Reset all running activities with of this type."
          },
          "resetHeartbeat": {
            "type": "boolean",
            "description": "Indicates that activity should reset heartbeat details.\n This flag will be applied only to the new instance of the activity."
          },
          "keepPaused": {
            "type": "boolean",
            "description": "if activity is paused, it will remain paused after reset"
          },
          "jitter": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.\n (unless it is paused and keep_paused is set)"
          }
        }
      },
      "ResetActivityResponse": {
        "type": "object",
        "properties": {}
      },
      "ResetOptions": {
        "type": "object",
        "properties": {
          "workflowTaskId": {
            "type": "string",
            "description": "The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n `WORKFLOW_TASK_STARTED` event to reset to.\n Note that this option doesn't make sense when used as part of a batch request."
          },
          "buildId": {
            "type": "string",
            "description": "Resets to the first workflow task processed by this build id.\n If the workflow was not processed by the build id, or the workflow task can't be\n determined, no reset will be performed.\n Note that by default, this reset is allowed to be to a prior run in a chain of\n continue-as-new."
          },
          "resetReapplyType": {
            "enum": [
              "RESET_REAPPLY_TYPE_UNSPECIFIED",
              "RESET_REAPPLY_TYPE_SIGNAL",
              "RESET_REAPPLY_TYPE_NONE",
              "RESET_REAPPLY_TYPE_ALL_ELIGIBLE"
            ],
            "type": "string",
            "description": "Event types to be reapplied (deprecated)\n Default: RESET_REAPPLY_TYPE_SIGNAL",
            "format": "enum"
          },
          "currentRunOnly": {
            "type": "boolean",
            "description": "If true, limit the reset to only within the current run. (Applies to build_id targets and\n possibly others in the future.)"
          },
          "resetReapplyExcludeTypes": {
            "type": "array",
            "items": {
              "enum": [
                "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
                "RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL",
                "RESET_REAPPLY_EXCLUDE_TYPE_UPDATE",
                "RESET_REAPPLY_EXCLUDE_TYPE_NEXUS",
                "RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST"
              ],
              "type": "string",
              "format": "enum"
            },
            "description": "Event types not to be reapplied"
          }
        },
        "description": "Describes where and how to reset a workflow, used for batch reset currently\n and may be used for single-workflow reset later."
      },
      "ResetPointInfo": {
        "type": "object",
        "properties": {
          "buildId": {
            "type": "string",
            "description": "Worker build id."
          },
          "binaryChecksum": {
            "type": "string",
            "description": "A worker binary version identifier (deprecated)."
          },
          "runId": {
            "type": "string",
            "description": "The first run ID in the execution chain that was touched by this worker build."
          },
          "firstWorkflowTaskCompletedId": {
            "type": "string",
            "description": "Event ID of the first WorkflowTaskCompleted event processed by this worker build."
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "expireTime": {
            "type": "string",
            "description": "(-- api-linter: core::0214::resource-expiry=disabled\n     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)\n The time that the run is deleted due to retention.",
            "format": "date-time"
          },
          "resettable": {
            "type": "boolean",
            "description": "false if the reset point has pending childWFs/reqCancels/signalExternals."
          }
        },
        "description": "ResetPointInfo records the workflow event id that is the first one processed by a given\n build id or binary checksum. A new reset point will be created if either build id or binary\n checksum changes (although in general only one or the other will be used at a time)."
      },
      "ResetPoints": {
        "type": "object",
        "properties": {
          "points": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ResetPointInfo"
            }
          }
        }
      },
      "ResetWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "The workflow to reset. If this contains a run ID then the workflow will be reset back to the\n provided event ID in that run. Otherwise it will be reset to the provided event ID in the\n current run. In all cases the current run will be terminated and a new run started."
          },
          "reason": {
            "type": "string"
          },
          "workflowTaskFinishEventId": {
            "type": "string",
            "description": "The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n `WORKFLOW_TASK_STARTED` event to reset to."
          },
          "requestId": {
            "type": "string",
            "description": "Used to de-dupe reset requests"
          },
          "resetReapplyType": {
            "enum": [
              "RESET_REAPPLY_TYPE_UNSPECIFIED",
              "RESET_REAPPLY_TYPE_SIGNAL",
              "RESET_REAPPLY_TYPE_NONE",
              "RESET_REAPPLY_TYPE_ALL_ELIGIBLE"
            ],
            "type": "string",
            "description": "Event types to be reapplied (deprecated)\n Default: RESET_REAPPLY_TYPE_SIGNAL",
            "format": "enum"
          },
          "resetReapplyExcludeTypes": {
            "type": "array",
            "items": {
              "enum": [
                "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
                "RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL",
                "RESET_REAPPLY_EXCLUDE_TYPE_UPDATE",
                "RESET_REAPPLY_EXCLUDE_TYPE_NEXUS",
                "RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST"
              ],
              "type": "string",
              "format": "enum"
            },
            "description": "Event types not to be reapplied"
          }
        }
      },
      "ResetWorkflowExecutionResponse": {
        "type": "object",
        "properties": {
          "runId": {
            "type": "string"
          }
        }
      },
      "ResetWorkflowFailureInfo": {
        "type": "object",
        "properties": {
          "lastHeartbeatDetails": {
            "$ref": "#/components/schemas/Payloads"
          }
        }
      },
      "RespondActivityTaskCanceledByIdRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity"
          },
          "workflowId": {
            "type": "string",
            "description": "Id of the workflow which scheduled this activity"
          },
          "runId": {
            "type": "string",
            "description": "Run Id of the workflow which scheduled this activity"
          },
          "activityId": {
            "type": "string",
            "description": "Id of the activity to confirm is cancelled"
          },
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized additional information to attach to the cancellation"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        }
      },
      "RespondActivityTaskCanceledByIdResponse": {
        "type": "object",
        "properties": {}
      },
      "RespondActivityTaskCanceledRequest": {
        "type": "object",
        "properties": {
          "taskToken": {
            "type": "string",
            "description": "The task token as received in `PollActivityTaskQueueResponse`",
            "format": "bytes"
          },
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized additional information to attach to the cancellation"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "namespace": {
            "type": "string"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this task. This message's `build_id` field should\n always be set by SDKs. Workers opting into versioning will also set the `use_versioning`\n field to true. See message docstrings for more.\n Deprecated. Use `deployment` instead."
          },
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "Deployment info of the worker that completed this task. Must be present if user has set\n `WorkerDeploymentOptions` regardless of versioning being enabled or not.\n Deprecated. Replaced with `deployment_options`."
          },
          "deploymentOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerDeploymentOptions"
              }
            ],
            "description": "Worker deployment options that user has set in the worker."
          }
        }
      },
      "RespondActivityTaskCanceledResponse": {
        "type": "object",
        "properties": {}
      },
      "RespondActivityTaskCompletedByIdRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity"
          },
          "workflowId": {
            "type": "string",
            "description": "Id of the workflow which scheduled this activity"
          },
          "runId": {
            "type": "string",
            "description": "Run Id of the workflow which scheduled this activity"
          },
          "activityId": {
            "type": "string",
            "description": "Id of the activity to complete"
          },
          "result": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "The serialized result of activity execution"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          }
        }
      },
      "RespondActivityTaskCompletedByIdResponse": {
        "type": "object",
        "properties": {}
      },
      "RespondActivityTaskCompletedRequest": {
        "type": "object",
        "properties": {
          "taskToken": {
            "type": "string",
            "description": "The task token as received in `PollActivityTaskQueueResponse`",
            "format": "bytes"
          },
          "result": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "The result of successfully executing the activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "namespace": {
            "type": "string"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this task. This message's `build_id` field should\n always be set by SDKs. Workers opting into versioning will also set the `use_versioning`\n field to true. See message docstrings for more.\n Deprecated. Use `deployment` instead."
          },
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "Deployment info of the worker that completed this task. Must be present if user has set\n `WorkerDeploymentOptions` regardless of versioning being enabled or not.\n Deprecated. Replaced with `deployment_options`."
          },
          "deploymentOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerDeploymentOptions"
              }
            ],
            "description": "Worker deployment options that user has set in the worker."
          }
        }
      },
      "RespondActivityTaskCompletedResponse": {
        "type": "object",
        "properties": {}
      },
      "RespondActivityTaskFailedByIdRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity"
          },
          "workflowId": {
            "type": "string",
            "description": "Id of the workflow which scheduled this activity"
          },
          "runId": {
            "type": "string",
            "description": "Run Id of the workflow which scheduled this activity"
          },
          "activityId": {
            "type": "string",
            "description": "Id of the activity to fail"
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Detailed failure information"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "lastHeartbeatDetails": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Additional details to be stored as last activity heartbeat"
          }
        }
      },
      "RespondActivityTaskFailedByIdResponse": {
        "type": "object",
        "properties": {
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Failure"
            },
            "description": "Server validation failures could include\n last_heartbeat_details payload is too large, request failure is too large"
          }
        }
      },
      "RespondActivityTaskFailedRequest": {
        "type": "object",
        "properties": {
          "taskToken": {
            "type": "string",
            "description": "The task token as received in `PollActivityTaskQueueResponse`",
            "format": "bytes"
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Detailed failure information"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "namespace": {
            "type": "string"
          },
          "lastHeartbeatDetails": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Additional details to be stored as last activity heartbeat"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this task. This message's `build_id` field should\n always be set by SDKs. Workers opting into versioning will also set the `use_versioning`\n field to true. See message docstrings for more.\n Deprecated. Use `deployment` instead."
          },
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "Deployment info of the worker that completed this task. Must be present if user has set\n `WorkerDeploymentOptions` regardless of versioning being enabled or not.\n Deprecated. Replaced with `deployment_options`."
          },
          "deploymentOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerDeploymentOptions"
              }
            ],
            "description": "Worker deployment options that user has set in the worker."
          }
        }
      },
      "RespondActivityTaskFailedResponse": {
        "type": "object",
        "properties": {
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Failure"
            },
            "description": "Server validation failures could include\n last_heartbeat_details payload is too large, request failure is too large"
          }
        }
      },
      "RetryPolicy": {
        "type": "object",
        "properties": {
          "initialInterval": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries."
          },
          "backoffCoefficient": {
            "type": "number",
            "description": "Coefficient used to calculate the next retry interval.\n The next retry interval is previous interval multiplied by the coefficient.\n Must be 1 or larger.",
            "format": "double"
          },
          "maximumInterval": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Maximum interval between retries. Exponential backoff leads to interval increase.\n This value is the cap of the increase. Default is 100x of the initial interval."
          },
          "maximumAttempts": {
            "type": "integer",
            "description": "Maximum number of attempts. When exceeded the retries stop even if not expired yet.\n 1 disables retries. 0 means unlimited (up to the timeouts)",
            "format": "int32"
          },
          "nonRetryableErrorTypes": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that\n this is not a substring match, the error *type* (not message) must match exactly."
          }
        },
        "description": "How retries ought to be handled, usable by both workflows and activities"
      },
      "RoutingConfig": {
        "type": "object",
        "properties": {
          "currentVersion": {
            "type": "string",
            "description": "Always present. Specifies which Deployment Version should should receive new workflow\n executions and tasks of existing unversioned or AutoUpgrade workflows.\n Can be one of the following:\n - A Deployment Version identifier in the form \"<deployment_name>.<build_id>\".\n - Or, the \"__unversioned__\" special value, to represent all the unversioned workers (those\n   with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\n Note: Current Version is overridden by the Ramping Version for a portion of traffic when a ramp\n is set (see `ramping_version`.)"
          },
          "rampingVersion": {
            "type": "string",
            "description": "When present, it means the traffic is being shifted from the Current Version to the Ramping\n Version.\n Must always be different from Current Version. Can be one of the following:\n - A Deployment Version identifier in the form \"<deployment_name>.<build_id>\".\n - Or, the \"__unversioned__\" special value, to represent all the unversioned workers (those\n   with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\n Note that it is possible to ramp from one Version to another Version, or from unversioned\n workers to a particular Version, or from a particular Version to unversioned workers."
          },
          "rampingVersionPercentage": {
            "type": "number",
            "description": "Percentage of tasks that are routed to the Ramping Version instead of the Current Version.\n Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but\n not yet \"promoted\" to be the Current Version, likely due to pending validations.",
            "format": "float"
          },
          "currentVersionChangedTime": {
            "type": "string",
            "description": "Last time current version was changed.",
            "format": "date-time"
          },
          "rampingVersionChangedTime": {
            "type": "string",
            "description": "Last time ramping version was changed. Not updated if only the ramp percentage changes.",
            "format": "date-time"
          },
          "rampingVersionPercentageChangedTime": {
            "type": "string",
            "description": "Last time ramping version percentage was changed.\n If ramping version is changed, this is also updated, even if the percentage stays the same.",
            "format": "date-time"
          }
        }
      },
      "Schedule": {
        "type": "object",
        "properties": {
          "spec": {
            "$ref": "#/components/schemas/ScheduleSpec"
          },
          "action": {
            "$ref": "#/components/schemas/ScheduleAction"
          },
          "policies": {
            "$ref": "#/components/schemas/SchedulePolicies"
          },
          "state": {
            "$ref": "#/components/schemas/ScheduleState"
          }
        }
      },
      "ScheduleAction": {
        "type": "object",
        "properties": {
          "startWorkflow": {
            "allOf": [
              {
                "$ref": "#/components/schemas/NewWorkflowExecutionInfo"
              }
            ],
            "description": "All fields of NewWorkflowExecutionInfo are valid except for:\n - workflow_id_reuse_policy\n - cron_schedule\n The workflow id of the started workflow may not match this exactly,\n it may have a timestamp appended for uniqueness."
          }
        }
      },
      "ScheduleActionResult": {
        "type": "object",
        "properties": {
          "scheduleTime": {
            "type": "string",
            "description": "Time that the action was taken (according to the schedule, including jitter).",
            "format": "date-time"
          },
          "actualTime": {
            "type": "string",
            "description": "Time that the action was taken (real time).",
            "format": "date-time"
          },
          "startWorkflowResult": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "If action was start_workflow:"
          },
          "startWorkflowStatus": {
            "enum": [
              "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
              "WORKFLOW_EXECUTION_STATUS_RUNNING",
              "WORKFLOW_EXECUTION_STATUS_COMPLETED",
              "WORKFLOW_EXECUTION_STATUS_FAILED",
              "WORKFLOW_EXECUTION_STATUS_CANCELED",
              "WORKFLOW_EXECUTION_STATUS_TERMINATED",
              "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
              "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
            ],
            "type": "string",
            "description": "If the action was start_workflow, this field will reflect an\n eventually-consistent view of the started workflow's status.",
            "format": "enum"
          }
        }
      },
      "ScheduleInfo": {
        "type": "object",
        "properties": {
          "actionCount": {
            "type": "string",
            "description": "Number of actions taken so far."
          },
          "missedCatchupWindow": {
            "type": "string",
            "description": "Number of times a scheduled action was skipped due to missing the catchup window."
          },
          "overlapSkipped": {
            "type": "string",
            "description": "Number of skipped actions due to overlap."
          },
          "bufferDropped": {
            "type": "string",
            "description": "Number of dropped actions due to buffer limit."
          },
          "bufferSize": {
            "type": "string",
            "description": "Number of actions in the buffer. The buffer holds the actions that cannot\n be immediately triggered (due to the overlap policy). These actions can be a result of\n the normal schedule or a backfill."
          },
          "runningWorkflows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowExecution"
            },
            "description": "Currently-running workflows started by this schedule. (There might be\n more than one if the overlap policy allows overlaps.)\n Note that the run_ids in here are the original execution run ids as\n started by the schedule. If the workflows retried, did continue-as-new,\n or were reset, they might still be running but with a different run_id."
          },
          "recentActions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduleActionResult"
            },
            "description": "Most recent ten actual action times (including manual triggers)."
          },
          "futureActionTimes": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "date-time"
            },
            "description": "Next ten scheduled action times."
          },
          "createTime": {
            "type": "string",
            "description": "Timestamps of schedule creation and last update.",
            "format": "date-time"
          },
          "updateTime": {
            "type": "string",
            "format": "date-time"
          },
          "invalidScheduleError": {
            "type": "string"
          }
        }
      },
      "ScheduleListEntry": {
        "type": "object",
        "properties": {
          "scheduleId": {
            "type": "string"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "info": {
            "$ref": "#/components/schemas/ScheduleListInfo"
          }
        },
        "description": "ScheduleListEntry is returned by ListSchedules."
      },
      "ScheduleListInfo": {
        "type": "object",
        "properties": {
          "spec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ScheduleSpec"
              }
            ],
            "description": "From spec:\n Some fields are dropped from this copy of spec: timezone_data"
          },
          "workflowType": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowType"
              }
            ],
            "description": "From action:\n Action is a oneof field, but we need to encode this in JSON and oneof fields don't work\n well with JSON. If action is start_workflow, this is set:"
          },
          "notes": {
            "type": "string",
            "description": "From state:"
          },
          "paused": {
            "type": "boolean"
          },
          "recentActions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ScheduleActionResult"
            },
            "description": "From info (maybe fewer entries):"
          },
          "futureActionTimes": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "date-time"
            }
          }
        },
        "description": "ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo\n that's returned in ListSchedules."
      },
      "SchedulePatch": {
        "type": "object",
        "properties": {
          "triggerImmediately": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TriggerImmediatelyRequest"
              }
            ],
            "description": "If set, trigger one action immediately."
          },
          "backfillRequest": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BackfillRequest"
            },
            "description": "If set, runs though the specified time period(s) and takes actions as if that time\n passed by right now, all at once. The overlap policy can be overridden for the\n scope of the backfill."
          },
          "pause": {
            "type": "string",
            "description": "If set, change the state to paused or unpaused (respectively) and set the\n notes field to the value of the string."
          },
          "unpause": {
            "type": "string"
          }
        }
      },
      "SchedulePolicies": {
        "type": "object",
        "properties": {
          "overlapPolicy": {
            "enum": [
              "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
              "SCHEDULE_OVERLAP_POLICY_SKIP",
              "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
              "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
              "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
              "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
              "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL"
            ],
            "type": "string",
            "description": "Policy for overlaps.\n Note that this can be changed after a schedule has taken some actions,\n and some changes might produce unintuitive results. In general, the later\n policy overrides the earlier policy.",
            "format": "enum"
          },
          "catchupWindow": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Policy for catchups:\n If the Temporal server misses an action due to one or more components\n being down, and comes back up, the action will be run if the scheduled\n time is within this window from the current time.\n This value defaults to one year, and can't be less than 10 seconds."
          },
          "pauseOnFailure": {
            "type": "boolean",
            "description": "If true, and a workflow run fails or times out, turn on \"paused\".\n This applies after retry policies: the full chain of retries must fail to\n trigger a pause here."
          },
          "keepOriginalWorkflowId": {
            "type": "boolean",
            "description": "If true, and the action would start a workflow, a timestamp will not be\n appended to the scheduled workflow id."
          }
        }
      },
      "ScheduleSpec": {
        "type": "object",
        "properties": {
          "structuredCalendar": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StructuredCalendarSpec"
            },
            "description": "Calendar-based specifications of times."
          },
          "cronString": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "cron_string holds a traditional cron specification as a string. It\n accepts 5, 6, or 7 fields, separated by spaces, and interprets them the\n same way as CalendarSpec.\n 5 fields:         minute, hour, day_of_month, month, day_of_week\n 6 fields:         minute, hour, day_of_month, month, day_of_week, year\n 7 fields: second, minute, hour, day_of_month, month, day_of_week, year\n If year is not given, it defaults to *. If second is not given, it\n defaults to 0.\n Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also\n accepted instead of the 5-7 time fields.\n Optionally, the string can be preceded by CRON_TZ=<timezone name> or\n TZ=<timezone name>, which will get copied to timezone_name. (There must\n not also be a timezone_name present.)\n Optionally \"#\" followed by a comment can appear at the end of the string.\n Note that the special case that some cron implementations have for\n treating day_of_month and day_of_week as \"or\" instead of \"and\" when both\n are set is not implemented.\n @every <interval>[/<phase>] is accepted and gets compiled into an\n IntervalSpec instead. <interval> and <phase> should be a decimal integer\n with a unit suffix s, m, h, or d."
          },
          "calendar": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CalendarSpec"
            },
            "description": "Calendar-based specifications of times."
          },
          "interval": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntervalSpec"
            },
            "description": "Interval-based specifications of times."
          },
          "excludeCalendar": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CalendarSpec"
            },
            "description": "Any timestamps matching any of exclude_* will be skipped."
          },
          "excludeStructuredCalendar": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/StructuredCalendarSpec"
            }
          },
          "startTime": {
            "type": "string",
            "description": "If start_time is set, any timestamps before start_time will be skipped.\n (Together, start_time and end_time make an inclusive interval.)",
            "format": "date-time"
          },
          "endTime": {
            "type": "string",
            "description": "If end_time is set, any timestamps after end_time will be skipped.",
            "format": "date-time"
          },
          "jitter": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "All timestamps will be incremented by a random value from 0 to this\n amount of jitter. Default: 0"
          },
          "timezoneName": {
            "type": "string",
            "description": "Time zone to interpret all calendar-based specs in.\n\n If unset, defaults to UTC. We recommend using UTC for your application if\n at all possible, to avoid various surprising properties of time zones.\n\n Time zones may be provided by name, corresponding to names in the IANA\n time zone database (see https://www.iana.org/time-zones). The definition\n will be loaded by the Temporal server from the environment it runs in.\n\n If your application requires more control over the time zone definition\n used, it may pass in a complete definition in the form of a TZif file\n from the time zone database. If present, this will be used instead of\n loading anything from the environment. You are then responsible for\n updating timezone_data when the definition changes.\n\n Calendar spec matching is based on literal matching of the clock time\n with no special handling of DST: if you write a calendar spec that fires\n at 2:30am and specify a time zone that follows DST, that action will not\n be triggered on the day that has no 2:30am. Similarly, an action that\n fires at 1:30am will be triggered twice on the day that has two 1:30s.\n\n Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC)."
          },
          "timezoneData": {
            "type": "string",
            "format": "bytes"
          }
        },
        "description": "ScheduleSpec is a complete description of a set of absolute timestamps\n (possibly infinite) that an action should occur at. The meaning of a\n ScheduleSpec depends only on its contents and never changes, except that the\n definition of a time zone can change over time (most commonly, when daylight\n saving time policy changes for an area). To create a totally self-contained\n ScheduleSpec, use UTC or include timezone_data.\n\n For input, you can provide zero or more of: structured_calendar, calendar,\n cron_string, interval, and exclude_structured_calendar, and all of them will\n be used (the schedule will take action at the union of all of their times,\n minus the ones that match exclude_structured_calendar).\n\n On input, calendar and cron_string fields will be compiled into\n structured_calendar (and maybe interval and timezone_name), so if you\n Describe a schedule, you'll see only structured_calendar, interval, etc.\n\n If a spec has no matching times after the current time, then the schedule\n will be subject to automatic deletion (after several days)."
      },
      "ScheduleState": {
        "type": "object",
        "properties": {
          "notes": {
            "type": "string",
            "description": "Informative human-readable message with contextual notes, e.g. the reason\n a schedule is paused. The system may overwrite this message on certain\n conditions, e.g. when pause-on-failure happens."
          },
          "paused": {
            "type": "boolean",
            "description": "If true, do not take any actions based on the schedule spec."
          },
          "limitedActions": {
            "type": "boolean",
            "description": "If limited_actions is true, decrement remaining_actions after each\n action, and do not take any more scheduled actions if remaining_actions\n is zero. Actions may still be taken by explicit request (i.e. trigger\n immediately or backfill). Skipped actions (due to overlap policy) do not\n count against remaining actions.\n If a schedule has no more remaining actions, then the schedule will be\n subject to automatic deletion (after several days)."
          },
          "remainingActions": {
            "type": "string"
          }
        }
      },
      "SearchAttributes": {
        "type": "object",
        "properties": {
          "indexedFields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            }
          }
        },
        "description": "A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.\n The payload is not serialized in a user-defined way."
      },
      "ServerFailureInfo": {
        "type": "object",
        "properties": {
          "nonRetryable": {
            "type": "boolean"
          }
        }
      },
      "SetCurrentDeploymentRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "deployment": {
            "$ref": "#/components/schemas/Deployment"
          },
          "identity": {
            "type": "string",
            "description": "Optional. The identity of the client who initiated this request."
          },
          "updateMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UpdateDeploymentMetadata"
              }
            ],
            "description": "Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed\n when describing a deployment. It is a good place for information such as operator name,\n links to internal deployment pipelines, etc."
          }
        },
        "description": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
      },
      "SetCurrentDeploymentResponse": {
        "type": "object",
        "properties": {
          "currentDeploymentInfo": {
            "$ref": "#/components/schemas/DeploymentInfo"
          },
          "previousDeploymentInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeploymentInfo"
              }
            ],
            "description": "Info of the deployment that was current before executing this operation."
          }
        },
        "description": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
      },
      "SetWorkerDeploymentCurrentVersionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "deploymentName": {
            "type": "string"
          },
          "version": {
            "type": "string",
            "description": "Required. Can be one of the following:\n - A Deployment Version identifier in the form \"<deployment_name>.<build_id>\".\n - Or, the \"__unversioned__\" special value, to represent all the unversioned workers (those\n   with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)"
          },
          "conflictToken": {
            "type": "string",
            "description": "Optional. This can be the value of conflict_token from a Describe, or another Worker\n Deployment API. Passing a non-nil conflict token will cause this request to fail if the\n Deployment's configuration has been modified between the API call that generated the\n token and this one.",
            "format": "bytes"
          },
          "identity": {
            "type": "string",
            "description": "Optional. The identity of the client who initiated this request."
          },
          "ignoreMissingTaskQueues": {
            "type": "boolean",
            "description": "Optional. By default this request would be rejected if not all the expected Task Queues are\n being polled by the new Version, to protect against accidental removal of Task Queues, or\n worker health issues. Pass `true` here to bypass this protection.\n The set of expected Task Queues is the set of all the Task Queues that were ever poller by\n the existing Current Version of the Deployment, with the following exclusions:\n   - Task Queues that are not used anymore (inferred by having empty backlog and a task\n     add_rate of 0.)\n   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue\n     having a different Current Version than the Current Version of this deployment.)\n WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not\n needed. If the request is unexpectedly rejected due to missing pollers, then that means the\n pollers have not reached to the server yet. Only set this if you expect those pollers to\n never arrive."
          }
        },
        "description": "Set/unset the Current Version of a Worker Deployment."
      },
      "SetWorkerDeploymentCurrentVersionResponse": {
        "type": "object",
        "properties": {
          "conflictToken": {
            "type": "string",
            "description": "This value is returned so that it can be optionally passed to APIs\n that write to the Worker Deployment state to ensure that the state\n did not change between this API call and a future write.",
            "format": "bytes"
          },
          "previousVersion": {
            "type": "string",
            "description": "The version that was current before executing this operation, in the form\n \"<deployment_name>.<build_id>\". Can also be the `__unversioned__` special value."
          }
        }
      },
      "SetWorkerDeploymentRampingVersionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "deploymentName": {
            "type": "string"
          },
          "version": {
            "type": "string",
            "description": "Can be one of the following:\n - Absent/empty value to unset the Ramping Version. Must be paired with `percentage=0`.\n - A Deployment Version identifier in the form \"<deployment_name>.<build_id>\".\n - Or, the \"__unversioned__\" special value, to represent all the unversioned workers (those\n   with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)"
          },
          "percentage": {
            "type": "number",
            "description": "Ramp percentage to set. Valid range: [0,100].",
            "format": "float"
          },
          "conflictToken": {
            "type": "string",
            "description": "Optional. This can be the value of conflict_token from a Describe, or another Worker\n Deployment API. Passing a non-nil conflict token will cause this request to fail if the\n Deployment's configuration has been modified between the API call that generated the\n token and this one.",
            "format": "bytes"
          },
          "identity": {
            "type": "string",
            "description": "Optional. The identity of the client who initiated this request."
          },
          "ignoreMissingTaskQueues": {
            "type": "boolean",
            "description": "Optional. By default this request would be rejected if not all the expected Task Queues are\n being polled by the new Version, to protect against accidental removal of Task Queues, or\n worker health issues. Pass `true` here to bypass this protection.\n The set of expected Task Queues equals to all the Task Queues ever polled from the existing\n Current Version of the Deployment, with the following exclusions:\n   - Task Queues that are not used anymore (inferred by having empty backlog and a task\n     add_rate of 0.)\n   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue\n     having a different Current Version than the Current Version of this deployment.)\n WARNING: Do not set this flag unless you are sure that the missing task queue poller are not\n needed. If the request is unexpectedly rejected due to missing pollers, then that means the\n pollers have not reached to the server yet. Only set this if you expect those pollers to\n never arrive.\n Note: this check only happens when the ramping version is about to change, not every time\n that the percentage changes. Also note that the check is against the deployment's Current\n Version, not the previous Ramping Version."
          }
        },
        "description": "Set/unset the Ramping Version of a Worker Deployment and its ramp percentage."
      },
      "SetWorkerDeploymentRampingVersionResponse": {
        "type": "object",
        "properties": {
          "conflictToken": {
            "type": "string",
            "description": "This value is returned so that it can be optionally passed to APIs\n that write to the Worker Deployment state to ensure that the state\n did not change between this API call and a future write.",
            "format": "bytes"
          },
          "previousVersion": {
            "type": "string",
            "description": "The version that was ramping before executing this operation, in the form\n \"<deployment_name>.<build_id>\". Can also be the `__unversioned__` special value."
          },
          "previousPercentage": {
            "type": "number",
            "description": "The ramping version percentage before executing this operation.",
            "format": "float"
          }
        }
      },
      "SignalExternalWorkflowExecutionFailedEventAttributes": {
        "type": "object",
        "properties": {
          "cause": {
            "enum": [
              "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
              "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
              "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND",
              "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED"
            ],
            "type": "string",
            "format": "enum"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which failed the signal.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "initiatedEventId": {
            "type": "string"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          }
        }
      },
      "SignalExternalWorkflowExecutionInitiatedEventAttributes": {
        "type": "object",
        "properties": {
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "namespace": {
            "type": "string",
            "description": "Namespace of the to-be-signalled workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "signalName": {
            "type": "string",
            "description": "name/type of the signal to fire in the external workflow"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized arguments to provide to the signal handler"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          },
          "childWorkflowOnly": {
            "type": "boolean",
            "description": "Workers are expected to set this to true if the workflow they are requesting to cancel is\n a child of the workflow which issued the request"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          }
        }
      },
      "SignalWithStartWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowId": {
            "type": "string"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "taskQueue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskQueue"
              }
            ],
            "description": "The task queue to start this workflow on, if it will be started"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
          },
          "workflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Total workflow execution timeout including retries and continue as new"
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow run"
          },
          "workflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow task"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "requestId": {
            "type": "string",
            "description": "Used to de-dupe signal w/ start requests"
          },
          "workflowIdReusePolicy": {
            "enum": [
              "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
              "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
            ],
            "type": "string",
            "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\n The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\n See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.",
            "format": "enum"
          },
          "workflowIdConflictPolicy": {
            "enum": [
              "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
              "WORKFLOW_ID_CONFLICT_POLICY_FAIL",
              "WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING",
              "WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING"
            ],
            "type": "string",
            "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\n The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.\n Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.\n\n See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.",
            "format": "enum"
          },
          "signalName": {
            "type": "string",
            "description": "The workflow author-defined name of the signal to send to the workflow"
          },
          "signalInput": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized value(s) to provide with the signal"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          },
          "retryPolicy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RetryPolicy"
              }
            ],
            "description": "Retry policy for the workflow"
          },
          "cronSchedule": {
            "type": "string",
            "description": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "workflowStartDelay": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\n Note that the signal will be delivered with the first workflow task. If the workflow gets\n another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately\n and the rest of the delay period will be ignored, even if that request also had a delay.\n Signal via SignalWorkflowExecution will not unblock the workflow."
          },
          "userMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserMetadata"
              }
            ],
            "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\n for use by user interfaces to display the fixed as-of-start summary and details of the\n workflow."
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events."
          },
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\n To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        }
      },
      "SignalWithStartWorkflowExecutionResponse": {
        "type": "object",
        "properties": {
          "runId": {
            "type": "string",
            "description": "The run id of the workflow that was started - or just signaled, if it was already running."
          },
          "started": {
            "type": "boolean",
            "description": "If true, a new workflow was started."
          }
        }
      },
      "SignalWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "signalName": {
            "type": "string",
            "description": "The workflow author-defined name of the signal to send to the workflow"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized value(s) to provide with the signal"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "requestId": {
            "type": "string",
            "description": "Used to de-dupe sent signals"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          },
          "header": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Header"
              }
            ],
            "description": "Headers that are passed with the signal to the processing workflow.\n These can include things like auth or tracing tokens."
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Links to be associated with the WorkflowExecutionSignaled event."
          }
        }
      },
      "SignalWorkflowExecutionResponse": {
        "type": "object",
        "properties": {}
      },
      "StartBatchOperationRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace that contains the batch operation"
          },
          "visibilityQuery": {
            "type": "string",
            "description": "Visibility query defines the the group of workflow to apply the batch operation\n This field and `executions` are mutually exclusive"
          },
          "jobId": {
            "type": "string",
            "description": "Job ID defines the unique ID for the batch job"
          },
          "reason": {
            "type": "string",
            "description": "Reason to perform the batch operation"
          },
          "executions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowExecution"
            },
            "description": "Executions to apply the batch operation\n This field and `visibility_query` are mutually exclusive"
          },
          "maxOperationsPerSecond": {
            "type": "number",
            "description": "Limit for the number of operations processed per second within this batch.\n Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system\n overload and minimize potential delays in executing ongoing tasks for user workers.\n Note that when no explicit limit is provided, the server will operate according to its limit defined by the\n dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the\n server's configured limit.",
            "format": "float"
          },
          "terminationOperation": {
            "$ref": "#/components/schemas/BatchOperationTermination"
          },
          "signalOperation": {
            "$ref": "#/components/schemas/BatchOperationSignal"
          },
          "cancellationOperation": {
            "$ref": "#/components/schemas/BatchOperationCancellation"
          },
          "deletionOperation": {
            "$ref": "#/components/schemas/BatchOperationDeletion"
          },
          "resetOperation": {
            "$ref": "#/components/schemas/BatchOperationReset"
          },
          "updateWorkflowOptionsOperation": {
            "$ref": "#/components/schemas/BatchOperationUpdateWorkflowExecutionOptions"
          },
          "unpauseActivitiesOperation": {
            "$ref": "#/components/schemas/BatchOperationUnpauseActivities"
          }
        }
      },
      "StartBatchOperationResponse": {
        "type": "object",
        "properties": {}
      },
      "StartChildWorkflowExecutionFailedEventAttributes": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowId": {
            "type": "string"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "cause": {
            "enum": [
              "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
              "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS",
              "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
            ],
            "type": "string",
            "format": "enum"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          },
          "initiatedEventId": {
            "type": "string",
            "description": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          }
        }
      },
      "StartChildWorkflowExecutionInitiatedEventAttributes": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the child workflow.\n SDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
          },
          "namespaceId": {
            "type": "string"
          },
          "workflowId": {
            "type": "string"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "input": {
            "$ref": "#/components/schemas/Payloads"
          },
          "workflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Total workflow execution timeout including retries and continue as new."
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow run."
          },
          "workflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow task."
          },
          "parentClosePolicy": {
            "enum": [
              "PARENT_CLOSE_POLICY_UNSPECIFIED",
              "PARENT_CLOSE_POLICY_TERMINATE",
              "PARENT_CLOSE_POLICY_ABANDON",
              "PARENT_CLOSE_POLICY_REQUEST_CANCEL"
            ],
            "type": "string",
            "description": "Default: PARENT_CLOSE_POLICY_TERMINATE.",
            "format": "enum"
          },
          "control": {
            "type": "string",
            "description": "Deprecated"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "workflowIdReusePolicy": {
            "enum": [
              "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
              "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
            ],
            "type": "string",
            "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.",
            "format": "enum"
          },
          "retryPolicy": {
            "$ref": "#/components/schemas/RetryPolicy"
          },
          "cronSchedule": {
            "type": "string",
            "description": "If this child runs on a cron schedule, it will appear here"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "inheritBuildId": {
            "type": "boolean",
            "description": "If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment\n rules of the child's Task Queue will be used to independently assign a Build ID to it."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        }
      },
      "StartWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowId": {
            "type": "string"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
          },
          "workflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Total workflow execution timeout including retries and continue as new."
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow run."
          },
          "workflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow task."
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request"
          },
          "requestId": {
            "type": "string",
            "description": "A unique identifier for this start request. Typically UUIDv4."
          },
          "workflowIdReusePolicy": {
            "enum": [
              "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
              "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
              "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
            ],
            "type": "string",
            "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\n The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\n See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.",
            "format": "enum"
          },
          "workflowIdConflictPolicy": {
            "enum": [
              "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
              "WORKFLOW_ID_CONFLICT_POLICY_FAIL",
              "WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING",
              "WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING"
            ],
            "type": "string",
            "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\n The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.\n\n See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.",
            "format": "enum"
          },
          "retryPolicy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RetryPolicy"
              }
            ],
            "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
          },
          "cronSchedule": {
            "type": "string",
            "description": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "requestEagerExecution": {
            "type": "boolean",
            "description": "Request to get the first workflow task inline in the response bypassing matching service and worker polling.\n If set to `true` the caller is expected to have a worker available and capable of processing the task.\n The returned task will be marked as started and is expected to be completed by the specified\n `workflow_task_timeout`."
          },
          "continuedFailure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "These values will be available as ContinuedFailure and LastCompletionResult in the\n WorkflowExecutionStarted event and through SDKs. The are currently only used by the\n server itself (for the schedules feature) and are not intended to be exposed in\n StartWorkflowExecution."
          },
          "lastCompletionResult": {
            "$ref": "#/components/schemas/Payloads"
          },
          "workflowStartDelay": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\n If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest\n of the delay will be ignored."
          },
          "completionCallbacks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Callback"
            },
            "description": "Callbacks to be called by the server when this workflow reaches a terminal state.\n If the workflow continues-as-new, these callbacks will be carried over to the new execution.\n Callback addresses must be whitelisted in the server's dynamic configuration."
          },
          "userMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserMetadata"
              }
            ],
            "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\n for use by user interfaces to display the fixed as-of-start summary and details of the\n workflow."
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Links to be associated with the workflow."
          },
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\n To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
          },
          "onConflictOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/OnConflictOptions"
              }
            ],
            "description": "Defines actions to be done to the existing running workflow when the conflict policy\n WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a\n empty object (ie., all options with default value), it won't do anything to the existing\n running workflow. If set, it will add a history event to the running workflow."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        }
      },
      "StartWorkflowExecutionResponse": {
        "type": "object",
        "properties": {
          "runId": {
            "type": "string",
            "description": "The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING)."
          },
          "started": {
            "type": "boolean",
            "description": "If true, a new workflow was started."
          },
          "eagerWorkflowTask": {
            "allOf": [
              {
                "$ref": "#/components/schemas/PollWorkflowTaskQueueResponse"
              }
            ],
            "description": "When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will\n return the first workflow task to be eagerly executed.\n The caller is expected to have a worker available to process the task."
          }
        }
      },
      "Status": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].",
            "format": "int32"
          },
          "message": {
            "type": "string",
            "description": "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client."
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/GoogleProtobufAny"
            },
            "description": "A list of messages that carry the error details.  There is a common set of message types for APIs to use."
          }
        },
        "description": "The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors)."
      },
      "StopBatchOperationRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace that contains the batch operation"
          },
          "jobId": {
            "type": "string",
            "description": "Batch job id"
          },
          "reason": {
            "type": "string",
            "description": "Reason to stop a batch operation"
          },
          "identity": {
            "type": "string",
            "description": "Identity of the operator"
          }
        }
      },
      "StopBatchOperationResponse": {
        "type": "object",
        "properties": {}
      },
      "StructuredCalendarSpec": {
        "type": "object",
        "properties": {
          "second": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match seconds (0-59)"
          },
          "minute": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match minutes (0-59)"
          },
          "hour": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match hours (0-23)"
          },
          "dayOfMonth": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match days of the month (1-31)\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: standard name of field --)"
          },
          "month": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match months (1-12)"
          },
          "year": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match years."
          },
          "dayOfWeek": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Range"
            },
            "description": "Match days of the week (0-6; 0 is Sunday)."
          },
          "comment": {
            "type": "string",
            "description": "Free-form comment describing the intention of this spec."
          }
        },
        "description": "StructuredCalendarSpec describes an event specification relative to the\n calendar, in a form that's easy to work with programmatically. Each field can\n be one or more ranges.\n A timestamp matches if at least one range of each field matches the\n corresponding fields of the timestamp, except for year: if year is missing,\n that means all years match. For all fields besides year, at least one Range\n must be present to match anything.\n TODO: add relative-to-end-of-month\n TODO: add nth day-of-week in month"
      },
      "TaskIdBlock": {
        "type": "object",
        "properties": {
          "startId": {
            "type": "string"
          },
          "endId": {
            "type": "string"
          }
        }
      },
      "TaskQueue": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "kind": {
            "enum": [
              "TASK_QUEUE_KIND_UNSPECIFIED",
              "TASK_QUEUE_KIND_NORMAL",
              "TASK_QUEUE_KIND_STICKY"
            ],
            "type": "string",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.",
            "format": "enum"
          },
          "normalName": {
            "type": "string",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\n the normal task queue that the sticky worker is running on."
          }
        },
        "description": "See https://docs.temporal.io/docs/concepts/task-queues/"
      },
      "TaskQueueReachability": {
        "type": "object",
        "properties": {
          "taskQueue": {
            "type": "string"
          },
          "reachability": {
            "type": "array",
            "items": {
              "enum": [
                "TASK_REACHABILITY_UNSPECIFIED",
                "TASK_REACHABILITY_NEW_WORKFLOWS",
                "TASK_REACHABILITY_EXISTING_WORKFLOWS",
                "TASK_REACHABILITY_OPEN_WORKFLOWS",
                "TASK_REACHABILITY_CLOSED_WORKFLOWS"
              ],
              "type": "string",
              "format": "enum"
            },
            "description": "Task reachability for a worker in a single task queue.\n See the TaskReachability docstring for information about each enum variant.\n If reachability is empty, this worker is considered unreachable in this task queue."
          }
        },
        "description": "Reachability of tasks for a worker on a single task queue."
      },
      "TaskQueueStats": {
        "type": "object",
        "properties": {
          "approximateBacklogCount": {
            "type": "string",
            "description": "The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually\n converges to the right value. Can be relied upon for scaling decisions.\n\n Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because\n those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size\n grows."
          },
          "approximateBacklogAge": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Approximate age of the oldest task in the backlog based on the creation time of the task at the head of\n the queue. Can be relied upon for scaling decisions.\n\n Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because\n those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than\n few seconds."
          },
          "tasksAddRate": {
            "type": "number",
            "description": "The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks\n whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going\n to the backlog (sync-matched).\n\n The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which\n backlog grows/shrinks.\n\n Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by\n tasks_add_rate, because:\n - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is\n   enable for activities by default in the latest SDKs.\n - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each\n   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific\n   worker instance.",
            "format": "float"
          },
          "tasksDispatchRate": {
            "type": "number",
            "description": "The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes\n tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without\n going to the backlog (sync-matched).\n\n The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which\n backlog grows/shrinks.\n\n Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by\n tasks_dispatch_rate, because:\n - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is\n   enable for activities by default in the latest SDKs.\n - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each\n   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific\n   worker instance.",
            "format": "float"
          }
        },
        "description": "TaskQueueStats contains statistics about task queue backlog and activity.\n\n For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read\n comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy."
      },
      "TaskQueueStatus": {
        "type": "object",
        "properties": {
          "backlogCountHint": {
            "type": "string"
          },
          "readLevel": {
            "type": "string"
          },
          "ackLevel": {
            "type": "string"
          },
          "ratePerSecond": {
            "type": "number",
            "format": "double"
          },
          "taskIdBlock": {
            "$ref": "#/components/schemas/TaskIdBlock"
          }
        },
        "description": "Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior."
      },
      "TaskQueueTypeInfo": {
        "type": "object",
        "properties": {
          "pollers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PollerInfo"
            },
            "description": "Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID."
          },
          "stats": {
            "$ref": "#/components/schemas/TaskQueueStats"
          }
        }
      },
      "TaskQueueVersionInfo": {
        "type": "object",
        "properties": {
          "typesInfo": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TaskQueueTypeInfo"
            },
            "description": "Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum."
          },
          "taskReachability": {
            "enum": [
              "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED",
              "BUILD_ID_TASK_REACHABILITY_REACHABLE",
              "BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
              "BUILD_ID_TASK_REACHABILITY_UNREACHABLE"
            ],
            "type": "string",
            "description": "Task Reachability is eventually consistent; there may be a delay until it converges to the most\n accurate value but it is designed in a way to take the more conservative side until it converges.\n For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.\n\n Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be\n accounted for reachability as server cannot know if they'll happen as they do not use\n assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows\n who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make\n sure to query reachability for the parent/previous workflow's Task Queue as well.",
            "format": "enum"
          }
        }
      },
      "TaskQueueVersioningInfo": {
        "type": "object",
        "properties": {
          "currentVersion": {
            "type": "string",
            "description": "Always present. Specifies which Deployment Version should receive new workflow\n executions and tasks of existing unversioned or AutoUpgrade workflows.\n Can be one of the following:\n - A Deployment Version identifier in the form \"<deployment_name>.<build_id>\".\n - Or, the \"__unversioned__\" special value, to represent all the unversioned workers (those\n   with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\n Note: Current Version is overridden by the Ramping Version for a portion of traffic when a ramp\n is set (see `ramping_version`.)"
          },
          "rampingVersion": {
            "type": "string",
            "description": "When present, it means the traffic is being shifted from the Current Version to the Ramping\n Version.\n Must always be different from `current_version`. Can be one of the following:\n - A Deployment Version identifier in the form \"<deployment_name>.<build_id>\".\n - Or, the \"__unversioned__\" special value, to represent all the unversioned workers (those\n   with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\n Note that it is possible to ramp from one Version to another Version, or from unversioned\n workers to a particular Version, or from a particular Version to unversioned workers."
          },
          "rampingVersionPercentage": {
            "type": "number",
            "description": "Percentage of tasks that are routed to the Ramping Version instead of the Current Version.\n Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but\n not yet \"promoted\" to be the Current Version, likely due to pending validations.",
            "format": "float"
          },
          "updateTime": {
            "type": "string",
            "description": "Last time versioning information of this Task Queue changed.",
            "format": "date-time"
          }
        },
        "description": "Experimental. Worker Deployments are experimental and might significantly change in the future."
      },
      "TerminateWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "reason": {
            "type": "string"
          },
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized additional information to attach to the termination event"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the worker/client"
          },
          "firstExecutionRunId": {
            "type": "string",
            "description": "If set, this call will error if the most recent (if no run id is set on\n `workflow_execution`), or specified (if it is) workflow execution is not part of the same\n execution chain as this id."
          },
          "links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Link"
            },
            "description": "Links to be associated with the WorkflowExecutionTerminated event."
          }
        }
      },
      "TerminateWorkflowExecutionResponse": {
        "type": "object",
        "properties": {}
      },
      "TerminatedFailureInfo": {
        "type": "object",
        "properties": {}
      },
      "TimeoutFailureInfo": {
        "type": "object",
        "properties": {
          "timeoutType": {
            "enum": [
              "TIMEOUT_TYPE_UNSPECIFIED",
              "TIMEOUT_TYPE_START_TO_CLOSE",
              "TIMEOUT_TYPE_SCHEDULE_TO_START",
              "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
              "TIMEOUT_TYPE_HEARTBEAT"
            ],
            "type": "string",
            "format": "enum"
          },
          "lastHeartbeatDetails": {
            "$ref": "#/components/schemas/Payloads"
          }
        }
      },
      "TimerCanceledEventAttributes": {
        "type": "object",
        "properties": {
          "timerId": {
            "type": "string",
            "description": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `TIMER_STARTED` event itself"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "identity": {
            "type": "string",
            "description": "The id of the worker who requested this cancel"
          }
        }
      },
      "TimerFiredEventAttributes": {
        "type": "object",
        "properties": {
          "timerId": {
            "type": "string",
            "description": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `TIMER_STARTED` event itself"
          }
        }
      },
      "TimerStartedEventAttributes": {
        "type": "object",
        "properties": {
          "timerId": {
            "type": "string",
            "description": "The worker/user assigned id for this timer"
          },
          "startToFireTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "How long until this timer fires\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          }
        }
      },
      "TimestampedBuildIdAssignmentRule": {
        "type": "object",
        "properties": {
          "rule": {
            "$ref": "#/components/schemas/BuildIdAssignmentRule"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "TimestampedCompatibleBuildIdRedirectRule": {
        "type": "object",
        "properties": {
          "rule": {
            "$ref": "#/components/schemas/CompatibleBuildIdRedirectRule"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "TriggerImmediatelyRequest": {
        "type": "object",
        "properties": {
          "overlapPolicy": {
            "enum": [
              "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
              "SCHEDULE_OVERLAP_POLICY_SKIP",
              "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
              "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
              "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
              "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
              "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL"
            ],
            "type": "string",
            "description": "If set, override overlap policy for this one request.",
            "format": "enum"
          }
        }
      },
      "TriggerWorkflowRuleRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "execution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Execution info of the workflow which scheduled this activity"
          },
          "id": {
            "type": "string"
          },
          "spec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowRuleSpec"
              }
            ],
            "description": "Note: Rule ID and expiration date are not used in the trigger request."
          }
        }
      },
      "TriggerWorkflowRuleResponse": {
        "type": "object",
        "properties": {
          "applied": {
            "type": "boolean",
            "description": "True is the rule was applied, based on the rule conditions (predicate/visibility_query)."
          }
        }
      },
      "UnpauseActivityRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity."
          },
          "execution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Execution info of the workflow which scheduled this activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request."
          },
          "id": {
            "type": "string",
            "description": "Only the activity with this ID will be unpaused."
          },
          "type": {
            "type": "string",
            "description": "Unpause all running activities with of this type."
          },
          "unpauseAll": {
            "type": "boolean",
            "description": "Unpause all running activities."
          },
          "resetAttempts": {
            "type": "boolean",
            "description": "Providing this flag will also reset the number of attempts."
          },
          "resetHeartbeat": {
            "type": "boolean",
            "description": "Providing this flag will also reset the heartbeat details."
          },
          "jitter": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "If set, the activity will start at a random time within the specified jitter duration."
          }
        }
      },
      "UnpauseActivityResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateActivityOptionsRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "Namespace of the workflow which scheduled this activity"
          },
          "execution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Execution info of the workflow which scheduled this activity"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request"
          },
          "activityOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivityOptions"
              }
            ],
            "description": "Activity options. Partial updates are accepted and controlled by update_mask"
          },
          "updateMask": {
            "type": "string",
            "description": "Controls which fields from `activity_options` will be applied",
            "format": "field-mask"
          },
          "id": {
            "type": "string",
            "description": "Only activity with this ID will be updated."
          },
          "type": {
            "type": "string",
            "description": "Update all running activities of this type."
          }
        }
      },
      "UpdateActivityOptionsResponse": {
        "type": "object",
        "properties": {
          "activityOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ActivityOptions"
              }
            ],
            "description": "Activity options after an update"
          }
        }
      },
      "UpdateDeploymentMetadata": {
        "type": "object",
        "properties": {
          "upsertEntries": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            }
          },
          "removeEntries": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of keys to remove from the metadata."
          }
        },
        "description": "Used as part of Deployment write APIs to update metadata attached to a deployment.\n Deprecated."
      },
      "UpdateNamespaceInfo": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "ownerEmail": {
            "type": "string"
          },
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A key-value map for any customized purpose.\n If data already exists on the namespace, \n this will merge with the existing key values."
          },
          "state": {
            "enum": [
              "NAMESPACE_STATE_UNSPECIFIED",
              "NAMESPACE_STATE_REGISTERED",
              "NAMESPACE_STATE_DEPRECATED",
              "NAMESPACE_STATE_DELETED"
            ],
            "type": "string",
            "description": "New namespace state, server will reject if transition is not allowed.\n Allowed transitions are:\n  Registered -> [ Deleted | Deprecated | Handover ]\n  Handover -> [ Registered ]\n Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.",
            "format": "enum"
          }
        }
      },
      "UpdateNamespaceRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "updateInfo": {
            "$ref": "#/components/schemas/UpdateNamespaceInfo"
          },
          "config": {
            "$ref": "#/components/schemas/NamespaceConfig"
          },
          "replicationConfig": {
            "$ref": "#/components/schemas/NamespaceReplicationConfig"
          },
          "securityToken": {
            "type": "string"
          },
          "deleteBadBinary": {
            "type": "string"
          },
          "promoteNamespace": {
            "type": "boolean",
            "description": "promote local namespace to global namespace. Ignored if namespace is already global namespace."
          }
        }
      },
      "UpdateNamespaceResponse": {
        "type": "object",
        "properties": {
          "namespaceInfo": {
            "$ref": "#/components/schemas/NamespaceInfo"
          },
          "config": {
            "$ref": "#/components/schemas/NamespaceConfig"
          },
          "replicationConfig": {
            "$ref": "#/components/schemas/NamespaceReplicationConfig"
          },
          "failoverVersion": {
            "type": "string"
          },
          "isGlobalNamespace": {
            "type": "boolean"
          }
        }
      },
      "UpdateNexusEndpointRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Server-generated unique endpoint ID."
          },
          "version": {
            "type": "string",
            "description": "Data version for this endpoint. Must match current version."
          },
          "spec": {
            "$ref": "#/components/schemas/EndpointSpec"
          }
        }
      },
      "UpdateNexusEndpointResponse": {
        "type": "object",
        "properties": {
          "endpoint": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Endpoint"
              }
            ],
            "description": "Data post acceptance. Can be used to issue additional updates to this record."
          }
        }
      },
      "UpdateRef": {
        "type": "object",
        "properties": {
          "workflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "updateId": {
            "type": "string"
          }
        },
        "description": "The data needed by a client to refer to a previously invoked Workflow Update."
      },
      "UpdateScheduleRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace of the schedule to update."
          },
          "scheduleId": {
            "type": "string",
            "description": "The id of the schedule to update."
          },
          "schedule": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Schedule"
              }
            ],
            "description": "The new schedule. The four main fields of the schedule (spec, action,\n policies, state) are replaced completely by the values in this message."
          },
          "conflictToken": {
            "type": "string",
            "description": "This can be the value of conflict_token from a DescribeScheduleResponse,\n which will cause this request to fail if the schedule has been modified\n between the Describe and this Update.\n If missing, the schedule will be updated unconditionally.",
            "format": "bytes"
          },
          "identity": {
            "type": "string",
            "description": "The identity of the client who initiated this request."
          },
          "requestId": {
            "type": "string",
            "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
          },
          "searchAttributes": {
            "allOf": [
              {
                "$ref": "#/components/schemas/SearchAttributes"
              }
            ],
            "description": "Schedule search attributes to be updated.\n Do not set this field if you do not want to update the search attributes.\n A non-null empty object will set the search attributes to an empty map.\n Note: you cannot only update the search attributes with `UpdateScheduleRequest`,\n you must also set the `schedule` field; otherwise, it will unset the schedule."
          }
        }
      },
      "UpdateScheduleResponse": {
        "type": "object",
        "properties": {}
      },
      "UpdateWorkerDeploymentVersionMetadataRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string"
          },
          "version": {
            "type": "string",
            "description": "Deployment Version identifier in the form \"<deployment_name>.<build_id>\"."
          },
          "upsertEntries": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            }
          },
          "removeEntries": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of keys to remove from the metadata."
          }
        },
        "description": "Used to update the user-defined metadata of a Worker Deployment Version."
      },
      "UpdateWorkerDeploymentVersionMetadataResponse": {
        "type": "object",
        "properties": {
          "metadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersionMetadata"
              }
            ],
            "description": "Full metadata after performing the update."
          }
        }
      },
      "UpdateWorkflowExecutionOptionsRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace name of the target Workflow."
          },
          "workflowExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "The target Workflow Id and (optionally) a specific Run Id thereof.\n (-- api-linter: core::0203::optional=disabled\n     aip.dev/not-precedent: false positive triggered by the word \"optional\" --)"
          },
          "workflowExecutionOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecutionOptions"
              }
            ],
            "description": "Workflow Execution options. Partial updates are accepted and controlled by update_mask."
          },
          "updateMask": {
            "type": "string",
            "description": "Controls which fields from `workflow_execution_options` will be applied.\n To unset a field, set it to null and use the update mask to indicate that it should be mutated.",
            "format": "field-mask"
          }
        }
      },
      "UpdateWorkflowExecutionOptionsResponse": {
        "type": "object",
        "properties": {
          "workflowExecutionOptions": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecutionOptions"
              }
            ],
            "description": "Workflow Execution options after update."
          }
        }
      },
      "UpdateWorkflowExecutionRequest": {
        "type": "object",
        "properties": {
          "namespace": {
            "type": "string",
            "description": "The namespace name of the target Workflow."
          },
          "workflowExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "The target Workflow Id and (optionally) a specific Run Id thereof.\n (-- api-linter: core::0203::optional=disabled\n     aip.dev/not-precedent: false positive triggered by the word \"optional\" --)"
          },
          "firstExecutionRunId": {
            "type": "string",
            "description": "If set, this call will error if the most recent (if no Run Id is set on\n `workflow_execution`), or specified (if it is) Workflow Execution is not\n part of the same execution chain as this Id."
          },
          "waitPolicy": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WaitPolicy"
              }
            ],
            "description": "Specifies client's intent to wait for Update results.\n NOTE: This field works together with API call timeout which is limited by\n server timeout (maximum wait time). If server timeout is expired before\n user specified timeout, API call returns even if specified stage is not reached.\n Actual reached stage will be included in the response."
          },
          "request": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Request"
              }
            ],
            "description": "The request information that will be delivered all the way down to the\n Workflow Execution."
          }
        },
        "description": "(-- api-linter: core::0134=disabled\n     aip.dev/not-precedent: Update RPCs don't follow Google API format. --)"
      },
      "UpdateWorkflowExecutionResponse": {
        "type": "object",
        "properties": {
          "updateRef": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UpdateRef"
              }
            ],
            "description": "Enough information for subsequent poll calls if needed. Never null."
          },
          "outcome": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Outcome"
              }
            ],
            "description": "The outcome of the Update if and only if the Workflow Update\n has completed. If this response is being returned before the Update has\n completed then this field will not be set."
          },
          "stage": {
            "enum": [
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED",
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED",
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED"
            ],
            "type": "string",
            "description": "The most advanced lifecycle stage that the Update is known to have\n reached, where lifecycle stages are ordered\n UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <\n UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <\n UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <\n UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.\n UNSPECIFIED will be returned if and only if the server's maximum wait\n time was reached before the Update reached the stage specified in the\n request WaitPolicy, and before the context deadline expired; clients may\n may then retry the call as needed.",
            "format": "enum"
          }
        }
      },
      "UpsertWorkflowSearchAttributesEventAttributes": {
        "type": "object",
        "properties": {
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          }
        }
      },
      "UserMetadata": {
        "type": "object",
        "properties": {
          "summary": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payload"
              }
            ],
            "description": "Short-form text that provides a summary. This payload should be a \"json/plain\"-encoded payload\n that is a single JSON string for use in user interfaces. User interface formatting may not\n apply to this text when used in \"title\" situations. The payload data section is limited to 400\n bytes by default."
          },
          "details": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payload"
              }
            ],
            "description": "Long-form text that provides details. This payload should be a \"json/plain\"-encoded payload\n that is a single JSON string for use in user interfaces. User interface formatting may apply to\n this text in common use. The payload data section is limited to 20000 bytes by default."
          }
        },
        "description": "Information a user can set, often for use by user interfaces."
      },
      "VersionDrainageInfo": {
        "type": "object",
        "properties": {
          "status": {
            "enum": [
              "VERSION_DRAINAGE_STATUS_UNSPECIFIED",
              "VERSION_DRAINAGE_STATUS_DRAINING",
              "VERSION_DRAINAGE_STATUS_DRAINED"
            ],
            "type": "string",
            "description": "Set to DRAINING when the version first stops accepting new executions (is no longer current or ramping).\n Set to DRAINED when no more open pinned workflows exist on this version.",
            "format": "enum"
          },
          "lastChangedTime": {
            "type": "string",
            "description": "Last time the drainage status changed.",
            "format": "date-time"
          },
          "lastCheckedTime": {
            "type": "string",
            "description": "Last time the system checked for drainage of this version.",
            "format": "date-time"
          }
        },
        "description": "Information about workflow drainage to help the user determine when it is safe\n to decommission a Version. Not present while version is current or ramping.\n Experimental. Worker Deployments are experimental and might significantly change in the future."
      },
      "VersionInfo": {
        "type": "object",
        "properties": {
          "current": {
            "$ref": "#/components/schemas/ReleaseInfo"
          },
          "recommended": {
            "$ref": "#/components/schemas/ReleaseInfo"
          },
          "instructions": {
            "type": "string"
          },
          "alerts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Alert"
            }
          },
          "lastUpdateTime": {
            "type": "string",
            "format": "date-time"
          }
        },
        "description": "VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions."
      },
      "VersionMetadata": {
        "type": "object",
        "properties": {
          "entries": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/Payload"
            },
            "description": "Arbitrary key-values."
          }
        }
      },
      "VersioningOverride": {
        "type": "object",
        "properties": {
          "behavior": {
            "enum": [
              "VERSIONING_BEHAVIOR_UNSPECIFIED",
              "VERSIONING_BEHAVIOR_PINNED",
              "VERSIONING_BEHAVIOR_AUTO_UPGRADE"
            ],
            "type": "string",
            "description": "Required.",
            "format": "enum"
          },
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.\n Identifies the worker deployment to pin the workflow to.\n Deprecated. Use `pinned_version`."
          },
          "pinnedVersion": {
            "type": "string",
            "description": "Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.\n Identifies the worker deployment version to pin the workflow to, in the format\n \"<deployment_name>.<build_id>\"."
          }
        },
        "description": "Used to override the versioning behavior (and pinned deployment version, if applicable) of a\n specific workflow execution. If set, takes precedence over the worker-sent values. See\n `WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call\n `UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`\n to indicate that it should be mutated."
      },
      "WaitPolicy": {
        "type": "object",
        "properties": {
          "lifecycleStage": {
            "enum": [
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED",
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED",
              "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED"
            ],
            "type": "string",
            "description": "Indicates the Update lifecycle stage that the Update must reach before\n API call is returned.\n NOTE: This field works together with API call timeout which is limited by\n server timeout (maximum wait time). If server timeout is expired before\n user specified timeout, API call returns even if specified stage is not reached.",
            "format": "enum"
          }
        },
        "description": "Specifies client's intent to wait for Update results."
      },
      "WorkerDeploymentInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Identifies a Worker Deployment. Must be unique within the namespace."
          },
          "versionSummaries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkerDeploymentInfo_WorkerDeploymentVersionSummary"
            },
            "description": "Deployment Versions that are currently tracked in this Deployment. A DeploymentVersion will be\n cleaned up automatically if all the following conditions meet:\n - It does not receive new executions (is not current or ramping)\n - It has no active pollers (see WorkerDeploymentVersionInfo.pollers_status) \n - It is drained (see WorkerDeploymentVersionInfo.drainage_status)"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "routingConfig": {
            "$ref": "#/components/schemas/RoutingConfig"
          },
          "lastModifierIdentity": {
            "type": "string",
            "description": "Identity of the last client who modified the configuration of this Deployment. Set to the\n `identity` value sent by APIs such as `SetWorkerDeploymentCurrentVersion` and\n `SetWorkerDeploymentRampingVersion`."
          }
        },
        "description": "A Worker Deployment (Deployment, for short) represents all workers serving \n a shared set of Task Queues. Typically, a Deployment represents one service or \n application.\n A Deployment contains multiple Deployment Versions, each representing a different \n version of workers. (see documentation of WorkerDeploymentVersionInfo)\n Deployment records are created in Temporal server automatically when their\n first poller arrives to the server.\n Experimental. Worker Deployments are experimental and might significantly change in the future."
      },
      "WorkerDeploymentInfo_WorkerDeploymentVersionSummary": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "description": "The fully-qualified string representation of the version, in the form \"<deployment_name>.<build_id>\"."
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "drainageStatus": {
            "enum": [
              "VERSION_DRAINAGE_STATUS_UNSPECIFIED",
              "VERSION_DRAINAGE_STATUS_DRAINING",
              "VERSION_DRAINAGE_STATUS_DRAINED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "WorkerDeploymentOptions": {
        "type": "object",
        "properties": {
          "deploymentName": {
            "type": "string",
            "description": "Required. Worker Deployment name."
          },
          "buildId": {
            "type": "string",
            "description": "The Build ID of the worker. Required when `worker_versioning_mode==VERSIONED`, in which case,\n the worker will be part of a Deployment Version identified by \"<deployment_name>.<build_id>\"."
          },
          "workerVersioningMode": {
            "enum": [
              "WORKER_VERSIONING_MODE_UNSPECIFIED",
              "WORKER_VERSIONING_MODE_UNVERSIONED",
              "WORKER_VERSIONING_MODE_VERSIONED"
            ],
            "type": "string",
            "description": "Required. Versioning Mode for this worker. Must be the same for all workers with the\n same `deployment_name` and `build_id` combination, across all Task Queues.\n When `worker_versioning_mode==VERSIONED`, the worker will be part of a Deployment Version\n identified by \"<deployment_name>.<build_id>\".",
            "format": "enum"
          }
        },
        "description": "Worker Deployment options set in SDK that need to be sent to server in every poll.\n Experimental. Worker Deployments are experimental and might significantly change in the future."
      },
      "WorkerDeploymentVersionInfo": {
        "type": "object",
        "properties": {
          "version": {
            "type": "string",
            "description": "The fully-qualified string representation of the version, in the form \"<deployment_name>.<build_id>\"."
          },
          "deploymentName": {
            "type": "string"
          },
          "createTime": {
            "type": "string",
            "format": "date-time"
          },
          "routingChangedTime": {
            "type": "string",
            "description": "Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.",
            "format": "date-time"
          },
          "currentSinceTime": {
            "type": "string",
            "description": "(-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)\n Nil if not current.",
            "format": "date-time"
          },
          "rampingSinceTime": {
            "type": "string",
            "description": "(-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)\n Nil if not ramping. Updated when the version first starts ramping, not on each ramp change.",
            "format": "date-time"
          },
          "rampPercentage": {
            "type": "number",
            "description": "Range: [0, 100]. Must be zero if the version is not ramping (i.e. `ramping_since_time` is nil).\n Can be in the range [0, 100] if the version is ramping.",
            "format": "float"
          },
          "taskQueueInfos": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkerDeploymentVersionInfo_VersionTaskQueueInfo"
            },
            "description": "All the Task Queues that have ever polled from this Deployment version."
          },
          "drainageInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersionDrainageInfo"
              }
            ],
            "description": "Helps user determine when it is safe to decommission the workers of this\n Version. Not present when version is current or ramping.\n Current limitations:\n - Not supported for Unversioned mode.\n - Periodically refreshed, may have delays up to few minutes (consult the\n   last_checked_time value).\n - Refreshed only when version is not current or ramping AND the status is not\n   \"drained\" yet.\n - Once the status is changed to \"drained\", it is not changed until the Version\n   becomes Current or Ramping again, at which time the drainage info is cleared.\n   This means if the Version is \"drained\" but new workflows are sent to it via\n   Pinned Versioning Override, the status does not account for those Pinned-override\n   executions and remains \"drained\"."
          },
          "metadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersionMetadata"
              }
            ],
            "description": "Arbitrary user-provided metadata attached to this version."
          }
        },
        "description": "A Worker Deployment Version (Version, for short) represents all workers of the same \n code and config within a Deployment. Workers of the same Version are expected to \n behave exactly the same so when executions move between them there are no \n non-determinism issues.\n Worker Deployment Versions are created in Temporal server automatically when \n their first poller arrives to the server.\n Experimental. Worker Deployments are experimental and might significantly change in the future."
      },
      "WorkerDeploymentVersionInfo_VersionTaskQueueInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY",
              "TASK_QUEUE_TYPE_NEXUS"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "WorkerVersionCapabilities": {
        "type": "object",
        "properties": {
          "buildId": {
            "type": "string",
            "description": "An opaque whole-worker identifier"
          },
          "useVersioning": {
            "type": "boolean",
            "description": "If set, the worker is opting in to worker versioning, and wishes to only receive appropriate\n tasks."
          },
          "deploymentSeriesName": {
            "type": "string",
            "description": "Must be sent if user has set a deployment series name (versioning-3)."
          }
        },
        "description": "Identifies the version that a worker is compatible with when polling or identifying itself,\n and whether or not this worker is opting into the build-id based versioning feature. This is\n used by matching to determine which workers ought to receive what tasks.\n Deprecated. Use WorkerDeploymentOptions instead."
      },
      "WorkerVersionStamp": {
        "type": "object",
        "properties": {
          "buildId": {
            "type": "string",
            "description": "An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this\n message is included in requests which previously used that."
          },
          "useVersioning": {
            "type": "boolean",
            "description": "If set, the worker is opting in to worker versioning. Otherwise, this is used only as a\n marker for workflow reset points and the BuildIDs search attribute."
          }
        },
        "description": "Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.\n Identifies the version(s) of a worker that processed a task"
      },
      "WorkflowEvent_EventReference": {
        "type": "object",
        "properties": {
          "eventId": {
            "type": "string"
          },
          "eventType": {
            "enum": [
              "EVENT_TYPE_UNSPECIFIED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT",
              "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED",
              "EVENT_TYPE_WORKFLOW_TASK_STARTED",
              "EVENT_TYPE_WORKFLOW_TASK_COMPLETED",
              "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT",
              "EVENT_TYPE_WORKFLOW_TASK_FAILED",
              "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED",
              "EVENT_TYPE_ACTIVITY_TASK_STARTED",
              "EVENT_TYPE_ACTIVITY_TASK_COMPLETED",
              "EVENT_TYPE_ACTIVITY_TASK_FAILED",
              "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT",
              "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED",
              "EVENT_TYPE_ACTIVITY_TASK_CANCELED",
              "EVENT_TYPE_TIMER_STARTED",
              "EVENT_TYPE_TIMER_FIRED",
              "EVENT_TYPE_TIMER_CANCELED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED",
              "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
              "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
              "EVENT_TYPE_MARKER_RECORDED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW",
              "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED",
              "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT",
              "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED",
              "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
              "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
              "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED",
              "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED",
              "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY",
              "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY",
              "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED",
              "EVENT_TYPE_NEXUS_OPERATION_SCHEDULED",
              "EVENT_TYPE_NEXUS_OPERATION_STARTED",
              "EVENT_TYPE_NEXUS_OPERATION_COMPLETED",
              "EVENT_TYPE_NEXUS_OPERATION_FAILED",
              "EVENT_TYPE_NEXUS_OPERATION_CANCELED",
              "EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT",
              "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED",
              "EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED",
              "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED",
              "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "WorkflowExecution": {
        "type": "object",
        "properties": {
          "workflowId": {
            "type": "string"
          },
          "runId": {
            "type": "string"
          }
        },
        "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\n uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\n run id as a way of saying \"target the latest run of the workflow\"."
      },
      "WorkflowExecutionCancelRequestedEventAttributes": {
        "type": "object",
        "properties": {
          "cause": {
            "type": "string",
            "description": "User provided reason for requesting cancellation\n TODO: shall we create a new field with name \"reason\" and deprecate this one?"
          },
          "externalInitiatedEventId": {
            "type": "string",
            "description": "TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?"
          },
          "externalWorkflowExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "identity": {
            "type": "string",
            "description": "id of the worker or client who requested this cancel"
          }
        }
      },
      "WorkflowExecutionCanceledEventAttributes": {
        "type": "object",
        "properties": {
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "details": {
            "$ref": "#/components/schemas/Payloads"
          }
        }
      },
      "WorkflowExecutionCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "result": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized result of workflow completion (ie: The return value of the workflow function)"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "newExecutionRunId": {
            "type": "string",
            "description": "If another run is started by cron, this contains the new run id."
          }
        }
      },
      "WorkflowExecutionConfig": {
        "type": "object",
        "properties": {
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "workflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          },
          "defaultWorkflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string"
          },
          "userMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/UserMetadata"
              }
            ],
            "description": "User metadata provided on start workflow."
          }
        }
      },
      "WorkflowExecutionContinuedAsNewEventAttributes": {
        "type": "object",
        "properties": {
          "newExecutionRunId": {
            "type": "string",
            "description": "The run ID of the new workflow started by this continue-as-new"
          },
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "input": {
            "$ref": "#/components/schemas/Payloads"
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow run."
          },
          "workflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow task."
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "backoffStartInterval": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "TODO: How and is this used?"
          },
          "initiator": {
            "enum": [
              "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
              "CONTINUE_AS_NEW_INITIATOR_WORKFLOW",
              "CONTINUE_AS_NEW_INITIATOR_RETRY",
              "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE"
            ],
            "type": "string",
            "format": "enum"
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "TODO: David are these right?\n Deprecated. If a workflow's retry policy would cause a new run to start when the current one\n has failed, this field would be populated with that failure. Now (when supported by server\n and sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set."
          },
          "lastCompletionResult": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "TODO: Is this the result of *this* workflow as it continued-as-new?"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "inheritBuildId": {
            "type": "boolean",
            "description": "If this is set, the new execution inherits the Build ID of the current execution. Otherwise,\n the assignment rules will be used to independently assign a Build ID to the new execution."
          }
        }
      },
      "WorkflowExecutionExtendedInfo": {
        "type": "object",
        "properties": {
          "executionExpirationTime": {
            "type": "string",
            "description": "Workflow execution expiration time is defined as workflow start time plus expiration timeout.\n Workflow start time may change after workflow reset.",
            "format": "date-time"
          },
          "runExpirationTime": {
            "type": "string",
            "description": "Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.",
            "format": "date-time"
          },
          "cancelRequested": {
            "type": "boolean",
            "description": "indicates if the workflow received a cancel request"
          },
          "lastResetTime": {
            "type": "string",
            "description": "Last workflow reset time. Nil if the workflow was never reset.",
            "format": "date-time"
          },
          "originalStartTime": {
            "type": "string",
            "description": "Original workflow start time.",
            "format": "date-time"
          },
          "resetRunId": {
            "type": "string",
            "description": "Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run."
          }
        },
        "description": "Holds all the extra information about workflow execution that is not part of Visibility."
      },
      "WorkflowExecutionFailedEventAttributes": {
        "type": "object",
        "properties": {
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "Serialized result of workflow failure (ex: An exception thrown, or error returned)"
          },
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          },
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "newExecutionRunId": {
            "type": "string",
            "description": "If another run is started by cron or retry, this contains the new run id."
          }
        }
      },
      "WorkflowExecutionInfo": {
        "type": "object",
        "properties": {
          "execution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "type": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "startTime": {
            "type": "string",
            "format": "date-time"
          },
          "closeTime": {
            "type": "string",
            "format": "date-time"
          },
          "status": {
            "enum": [
              "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
              "WORKFLOW_EXECUTION_STATUS_RUNNING",
              "WORKFLOW_EXECUTION_STATUS_COMPLETED",
              "WORKFLOW_EXECUTION_STATUS_FAILED",
              "WORKFLOW_EXECUTION_STATUS_CANCELED",
              "WORKFLOW_EXECUTION_STATUS_TERMINATED",
              "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
              "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
            ],
            "type": "string",
            "format": "enum"
          },
          "historyLength": {
            "type": "string"
          },
          "parentNamespaceId": {
            "type": "string"
          },
          "parentExecution": {
            "$ref": "#/components/schemas/WorkflowExecution"
          },
          "executionTime": {
            "type": "string",
            "format": "date-time"
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "autoResetPoints": {
            "$ref": "#/components/schemas/ResetPoints"
          },
          "taskQueue": {
            "type": "string"
          },
          "stateTransitionCount": {
            "type": "string"
          },
          "historySizeBytes": {
            "type": "string"
          },
          "mostRecentWorkerVersionStamp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "If set, the most recent worker version stamp that appeared in a workflow task completion\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "executionDuration": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Workflow execution duration is defined as difference between close time and execution time.\n This field is only populated if the workflow is closed."
          },
          "rootExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Contains information about the root workflow execution.\n The root workflow execution is defined as follows:\n 1. A workflow without parent workflow is its own root workflow.\n 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.\n Note: workflows continued as new or reseted may or may not have parents, check examples below.\n\n Examples:\n   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.\n     - The root workflow of all three workflows is W1.\n   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.\n     - The root workflow of all three workflows is W1.\n   Scenario 3: Workflow W1 continued as new W2.\n     - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3\n     - The root workflow of all three workflows is W1.\n   Scenario 5: Workflow W1 is reseted, creating W2.\n     - The root workflow of W1 is W1 and the root workflow of W2 is W2."
          },
          "assignedBuildId": {
            "type": "string",
            "description": "The currently assigned build ID for this execution. Presence of this value means worker versioning is used\n for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules\n when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled\n again, the assigned build ID may change according to the latest versioning rules.\n Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to\n this execution.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "inheritedBuildId": {
            "type": "string",
            "description": "Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead\n of using the assignment rules.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "firstRunId": {
            "type": "string",
            "description": "The first run ID in the execution chain.\n Executions created via the following operations are considered to be in the same chain\n - ContinueAsNew\n - Workflow Retry\n - Workflow Reset\n - Cron Schedule"
          },
          "versioningInfo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecutionVersioningInfo"
              }
            ],
            "description": "Absent value means the workflow execution is not versioned. When present, the execution might\n be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.\n Experimental. Versioning info is experimental and might change in the future."
          },
          "workerDeploymentName": {
            "type": "string",
            "description": "The name of Worker Deployment that completed the most recent workflow task.\n Experimental. Worker Deployments are experimental and might change in the future."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        },
        "description": "Hold basic information about a workflow execution.\n This structure is a part of visibility, and thus contain a limited subset of information."
      },
      "WorkflowExecutionOptions": {
        "type": "object",
        "properties": {
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion."
          }
        }
      },
      "WorkflowExecutionOptionsUpdatedEventAttributes": {
        "type": "object",
        "properties": {
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "Versioning override upserted in this event.\n Ignored if nil or if unset_versioning_override is true."
          },
          "unsetVersioningOverride": {
            "type": "boolean",
            "description": "Versioning override removed in this event."
          },
          "attachedRequestId": {
            "type": "string",
            "description": "Request ID attachedto the running workflow execution so that subsequent requests with same\n request ID will be deduped."
          },
          "attachedCompletionCallbacks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Callback"
            },
            "description": "Completion callbacks attached to the running workflow execution."
          }
        }
      },
      "WorkflowExecutionSignaledEventAttributes": {
        "type": "object",
        "properties": {
          "signalName": {
            "type": "string",
            "description": "The name/type of the signal to fire"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Will be deserialized and provided as argument(s) to the signal handler"
          },
          "identity": {
            "type": "string",
            "description": "id of the worker/client who sent this signal"
          },
          "header": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Header"
              }
            ],
            "description": "Headers that were passed by the sender of the signal and copied by temporal \n server into the workflow task."
          },
          "skipGenerateWorkflowTask": {
            "type": "boolean",
            "description": "This field is deprecated and never respected. It should always be set to false."
          },
          "externalWorkflowExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "When signal origin is a workflow execution, this field is set."
          }
        }
      },
      "WorkflowExecutionStartedEventAttributes": {
        "type": "object",
        "properties": {
          "workflowType": {
            "$ref": "#/components/schemas/WorkflowType"
          },
          "parentWorkflowNamespace": {
            "type": "string",
            "description": "If this workflow is a child, the namespace our parent lives in.\n SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only."
          },
          "parentWorkflowNamespaceId": {
            "type": "string"
          },
          "parentWorkflowExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Contains information about parent workflow execution that initiated the child workflow these attributes belong to.\n If the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated."
          },
          "parentInitiatedEventId": {
            "type": "string",
            "description": "EventID of the child execution initiated event in parent workflow"
          },
          "taskQueue": {
            "$ref": "#/components/schemas/TaskQueue"
          },
          "input": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "SDK will deserialize this and provide it as arguments to the workflow function"
          },
          "workflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Total workflow execution timeout including retries and continue as new."
          },
          "workflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow run."
          },
          "workflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Timeout of a single workflow task."
          },
          "continuedExecutionRunId": {
            "type": "string",
            "description": "Run id of the previous workflow which continued-as-new or retired or cron executed into this\n workflow."
          },
          "initiator": {
            "enum": [
              "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
              "CONTINUE_AS_NEW_INITIATOR_WORKFLOW",
              "CONTINUE_AS_NEW_INITIATOR_RETRY",
              "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE"
            ],
            "type": "string",
            "format": "enum"
          },
          "continuedFailure": {
            "$ref": "#/components/schemas/Failure"
          },
          "lastCompletionResult": {
            "$ref": "#/components/schemas/Payloads"
          },
          "originalExecutionRunId": {
            "type": "string",
            "description": "This is the run id when the WorkflowExecutionStarted event was written.\n A workflow reset changes the execution run_id, but preserves this field."
          },
          "identity": {
            "type": "string",
            "description": "Identity of the client who requested this execution"
          },
          "firstExecutionRunId": {
            "type": "string",
            "description": "This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.\n Used to identify a chain."
          },
          "retryPolicy": {
            "$ref": "#/components/schemas/RetryPolicy"
          },
          "attempt": {
            "type": "integer",
            "description": "Starting at 1, the number of times we have tried to execute this workflow",
            "format": "int32"
          },
          "workflowExecutionExpirationTime": {
            "type": "string",
            "description": "The absolute time at which the workflow will be timed out.\n This is passed without change to the next run/retry of a workflow.",
            "format": "date-time"
          },
          "cronSchedule": {
            "type": "string",
            "description": "If this workflow runs on a cron schedule, it will appear here"
          },
          "firstWorkflowTaskBackoff": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "For a cron workflow, this contains the amount of time between when this iteration of\n the cron workflow was scheduled and when it should run next per its cron_schedule."
          },
          "memo": {
            "$ref": "#/components/schemas/Memo"
          },
          "searchAttributes": {
            "$ref": "#/components/schemas/SearchAttributes"
          },
          "prevAutoResetPoints": {
            "$ref": "#/components/schemas/ResetPoints"
          },
          "header": {
            "$ref": "#/components/schemas/Header"
          },
          "parentInitiatedEventVersion": {
            "type": "string",
            "description": "Version of the child execution initiated event in parent workflow\n It should be used together with parent_initiated_event_id to identify\n a child initiated event for global namespace"
          },
          "workflowId": {
            "type": "string",
            "description": "This field is new in 1.21."
          },
          "sourceVersionStamp": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "If this workflow intends to use anything other than the current overall default version for\n the queue, then we include it here.\n Deprecated. [cleanup-experimental-wv]"
          },
          "completionCallbacks": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Callback"
            },
            "description": "Completion callbacks attached when this workflow was started."
          },
          "rootWorkflowExecution": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowExecution"
              }
            ],
            "description": "Contains information about the root workflow execution.\n The root workflow execution is defined as follows:\n 1. A workflow without parent workflow is its own root workflow.\n 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.\n Note: workflows continued as new or reseted may or may not have parents, check examples below.\n\n Examples:\n   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.\n     - The root workflow of all three workflows is W1.\n   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.\n     - The root workflow of all three workflows is W1.\n   Scenario 3: Workflow W1 continued as new W2.\n     - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3\n     - The root workflow of all three workflows is W1.\n   Scenario 5: Workflow W1 is reseted, creating W2.\n     - The root workflow of W1 is W1 and the root workflow of W2 is W2."
          },
          "inheritedBuildId": {
            "type": "string",
            "description": "When present, this execution is assigned to the build ID of its parent or previous execution.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "Versioning override applied to this workflow when it was started."
          },
          "parentPinnedWorkerDeploymentVersion": {
            "type": "string",
            "description": "When present, it means this is a child workflow of a parent that is Pinned to this Worker\n Deployment Version. In this case, child workflow will start as Pinned to this Version instead\n of starting on the Current Version of its Task Queue.\n This is set only if the child workflow is starting on a Task Queue belonging to the same\n Worker Deployment Version."
          },
          "priority": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Priority"
              }
            ],
            "description": "Priority metadata"
          }
        },
        "description": "Always the first event in workflow history"
      },
      "WorkflowExecutionTerminatedEventAttributes": {
        "type": "object",
        "properties": {
          "reason": {
            "type": "string",
            "description": "User/client provided reason for termination"
          },
          "details": {
            "$ref": "#/components/schemas/Payloads"
          },
          "identity": {
            "type": "string",
            "description": "id of the client who requested termination"
          }
        }
      },
      "WorkflowExecutionTimedOutEventAttributes": {
        "type": "object",
        "properties": {
          "retryState": {
            "enum": [
              "RETRY_STATE_UNSPECIFIED",
              "RETRY_STATE_IN_PROGRESS",
              "RETRY_STATE_NON_RETRYABLE_FAILURE",
              "RETRY_STATE_TIMEOUT",
              "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
              "RETRY_STATE_RETRY_POLICY_NOT_SET",
              "RETRY_STATE_INTERNAL_SERVER_ERROR",
              "RETRY_STATE_CANCEL_REQUESTED"
            ],
            "type": "string",
            "format": "enum"
          },
          "newExecutionRunId": {
            "type": "string",
            "description": "If another run is started by cron or retry, this contains the new run id."
          }
        }
      },
      "WorkflowExecutionUpdateAcceptedEventAttributes": {
        "type": "object",
        "properties": {
          "protocolInstanceId": {
            "type": "string",
            "description": "The instance ID of the update protocol that generated this event."
          },
          "acceptedRequestMessageId": {
            "type": "string",
            "description": "The message ID of the original request message that initiated this\n update. Needed so that the worker can recreate and deliver that same\n message as part of replay."
          },
          "acceptedRequestSequencingEventId": {
            "type": "string",
            "description": "The event ID used to sequence the original request message."
          },
          "acceptedRequest": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Request"
              }
            ],
            "description": "The message payload of the original request message that initiated this\n update."
          }
        }
      },
      "WorkflowExecutionUpdateAdmittedEventAttributes": {
        "type": "object",
        "properties": {
          "request": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Request"
              }
            ],
            "description": "The update request associated with this event."
          },
          "origin": {
            "enum": [
              "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED",
              "UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY"
            ],
            "type": "string",
            "description": "An explanation of why this event was written to history.",
            "format": "enum"
          }
        }
      },
      "WorkflowExecutionUpdateCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "meta": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Meta"
              }
            ],
            "description": "The metadata about this update."
          },
          "acceptedEventId": {
            "type": "string",
            "description": "The event ID indicating the acceptance of this update."
          },
          "outcome": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Outcome"
              }
            ],
            "description": "The outcome of executing the workflow update function."
          }
        }
      },
      "WorkflowExecutionUpdateRejectedEventAttributes": {
        "type": "object",
        "properties": {
          "protocolInstanceId": {
            "type": "string",
            "description": "The instance ID of the update protocol that generated this event."
          },
          "rejectedRequestMessageId": {
            "type": "string",
            "description": "The message ID of the original request message that initiated this\n update. Needed so that the worker can recreate and deliver that same\n message as part of replay."
          },
          "rejectedRequestSequencingEventId": {
            "type": "string",
            "description": "The event ID used to sequence the original request message."
          },
          "rejectedRequest": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Request"
              }
            ],
            "description": "The message payload of the original request message that initiated this\n update."
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "The cause of rejection."
          }
        }
      },
      "WorkflowExecutionVersioningInfo": {
        "type": "object",
        "properties": {
          "behavior": {
            "enum": [
              "VERSIONING_BEHAVIOR_UNSPECIFIED",
              "VERSIONING_BEHAVIOR_PINNED",
              "VERSIONING_BEHAVIOR_AUTO_UPGRADE"
            ],
            "type": "string",
            "description": "Versioning behavior determines how the server should treat this execution when workers are\n upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means\n unversioned. See the comments in `VersioningBehavior` enum for more info about different\n behaviors.\n This field is first set after an execution completes its first workflow task on a versioned\n worker, and set again on completion of every subsequent workflow task.\n For child workflows of Pinned parents, this will be set to Pinned (along with `version`) when\n the the child starts so that child's first workflow task goes to the same Version as the\n parent. After the first workflow task, it depends on the child workflow itself if it wants\n to stay pinned or become unpinned (according to Versioning Behavior set in the worker).\n Note that `behavior` is overridden by `versioning_override` if the latter is present.",
            "format": "enum"
          },
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "The worker deployment that completed the last workflow task of this workflow execution. Must\n be present if `behavior` is set. Absent value means no workflow task is completed, or the\n last workflow task was completed by an unversioned worker. Unversioned workers may still send\n a deployment value which will be stored here, so the right way to check if an execution is\n versioned if an execution is versioned or not is via the `behavior` field.\n Note that `deployment` is overridden by `versioning_override` if the latter is present.\n Deprecated. Use `version`."
          },
          "version": {
            "type": "string",
            "description": "The Worker Deployment Version that completed the last workflow task of this workflow\n execution, in the form \"<deployment_name>.<build_id>\".\n Must be present if and only if `behavior` is set. An absent value means no workflow task is\n completed, or the workflow is unversioned.\n For child workflows of Pinned parents, this will be set to parent's Pinned Version when the\n the child starts so that child's first workflow task goes to the same Version as the parent.\n Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`\n will override this value."
          },
          "versioningOverride": {
            "allOf": [
              {
                "$ref": "#/components/schemas/VersioningOverride"
              }
            ],
            "description": "Present if user has set an execution-specific versioning override. This override takes\n precedence over SDK-sent `behavior` (and `version` when override is PINNED). An\n override can be set when starting a new execution, as well as afterwards by calling the\n `UpdateWorkflowExecutionOptions` API.\n Pinned overrides are automatically inherited by child workflows."
          },
          "deploymentTransition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeploymentTransition"
              }
            ],
            "description": "When present, indicates the workflow is transitioning to a different deployment. Can\n indicate one of the following transitions: unversioned -> versioned, versioned -> versioned\n on a different deployment, or versioned -> unversioned.\n Not applicable to workflows with PINNED behavior.\n When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically\n start a transition to the task queue's current deployment if the task queue's current\n deployment is different from the workflow's deployment.\n If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those\n tasks will be redirected to the task queue's current deployment. As soon as a poller from\n that deployment is available to receive the task, the workflow will automatically start a\n transition to that deployment and continue execution there.\n A deployment transition can only exist while there is a pending or started workflow task.\n Once the pending workflow task completes on the transition's target deployment, the\n transition completes and the workflow's `deployment` and `behavior` fields are updated per\n the worker's task completion response.\n Pending activities will not start new attempts during a transition. Once the transition is\n completed, pending activities will start their next attempt on the new deployment.\n Deprecated. Use version_transition."
          },
          "versionTransition": {
            "allOf": [
              {
                "$ref": "#/components/schemas/DeploymentVersionTransition"
              }
            ],
            "description": "When present, indicates the workflow is transitioning to a different deployment version\n (which may belong to the same deployment name or another). Can indicate one of the following\n transitions: unversioned -> versioned, versioned -> versioned\n on a different deployment version, or versioned -> unversioned.\n Not applicable to workflows with PINNED behavior.\n When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically\n start a transition to the task queue's current version if the task queue's current version is\n different from the workflow's current deployment version.\n If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those\n tasks will be redirected to the task queue's current version. As soon as a poller from\n that deployment version is available to receive the task, the workflow will automatically\n start a transition to that version and continue execution there.\n A version transition can only exist while there is a pending or started workflow task.\n Once the pending workflow task completes on the transition's target version, the\n transition completes and the workflow's `behavior`, and `version` fields are updated per the\n worker's task completion response.\n Pending activities will not start new attempts during a transition. Once the transition is\n completed, pending activities will start their next attempt on the new version."
          }
        },
        "description": "Holds all the information about worker versioning for a particular workflow execution.\n Experimental. Versioning info is experimental and might change in the future."
      },
      "WorkflowPropertiesModifiedEventAttributes": {
        "type": "object",
        "properties": {
          "workflowTaskCompletedEventId": {
            "type": "string",
            "description": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
          },
          "upsertedMemo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Memo"
              }
            ],
            "description": "If set, update the workflow memo with the provided values. The values will be merged with\n the existing memo. If the user wants to delete values, a default/empty Payload should be\n used as the value for the key being deleted."
          }
        }
      },
      "WorkflowPropertiesModifiedExternallyEventAttributes": {
        "type": "object",
        "properties": {
          "newTaskQueue": {
            "type": "string",
            "description": "Not used."
          },
          "newWorkflowTaskTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Not used."
          },
          "newWorkflowRunTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Not used."
          },
          "newWorkflowExecutionTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "Not used."
          },
          "upsertedMemo": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Memo"
              }
            ],
            "description": "Not used."
          }
        },
        "description": "Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes"
      },
      "WorkflowQuery": {
        "type": "object",
        "properties": {
          "queryType": {
            "type": "string",
            "description": "The workflow-author-defined identifier of the query. Typically a function name."
          },
          "queryArgs": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Payloads"
              }
            ],
            "description": "Serialized arguments that will be provided to the query handler."
          },
          "header": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Header"
              }
            ],
            "description": "Headers that were passed by the caller of the query and copied by temporal\n server into the workflow task."
          }
        },
        "description": "See https://docs.temporal.io/docs/concepts/queries/"
      },
      "WorkflowRule": {
        "type": "object",
        "properties": {
          "createTime": {
            "type": "string",
            "description": "Rule creation time.",
            "format": "date-time"
          },
          "spec": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowRuleSpec"
              }
            ],
            "description": "Rule specification"
          }
        },
        "description": "WorkflowRule describes a rule that can be applied to any workflow in this namespace."
      },
      "WorkflowRuleAction": {
        "type": "object",
        "properties": {
          "activityPause": {
            "$ref": "#/components/schemas/WorkflowRuleAction_ActionActivityPause"
          }
        }
      },
      "WorkflowRuleAction_ActionActivityPause": {
        "type": "object",
        "properties": {}
      },
      "WorkflowRuleSpec": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The id of the new workflow rule. Must be unique within the namespace.\n Can be set by the user, and can have business meaning."
          },
          "activityStart": {
            "$ref": "#/components/schemas/WorkflowRuleSpec_ActivityStartingTrigger"
          },
          "visibilityQuery": {
            "type": "string",
            "description": "Restricted Visibility query.\n This query is used to filter workflows in this namespace to which this rule should apply.\n It is applied to any running workflow each time a triggering event occurs, before the trigger predicate is evaluated.\n The following workflow attributes are supported:\n - WorkflowType\n - WorkflowId\n - StartTime\n - ExecutionStatus"
          },
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/WorkflowRuleAction"
            },
            "description": "WorkflowRuleAction to be taken when the rule is triggered and predicate is matched."
          },
          "expirationTime": {
            "type": "string",
            "description": "Expiration time of the rule. After this time, the rule will be deleted.\n Can be empty if the rule should never expire.",
            "format": "date-time"
          }
        }
      },
      "WorkflowRuleSpec_ActivityStartingTrigger": {
        "type": "object",
        "properties": {
          "predicate": {
            "type": "string",
            "description": "Activity predicate is a SQL-like string filter parameter.\n It is used to match against workflow data.\n The following activity attributes are supported as part of the predicate:\n - ActivityType: An Activity Type is the mapping of a name to an Activity Definition..\n - ActivityId: The ID of the activity.\n - ActivityAttempt: The number attempts of the activity.\n - BackoffInterval: The current amount of time between scheduled attempts of the activity.\n - ActivityStatus: The status of the activity. Can be one of \"Scheduled\", \"Started\", \"Paused\".\n - TaskQueue: The name of the task queue the workflow specified that the activity should run on.\n Activity predicate support the following operators:\n  * =, !=, >, >=, <, <=\n  * AND, OR, ()\n  * BETWEEN ... AND\n    STARTS_WITH"
          }
        },
        "description": "Activity trigger will be triggered when an activity is about to start."
      },
      "WorkflowTaskCompletedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
          },
          "identity": {
            "type": "string",
            "description": "Identity of the worker who completed this task"
          },
          "binaryChecksum": {
            "type": "string",
            "description": "Binary ID of the worker who completed this task"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this workflow task. If present, the `build_id` field\n within is also used as `binary_checksum`, which may be omitted in that case (it may also be\n populated to preserve compatibility).\n Deprecated. Use `deployment` and `versioning_behavior` instead."
          },
          "sdkMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkflowTaskCompletedMetadata"
              }
            ],
            "description": "Data the SDK wishes to record for itself, but server need not interpret, and does not\n directly impact workflow state."
          },
          "meteringMetadata": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MeteringMetadata"
              }
            ],
            "description": "Local usage data sent during workflow task completion and recorded here for posterity"
          },
          "deployment": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Deployment"
              }
            ],
            "description": "The deployment that completed this task. May or may not be set for unversioned workers,\n depending on whether a value is sent by the SDK. This value updates workflow execution's\n `versioning_info.deployment`.\n Deprecated. Replaced with `worker_deployment_version`."
          },
          "versioningBehavior": {
            "enum": [
              "VERSIONING_BEHAVIOR_UNSPECIFIED",
              "VERSIONING_BEHAVIOR_PINNED",
              "VERSIONING_BEHAVIOR_AUTO_UPGRADE"
            ],
            "type": "string",
            "description": "Versioning behavior sent by the worker that completed this task for this particular workflow\n execution. UNSPECIFIED means the task was completed by an unversioned worker. This value\n updates workflow execution's `versioning_info.behavior`.",
            "format": "enum"
          },
          "workerDeploymentVersion": {
            "type": "string",
            "description": "The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`\n is set. This value updates workflow execution's `versioning_info.version`.\n Experimental. Worker Deployments are experimental and might significantly change in the future."
          },
          "workerDeploymentName": {
            "type": "string",
            "description": "The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`\n is set. This value updates workflow execution's `worker_deployment_name`.\n Experimental. Worker Deployments are experimental and might significantly change in the future."
          }
        }
      },
      "WorkflowTaskCompletedMetadata": {
        "type": "object",
        "properties": {
          "coreUsedFlags": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint32"
            },
            "description": "Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:\n\n During replay:\n * If a flag is not recognized (value is too high or not defined), it must fail the workflow\n   task.\n * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for\n   that flag during and after this WFT are allowed to assume that the flag is present.\n * If a code check for a flag does not find the flag in the set of used flags, it must take\n   the branch corresponding to the absence of that flag.\n\n During non-replay execution of new WFTs:\n * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not\n   previously recorded) flags when completing the WFT.\n\n SDKs which are too old to even know about this field at all are considered to produce\n undefined behavior if they replay workflows which used this mechanism.\n\n (-- api-linter: core::0141::forbidden-types=disabled\n     aip.dev/not-precedent: These really shouldn't have negative values. --)"
          },
          "langUsedFlags": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint32"
            },
            "description": "Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages\n here as processing a workflow with a different language than the one which authored it is\n already undefined behavior. See `core_used_patches` for more.\n\n (-- api-linter: core::0141::forbidden-types=disabled\n     aip.dev/not-precedent: These really shouldn't have negative values. --)"
          },
          "sdkName": {
            "type": "string",
            "description": "Name of the SDK that processed the task. This is usually something like \"temporal-go\" and is\n usually the same as client-name gRPC header. This should only be set if its value changed\n since the last time recorded on the workflow (or be set on the first task).\n\n (-- api-linter: core::0122::name-suffix=disabled\n     aip.dev/not-precedent: We're ok with a name suffix here. --)"
          },
          "sdkVersion": {
            "type": "string",
            "description": "Version of the SDK that processed the task. This is usually something like \"1.20.0\" and is\n usually the same as client-version gRPC header. This should only be set if its value changed\n since the last time recorded on the workflow (or be set on the first task)."
          }
        }
      },
      "WorkflowTaskFailedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
          },
          "cause": {
            "enum": [
              "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
              "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID",
              "WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE",
              "WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND",
              "WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE",
              "WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY",
              "WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED",
              "WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED",
              "WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED",
              "WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE",
              "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED",
              "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES",
              "WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED"
            ],
            "type": "string",
            "format": "enum"
          },
          "failure": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Failure"
              }
            ],
            "description": "The failure details"
          },
          "identity": {
            "type": "string",
            "description": "If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task?"
          },
          "baseRunId": {
            "type": "string",
            "description": "The original run id of the workflow. For reset workflow."
          },
          "newRunId": {
            "type": "string",
            "description": "If the workflow is being reset, the new run id."
          },
          "forkEventVersion": {
            "type": "string",
            "description": "TODO: ?"
          },
          "binaryChecksum": {
            "type": "string",
            "description": "DEPRECATED since 1.21 - use `worker_version` instead.\n If a worker explicitly failed this task, its binary id"
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker who processed this workflow task. If present, the `build_id` field\n within is also used as `binary_checksum`, which may be omitted in that case (it may also be\n populated to preserve compatibility).\n Deprecated. Use the info inside the corresponding WorkflowTaskStartedEvent"
          }
        }
      },
      "WorkflowTaskScheduledEventAttributes": {
        "type": "object",
        "properties": {
          "taskQueue": {
            "allOf": [
              {
                "$ref": "#/components/schemas/TaskQueue"
              }
            ],
            "description": "The task queue this workflow task was enqueued in, which could be a normal or sticky queue"
          },
          "startToCloseTimeout": {
            "pattern": "^-?(?:0|[1-9][0-9]{0,11})(?:\\.[0-9]{1,9})?s$",
            "type": "string",
            "description": "How long the worker has to process this task once receiving it before it times out\n\n (-- api-linter: core::0140::prepositions=disabled\n     aip.dev/not-precedent: \"to\" is used to indicate interval. --)"
          },
          "attempt": {
            "type": "integer",
            "description": "Starting at 1, how many attempts there have been to complete this task",
            "format": "int32"
          }
        }
      },
      "WorkflowTaskStartedEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
          },
          "identity": {
            "type": "string",
            "description": "Identity of the worker who picked up this task"
          },
          "requestId": {
            "type": "string",
            "description": "TODO: ? Appears unused?"
          },
          "suggestContinueAsNew": {
            "type": "boolean",
            "description": "True if this workflow should continue-as-new soon because its history size (in\n either event count or bytes) is getting large."
          },
          "historySizeBytes": {
            "type": "string",
            "description": "Total history size in bytes, which the workflow might use to decide when to\n continue-as-new regardless of the suggestion. Note that history event count is\n just the event id of this event, so we don't include it explicitly here."
          },
          "workerVersion": {
            "allOf": [
              {
                "$ref": "#/components/schemas/WorkerVersionStamp"
              }
            ],
            "description": "Version info of the worker to whom this task was dispatched.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          },
          "buildIdRedirectCounter": {
            "type": "string",
            "description": "Used by server internally to properly reapply build ID redirects to an execution\n when rebuilding it from events.\n Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
          }
        }
      },
      "WorkflowTaskTimedOutEventAttributes": {
        "type": "object",
        "properties": {
          "scheduledEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
          },
          "startedEventId": {
            "type": "string",
            "description": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
          },
          "timeoutType": {
            "enum": [
              "TIMEOUT_TYPE_UNSPECIFIED",
              "TIMEOUT_TYPE_START_TO_CLOSE",
              "TIMEOUT_TYPE_SCHEDULE_TO_START",
              "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
              "TIMEOUT_TYPE_HEARTBEAT"
            ],
            "type": "string",
            "format": "enum"
          }
        }
      },
      "WorkflowType": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "description": "Represents the identifier used by a workflow author to define the workflow. Typically, the\n name of a function. This is sometimes referred to as the workflow's \"name\""
      }
    }
  },
  "tags": [
    {
      "name": "OperatorService",
      "description": "OperatorService API defines how Temporal SDKs and other clients interact with the Temporal server\n to perform administrative functions like registering a search attribute or a namespace.\n APIs in this file could be not compatible with Temporal Cloud, hence it's usage in SDKs should be limited by\n designated APIs that clearly state that they shouldn't be used by the main Application (Workflows & Activities) framework."
    },
    {
      "name": "WorkflowService",
      "description": "WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server\n to create and interact with workflows and activities.\n\n Users are expected to call `StartWorkflowExecution` to create a new workflow execution.\n\n To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow\n and activity tasks from the service. For each workflow task, the sdk must process the\n (incremental or complete) event history and respond back with any newly generated commands.\n\n For each activity task, the worker is expected to execute the user's code which implements that\n activity, responding with completion or failure."
    }
  ],
  "description": "Arbitrary payload data in an unconstrained format.\nThis may be activity input parameters, a workflow result, a memo, etc."
}
