/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/cluster-info': {
    /** @description GetClusterInfo returns information about temporal cluster */
    get: operations['GetClusterInfo'];
  };
  '/api/v1/namespaces': {
    /** @description ListNamespaces returns the information and configuration for all namespaces. */
    get: operations['ListNamespaces'];
    /**
     * @description RegisterNamespace creates a new namespace which can be used as a container for all resources.
     *
     *  A Namespace is a top level entity within Temporal, and is used as a container for resources
     *  like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
     *  isolation for all resources within the namespace. All resources belongs to exactly one
     *  namespace.
     */
    post: operations['RegisterNamespace'];
  };
  '/api/v1/namespaces/{namespace}': {
    /** @description DescribeNamespace returns the information and configuration for a registered namespace. */
    get: operations['DescribeNamespace'];
  };
  '/api/v1/namespaces/{namespace}/activities/cancel': {
    /**
     * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
     *
     *  This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
     *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *  no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCanceled'];
  };
  '/api/v1/namespaces/{namespace}/activities/cancel-by-id': {
    /**
     * @description See `RecordActivityTaskCanceled`. This version allows clients to record failures by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskCanceledById'];
  };
  '/api/v1/namespaces/{namespace}/activities/complete': {
    /**
     * @description RespondActivityTaskCompleted is called by workers when they successfully complete an activity
     *  task.
     *
     *  This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
     *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *  no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCompleted'];
  };
  '/api/v1/namespaces/{namespace}/activities/complete-by-id': {
    /**
     * @description See `RecordActivityTaskCompleted`. This version allows clients to record completions by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskCompletedById'];
  };
  '/api/v1/namespaces/{namespace}/activities/fail': {
    /**
     * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
     *
     *  This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
     *  a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
     *  longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskFailed'];
  };
  '/api/v1/namespaces/{namespace}/activities/fail-by-id': {
    /**
     * @description See `RecordActivityTaskFailed`. This version allows clients to record failures by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RespondActivityTaskFailedById'];
  };
  '/api/v1/namespaces/{namespace}/activities/heartbeat': {
    /**
     * @description RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
     *
     *  If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
     *  then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
     *  the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
     *  such situations, in that event, the SDK should request cancellation of the activity.
     */
    post: operations['RecordActivityTaskHeartbeat'];
  };
  '/api/v1/namespaces/{namespace}/activities/heartbeat-by-id': {
    /**
     * @description See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
     *  namespace/workflow id/activity id instead of task token.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "By" is used to indicate request type. --)
     */
    post: operations['RecordActivityTaskHeartbeatById'];
  };
  '/api/v1/namespaces/{namespace}/archived-workflows': {
    /** @description ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
    get: operations['ListArchivedWorkflowExecutions'];
  };
  '/api/v1/namespaces/{namespace}/batch-operations': {
    /** @description ListBatchOperations returns a list of batch operations */
    get: operations['ListBatchOperations'];
  };
  '/api/v1/namespaces/{namespace}/batch-operations/{jobId}': {
    /** @description DescribeBatchOperation returns the information about a batch operation */
    get: operations['DescribeBatchOperation'];
    /** @description StartBatchOperation starts a new batch operation */
    post: operations['StartBatchOperation'];
  };
  '/api/v1/namespaces/{namespace}/batch-operations/{jobId}/stop': {
    /** @description StopBatchOperation stops a batch operation */
    post: operations['StopBatchOperation'];
  };
  '/api/v1/namespaces/{namespace}/schedules': {
    /** @description List all schedules in a namespace. */
    get: operations['ListSchedules'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}': {
    /** @description Returns the schedule description and current state of an existing schedule. */
    get: operations['DescribeSchedule'];
    /** @description Creates a new schedule. */
    post: operations['CreateSchedule'];
    /** @description Deletes a schedule, removing it from the system. */
    delete: operations['DeleteSchedule'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/matching-times': {
    /** @description Lists matching times within a range. */
    get: operations['ListScheduleMatchingTimes'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/patch': {
    /** @description Makes a specific change to a schedule or triggers an immediate action. */
    post: operations['PatchSchedule'];
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/update': {
    /** @description Changes the configuration or state of an existing schedule. */
    post: operations['UpdateSchedule'];
  };
  '/api/v1/namespaces/{namespace}/search-attributes': {
    /** @description ListSearchAttributes returns comprehensive information about search attributes. */
    get: operations['ListSearchAttributes'];
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility': {
    /**
     * @description Deprecated. Use `GetWorkerVersioningRules`.
     *  Fetches the worker build id versioning sets for a task queue.
     */
    get: operations['GetWorkerBuildIdCompatibility'];
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules': {
    /**
     * @description Fetches the Build ID assignment and redirect rules for a Task Queue.
     *  WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
     */
    get: operations['GetWorkerVersioningRules'];
  };
  '/api/v1/namespaces/{namespace}/task-queues/{task_queue.name}': {
    /**
     * @description DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
     *    - List of pollers
     *    - Workflow Reachability status
     *    - Backlog info for Workflow and/or Activity tasks
     */
    get: operations['DescribeTaskQueue'];
  };
  '/api/v1/namespaces/{namespace}/update': {
    /**
     * @description UpdateNamespace is used to update the information and configuration of a registered
     *  namespace.
     */
    post: operations['UpdateNamespace'];
  };
  '/api/v1/namespaces/{namespace}/worker-task-reachability': {
    /**
     * @description Deprecated. Use `DescribeTaskQueue`.
     *
     *  Fetches task reachability to determine whether a worker may be retired.
     *  The request may specify task queues to query for or let the server fetch all task queues mapped to the given
     *  build IDs.
     *
     *  When requesting a large number of task queues or all task queues associated with the given build ids in a
     *  namespace, all task queues will be listed in the response but some of them may not contain reachability
     *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
     *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
     *  another call to get the reachability for those task queues.
     *
     *  Open source users can adjust this limit by setting the server's dynamic config value for
     *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
     */
    get: operations['GetWorkerTaskReachability'];
  };
  '/api/v1/namespaces/{namespace}/workflow-count': {
    /** @description CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
    get: operations['CountWorkflowExecutions'];
  };
  '/api/v1/namespaces/{namespace}/workflows': {
    /** @description ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
    get: operations['ListWorkflowExecutions'];
  };
  '/api/v1/namespaces/{namespace}/workflows/execute-multi-operation': {
    /**
     * @description ExecuteMultiOperation executes multiple operations within a single workflow.
     *
     *  Operations are started atomically, meaning if *any* operation fails to be started, none are,
     *  and the request fails. Upon start, the API returns only when *all* operations have a response.
     *
     *  Upon failure, it returns `MultiOperationExecutionFailure` where the status code
     *  equals the status code of the *first* operation that failed to be started.
     *
     *  NOTE: Experimental API.
     */
    post: operations['ExecuteMultiOperation'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}': {
    /** @description DescribeWorkflowExecution returns information about the specified workflow execution. */
    get: operations['DescribeWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history': {
    /**
     * @description GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
     *  `NotFound` if the specified workflow execution is unknown to the service.
     */
    get: operations['GetWorkflowExecutionHistory'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history-reverse': {
    /**
     * @description GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
     *  order (starting from last event). Fails with`NotFound` if the specified workflow execution is
     *  unknown to the service.
     */
    get: operations['GetWorkflowExecutionHistoryReverse'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/query/{query.query_type}': {
    /** @description QueryWorkflow requests a query be executed for a specified workflow execution. */
    post: operations['QueryWorkflow'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowId}': {
    /**
     * @description StartWorkflowExecution starts a new workflow execution.
     *
     *  It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
     *  also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
     *  instance already exists with same workflow id.
     */
    post: operations['StartWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}': {
    /**
     * @description SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
     *  it isn't yet started.
     *
     *  If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
     *  and a workflow task is generated.
     *
     *  If the workflow is not running or not found, then the workflow is created with
     *  `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
     *  workflow task is generated.
     *
     *  (-- api-linter: core::0136::prepositions=disabled
     *      aip.dev/not-precedent: "With" is used to indicate combined operation. --)
     */
    post: operations['SignalWithStartWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/cancel': {
    /**
     * @description RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
     *  a workflow execution.
     *
     *  This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
     *  workflow history and a new workflow task created for the workflow. It returns success if the requested
     *  workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
     */
    post: operations['RequestCancelWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/reset': {
    /**
     * @description ResetWorkflowExecution will reset an existing workflow execution to a specified
     *  `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
     *  execution instance.
     *  TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
     */
    post: operations['ResetWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/signal/{signalName}': {
    /**
     * @description SignalWorkflowExecution is used to send a signal to a running workflow execution.
     *
     *  This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
     *  task being created for the execution.
     */
    post: operations['SignalWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/terminate': {
    /**
     * @description TerminateWorkflowExecution terminates an existing workflow execution by recording a
     *  `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
     *  execution instance.
     */
    post: operations['TerminateWorkflowExecution'];
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update/{request.input.name}': {
    /** @description Invokes the specified update function on user workflow code. */
    post: operations['UpdateWorkflowExecution'];
  };
  '/api/v1/nexus/endpoints': {
    /**
     * @description List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
     *  next_page_token field of the previous response to get the next page of results. An empty next_page_token
     *  indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
     *  earlier than the previous page's last endpoint's ID may be missed.
     */
    get: operations['ListNexusEndpoints'];
    /**
     * @description Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
     *  ALREADY_EXISTS.
     *  Returns the created endpoint with its initial version. You may use this version for subsequent updates.
     */
    post: operations['CreateNexusEndpoint'];
  };
  '/api/v1/nexus/endpoints/{id}': {
    /** @description Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
    get: operations['GetNexusEndpoint'];
    /** @description Delete an incoming Nexus service by ID. */
    delete: operations['DeleteNexusEndpoint'];
  };
  '/api/v1/nexus/endpoints/{id}/update': {
    /**
     * @description Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
     *  `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
     *  match.
     *  Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
     *  need to increment the version yourself. The server will increment the version for you after each update.
     */
    post: operations['UpdateNexusEndpoint'];
  };
  '/api/v1/system-info': {
    /** @description GetSystemInfo returns information about the system. */
    get: operations['GetSystemInfo'];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    ActivityFailureInfo: {
      scheduledEventId?: string;
      startedEventId?: string;
      identity?: string;
      activityType?: components['schemas']['ActivityType'];
      activityId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
    };
    ActivityPropertiesModifiedExternallyEventAttributes: {
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to. */
      scheduledEventId?: string;
      /**
       * @description If set, update the retry policy of the activity, replacing it with the specified one.
       *  The number of attempts at the activity is preserved.
       */
      newRetryPolicy?: components['schemas']['RetryPolicy'];
    };
    ActivityTaskCancelRequestedEventAttributes: {
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to */
      scheduledEventId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
    };
    ActivityTaskCanceledEventAttributes: {
      /** @description Additional information that the activity reported upon confirming cancellation */
      details?: components['schemas']['Payloads'];
      /**
       * @description id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same
       *  activity
       */
      latestCancelRequestedEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to */
      startedEventId?: string;
      /** @description id of the worker who canceled this activity */
      identity?: string;
      /**
       * @description Version info of the worker who processed this workflow task.
       *  Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    ActivityTaskCompletedEventAttributes: {
      /** @description Serialized results of the activity. IE: The return value of the activity function */
      result?: components['schemas']['Payloads'];
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to */
      startedEventId?: string;
      /** @description id of the worker that completed this task */
      identity?: string;
      /**
       * @description Version info of the worker who processed this workflow task.
       *  Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    ActivityTaskFailedEventAttributes: {
      /** @description Failure details */
      failure?: components['schemas']['Failure'];
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to */
      startedEventId?: string;
      /** @description id of the worker that failed this task */
      identity?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /**
       * @description Version info of the worker who processed this workflow task.
       *  Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    ActivityTaskScheduledEventAttributes: {
      /** @description The worker/user assigned identifier for the activity */
      activityId?: string;
      activityType?: components['schemas']['ActivityType'];
      taskQueue?: components['schemas']['TaskQueue'];
      header?: components['schemas']['Header'];
      input?: components['schemas']['Payloads'];
      /**
       * @description Indicates how long the caller is willing to wait for an activity completion. Limits how long
       *  retries will be attempted. Either this or `start_to_close_timeout` must be specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      scheduleToCloseTimeout?: string;
      /**
       * @description Limits time an activity task can stay in a task queue before a worker picks it up. This
       *  timeout is always non retryable, as all a retry would achieve is to put it back into the same
       *  queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
       *  specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      scheduleToStartTimeout?: string;
      /**
       * @description Maximum time an activity is allowed to execute after being picked up by a worker. This
       *  timeout is always retryable. Either this or `schedule_to_close_timeout` must be
       *  specified.
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      startToCloseTimeout?: string;
      /** @description Maximum permitted time between successful worker heartbeats. */
      heartbeatTimeout?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * @description Activities are assigned a default retry policy controlled by the service's dynamic
       *  configuration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set
       *  retry_policy.maximum_attempts to 1.
       */
      retryPolicy?: components['schemas']['RetryPolicy'];
      /**
       * @description If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
       *  Assignment rules of the activity's Task Queue will be used to determine the Build ID.
       */
      useWorkflowBuildId?: boolean;
    };
    ActivityTaskStartedEventAttributes: {
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to */
      scheduledEventId?: string;
      /** @description id of the worker that picked up this task */
      identity?: string;
      /** @description TODO ?? */
      requestId?: string;
      /**
       * Format: int32
       * @description Starting at 1, the number of times this task has been attempted
       */
      attempt?: number;
      /**
       * @description Will be set to the most recent failure details, if this task has previously failed and then
       *  been retried.
       */
      lastFailure?: components['schemas']['Failure'];
      /** @description Version info of the worker to whom this task was dispatched. */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
      /**
       * @description Used by server internally to properly reapply build ID redirects to an execution
       *  when rebuilding it from events.
       */
      buildIdRedirectCounter?: string;
    };
    ActivityTaskTimedOutEventAttributes: {
      /**
       * @description If this activity had failed, was retried, and then timed out, that failure is stored as the
       *  `cause` in here.
       */
      failure?: components['schemas']['Failure'];
      /** @description The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to */
      startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
    };
    /**
     * @description Represents the identifier used by a activity author to define the activity. Typically, the
     *  name of a function. This is sometimes referred to as the activity's "name"
     */
    ActivityType: {
      name?: string;
    };
    /** @description Alert contains notification and severity. */
    Alert: {
      message?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      severity?:
        | 'SEVERITY_UNSPECIFIED'
        | 'SEVERITY_HIGH'
        | 'SEVERITY_MEDIUM'
        | 'SEVERITY_LOW';
    };
    ApplicationFailureInfo: {
      type?: string;
      nonRetryable?: boolean;
      details?: components['schemas']['Payloads'];
      /**
       * @description next_retry_delay can be used by the client to override the activity
       *  retry interval calculated by the retry policy. Retry attempts will
       *  still be subject to the maximum retries limit and total time limit
       *  defined by the policy.
       *  ATTENTION: this value will be ignored if set for failures produced by
       *  the workflow.
       */
      nextRetryDelay?: string;
    };
    BackfillRequest: {
      /**
       * Format: date-time
       * @description Time range to evaluate schedule in. Currently, this time range is
       *  exclusive on start_time and inclusive on end_time. (This is admittedly
       *  counterintuitive and it may change in the future, so to be safe, use a
       *  start time strictly before a scheduled time.) Also note that an action
       *  nominally scheduled in the interval but with jitter that pushes it after
       *  end_time will not be included.
       */
      startTime?: string;
      /** Format: date-time */
      endTime?: string;
      /**
       * Format: enum
       * @description If set, override overlap policy for this request.
       * @enum {string}
       */
      overlapPolicy?:
        | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
        | 'SCHEDULE_OVERLAP_POLICY_SKIP'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
        | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
    };
    BadBinaries: {
      binaries?: {
        [key: string]: components['schemas']['BadBinaryInfo'];
      };
    };
    BadBinaryInfo: {
      reason?: string;
      operator?: string;
      /** Format: date-time */
      createTime?: string;
    };
    /**
     * @description BatchOperationCancellation sends cancel requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
     *  Ignore first_execution_run_id because this is used for single workflow operation.
     */
    BatchOperationCancellation: {
      /** @description The identity of the worker/client */
      identity?: string;
    };
    /**
     * @description BatchOperationDeletion sends deletion requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
     */
    BatchOperationDeletion: {
      /** @description The identity of the worker/client */
      identity?: string;
    };
    BatchOperationInfo: {
      /** @description Batch job ID */
      jobId?: string;
      /**
       * Format: enum
       * @description Batch operation state
       * @enum {string}
       */
      state?:
        | 'BATCH_OPERATION_STATE_UNSPECIFIED'
        | 'BATCH_OPERATION_STATE_RUNNING'
        | 'BATCH_OPERATION_STATE_COMPLETED'
        | 'BATCH_OPERATION_STATE_FAILED';
      /**
       * Format: date-time
       * @description Batch operation start time
       */
      startTime?: string;
      /**
       * Format: date-time
       * @description Batch operation close time
       */
      closeTime?: string;
    };
    /**
     * @description BatchOperationReset sends reset requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
     */
    BatchOperationReset: {
      /** @description The identity of the worker/client. */
      identity?: string;
      /** @description Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored. */
      options?: components['schemas']['ResetOptions'];
      /**
       * Format: enum
       * @description Reset type (deprecated, use `options`).
       * @enum {string}
       */
      resetType?:
        | 'RESET_TYPE_UNSPECIFIED'
        | 'RESET_TYPE_FIRST_WORKFLOW_TASK'
        | 'RESET_TYPE_LAST_WORKFLOW_TASK';
      /**
       * Format: enum
       * @description History event reapply options (deprecated, use `options`).
       * @enum {string}
       */
      resetReapplyType?:
        | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_TYPE_SIGNAL'
        | 'RESET_REAPPLY_TYPE_NONE'
        | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
    };
    /**
     * @description BatchOperationSignal sends signals to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
     */
    BatchOperationSignal: {
      /** @description The workflow author-defined name of the signal to send to the workflow */
      signal?: string;
      /** @description Serialized value(s) to provide with the signal */
      input?: components['schemas']['Payloads'];
      /**
       * @description Headers that are passed with the signal to the processing workflow.
       *  These can include things like auth or tracing tokens.
       */
      header?: components['schemas']['Header'];
      /** @description The identity of the worker/client */
      identity?: string;
    };
    /**
     * @description BatchOperationTermination sends terminate requests to batch workflows.
     *  Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
     *  Ignore first_execution_run_id because this is used for single workflow operation.
     */
    BatchOperationTermination: {
      /** @description Serialized value(s) to provide to the termination event */
      details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
    };
    /**
     * @description These rules assign a Build ID to Unassigned Workflow Executions and
     *  Activities.
     *
     *  Specifically, assignment rules are applied to the following Executions or
     *  Activities when they are scheduled in a Task Queue:
     *     - Generally, any new Workflow Execution, except:
     *       - When A Child Workflow or a Continue-As-New Execution inherits the
     *         Build ID from its parent/previous execution by setting the
     *         `inherit_build_id` flag.
     *       - Workflow Executions started Eagerly are assigned to the Build ID of
     *         the Starter.
     *     - An Activity that is scheduled on a Task Queue different from the one
     *       their Workflow runs on, unless the `use_workflow_build_id` flag is set.
     *
     *  In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
     *  the task will be dispatched to Workers of the Build ID determined by the
     *  assignment rules. Otherwise, the final Build ID will be determined by the
     *  redirect rules.
     *
     *  When using Worker Versioning, in the steady state, for a given Task Queue,
     *  there should typically be exactly one assignment rule to send all Unassigned
     *  tasks to the latest Build ID. Existence of at least one such "unconditional"
     *  rule at all times is enforce by the system, unless the `force` flag is used
     *  by the user when replacing/deleting these rules (for exceptional cases).
     *
     *  During a deployment, one or more additional rules can be added to assign a
     *  subset of the tasks to a new Build ID based on a "ramp percentage".
     *
     *  When there are multiple assignment rules for a Task Queue, the rules are
     *  evaluated in order, starting from index 0. The first applicable rule will be
     *  applied and the rest will be ignored.
     *
     *  In the event that no assignment rule is applicable on a task (or the Task
     *  Queue is simply not versioned), the tasks will be sent to unversioned
     *  workers, if available. Otherwise, they remain Unassigned, and will be
     *  retried for assignment, or dispatch to unversioned workers, at a later time
     *  depending on the availability of workers.
     */
    BuildIdAssignmentRule: {
      targetBuildId?: string;
      /**
       * @description This ramp is useful for gradual Blue/Green deployments (and similar)
       *  where you want to send a certain portion of the traffic to the target
       *  Build ID.
       */
      percentageRamp?: components['schemas']['RampByPercentage'];
    };
    /** @description Reachability of tasks for a worker by build id, in one or more task queues. */
    BuildIdReachability: {
      /** @description A build id or empty if unversioned. */
      buildId?: string;
      /** @description Reachability per task queue. */
      taskQueueReachability?: components['schemas']['TaskQueueReachability'][];
    };
    /**
     * @description CalendarSpec describes an event specification relative to the calendar,
     *  similar to a traditional cron specification, but with labeled fields. Each
     *  field can be one of:
     *    *: matches always
     *    x: matches when the field equals x
     *    x/y : matches when the field equals x+n*y where n is an integer
     *    x-z: matches when the field is between x and z inclusive
     *    w,x,y,...: matches when the field is one of the listed values
     *  Each x, y, z, ... is either a decimal integer, or a month or day of week name
     *  or abbreviation (in the appropriate fields).
     *  A timestamp matches if all fields match.
     *  Note that fields have different default values, for convenience.
     *  Note that the special case that some cron implementations have for treating
     *  day_of_month and day_of_week as "or" instead of "and" when both are set is
     *  not implemented.
     *  day_of_week can accept 0 or 7 as Sunday
     *  CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
     *  returned if you describe the schedule.
     */
    CalendarSpec: {
      /** @description Expression to match seconds. Default: 0 */
      second?: string;
      /** @description Expression to match minutes. Default: 0 */
      minute?: string;
      /** @description Expression to match hours. Default: 0 */
      hour?: string;
      /**
       * @description Expression to match days of the month. Default: *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: standard name of field --)
       */
      dayOfMonth?: string;
      /** @description Expression to match months. Default: * */
      month?: string;
      /** @description Expression to match years. Default: * */
      year?: string;
      /** @description Expression to match days of the week. Default: * */
      dayOfWeek?: string;
      /** @description Free-form comment describing the intention of this spec. */
      comment?: string;
    };
    /** @description Callback to attach to various events in the system, e.g. workflow run completion. */
    Callback: {
      nexus?: components['schemas']['Callback_Nexus'];
    };
    /** @description CallbackInfo contains the state of an attached workflow callback. */
    CallbackInfo: {
      /** @description Information on how this callback should be invoked (e.g. its URL and type). */
      callback?: components['schemas']['Callback'];
      /** @description Trigger for this callback. */
      trigger?: components['schemas']['CallbackInfo_Trigger'];
      /**
       * Format: date-time
       * @description The time when the callback was registered.
       */
      registrationTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'CALLBACK_STATE_UNSPECIFIED'
        | 'CALLBACK_STATE_STANDBY'
        | 'CALLBACK_STATE_SCHEDULED'
        | 'CALLBACK_STATE_BACKING_OFF'
        | 'CALLBACK_STATE_FAILED'
        | 'CALLBACK_STATE_SUCCEEDED';
      /**
       * Format: int32
       * @description The number of attempts made to deliver the callback.
       *  This number represents a minimum bound since the attempt is incremented after the callback request completes.
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      lastAttemptCompleteTime?: string;
      /** @description The last attempt's failure, if any. */
      lastAttemptFailure?: components['schemas']['Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      nextAttemptScheduleTime?: string;
    };
    CallbackInfo_Trigger: {
      workflowClosed?: components['schemas']['CallbackInfo_WorkflowClosed'];
    };
    /** @description Trigger for when the workflow is closed. */
    CallbackInfo_WorkflowClosed: Record<string, never>;
    Callback_Nexus: {
      /** @description Callback URL. */
      url?: string;
      /** @description Header to attach to callback request. */
      header?: {
        [key: string]: string;
      };
    };
    CanceledFailureInfo: {
      details?: components['schemas']['Payloads'];
    };
    ChildWorkflowExecutionCanceledEventAttributes: {
      details?: components['schemas']['Payloads'];
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      startedEventId?: string;
    };
    ChildWorkflowExecutionCompletedEventAttributes: {
      result?: components['schemas']['Payloads'];
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      startedEventId?: string;
    };
    ChildWorkflowExecutionFailedEventAttributes: {
      failure?: components['schemas']['Failure'];
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
    };
    ChildWorkflowExecutionFailureInfo: {
      namespace?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      initiatedEventId?: string;
      startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
    };
    ChildWorkflowExecutionStartedEventAttributes: {
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      header?: components['schemas']['Header'];
    };
    ChildWorkflowExecutionTerminatedEventAttributes: {
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      startedEventId?: string;
    };
    ChildWorkflowExecutionTimedOutEventAttributes: {
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      /** @description Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to */
      startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
    };
    ClusterReplicationConfig: {
      clusterName?: string;
    };
    /**
     * @description These rules apply to tasks assigned to a particular Build ID
     *  (`source_build_id`) to redirect them to another *compatible* Build ID
     *  (`target_build_id`).
     *
     *  It is user's responsibility to ensure that the target Build ID is compatible
     *  with the source Build ID (e.g. by using the Patching API).
     *
     *  Most deployments are not expected to need these rules, however following
     *  situations can greatly benefit from redirects:
     *   - Need to move long-running Workflow Executions from an old Build ID to a
     *     newer one.
     *   - Need to hotfix some broken or stuck Workflow Executions.
     *
     *  In steady state, redirect rules are beneficial when dealing with old
     *  Executions ran on now-decommissioned Build IDs:
     *   - To redirecting the Workflow Queries to the current (compatible) Build ID.
     *   - To be able to Reset an old Execution so it can run on the current
     *     (compatible) Build ID.
     *
     *  Redirect rules can be chained, but only the last rule in the chain can have
     *  a ramp.
     */
    CompatibleBuildIdRedirectRule: {
      sourceBuildId?: string;
      targetBuildId?: string;
    };
    /**
     * @description Used by the worker versioning APIs, represents an unordered set of one or more versions which are
     *  considered to be compatible with each other. Currently the versions are always worker build IDs.
     */
    CompatibleVersionSet: {
      /** @description All the compatible versions, unordered, except for the last element, which is considered the set "default". */
      buildIds?: string[];
    };
    CountWorkflowExecutionsResponse: {
      /**
       * @description If `query` is not grouping by any field, the count is an approximate number
       *  of workflows that matches the query.
       *  If `query` is grouping by a field, the count is simply the sum of the counts
       *  of the groups returned in the response. This number can be smaller than the
       *  total number of workflows matching the query.
       */
      count?: string;
      /**
       * @description `groups` contains the groups if the request is grouping by a field.
       *  The list might not be complete, and the counts of each group is approximate.
       */
      groups?: components['schemas']['CountWorkflowExecutionsResponse_AggregationGroup'][];
    };
    CountWorkflowExecutionsResponse_AggregationGroup: {
      groupValues?: components['schemas']['Payload'][];
      count?: string;
    };
    CreateNexusEndpointRequest: {
      /** @description Endpoint definition to create. */
      spec?: components['schemas']['EndpointSpec'];
    };
    CreateNexusEndpointResponse: {
      /** @description Data post acceptance. Can be used to issue additional updates to this record. */
      endpoint?: components['schemas']['Endpoint'];
    };
    /**
     * @description (-- api-linter: core::0203::optional=disabled
     *      aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
     */
    CreateScheduleRequest: {
      /** @description The namespace the schedule should be created in. */
      namespace?: string;
      /** @description The id of the new schedule. */
      scheduleId?: string;
      /** @description The schedule spec, policies, action, and initial state. */
      schedule?: components['schemas']['Schedule'];
      /** @description Optional initial patch (e.g. to run the action once immediately). */
      initialPatch?: components['schemas']['SchedulePatch'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description A unique identifier for this create request for idempotence. Typically UUIDv4. */
      requestId?: string;
      /** @description Memo and search attributes to attach to the schedule itself. */
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
    };
    CreateScheduleResponse: {
      /** Format: bytes */
      conflictToken?: string;
    };
    DataBlob: {
      /**
       * Format: enum
       * @enum {string}
       */
      encodingType?:
        | 'ENCODING_TYPE_UNSPECIFIED'
        | 'ENCODING_TYPE_PROTO3'
        | 'ENCODING_TYPE_JSON';
      /** Format: bytes */
      data?: string;
    };
    DeleteNexusEndpointResponse: Record<string, never>;
    DeleteScheduleResponse: Record<string, never>;
    DescribeBatchOperationResponse: {
      /**
       * Format: enum
       * @description Batch operation type
       * @enum {string}
       */
      operationType?:
        | 'BATCH_OPERATION_TYPE_UNSPECIFIED'
        | 'BATCH_OPERATION_TYPE_TERMINATE'
        | 'BATCH_OPERATION_TYPE_CANCEL'
        | 'BATCH_OPERATION_TYPE_SIGNAL'
        | 'BATCH_OPERATION_TYPE_DELETE'
        | 'BATCH_OPERATION_TYPE_RESET';
      /** @description Batch job ID */
      jobId?: string;
      /**
       * Format: enum
       * @description Batch operation state
       * @enum {string}
       */
      state?:
        | 'BATCH_OPERATION_STATE_UNSPECIFIED'
        | 'BATCH_OPERATION_STATE_RUNNING'
        | 'BATCH_OPERATION_STATE_COMPLETED'
        | 'BATCH_OPERATION_STATE_FAILED';
      /**
       * Format: date-time
       * @description Batch operation start time
       */
      startTime?: string;
      /**
       * Format: date-time
       * @description Batch operation close time
       */
      closeTime?: string;
      /** @description Total operation count */
      totalOperationCount?: string;
      /** @description Complete operation count */
      completeOperationCount?: string;
      /** @description Failure operation count */
      failureOperationCount?: string;
      /** @description Identity indicates the operator identity */
      identity?: string;
      /** @description Reason indicates the reason to stop a operation */
      reason?: string;
    };
    DescribeNamespaceResponse: {
      namespaceInfo?: components['schemas']['NamespaceInfo'];
      config?: components['schemas']['NamespaceConfig'];
      replicationConfig?: components['schemas']['NamespaceReplicationConfig'];
      failoverVersion?: string;
      isGlobalNamespace?: boolean;
      /**
       * @description Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
       *  states to ensure that the list does not grow unbounded.
       */
      failoverHistory?: components['schemas']['FailoverStatus'][];
    };
    DescribeScheduleResponse: {
      /**
       * @description The complete current schedule details. This may not match the schedule as
       *  created because:
       *  - some types of schedule specs may get compiled into others (e.g.
       *    CronString into StructuredCalendarSpec)
       *  - some unspecified fields may be replaced by defaults
       *  - some fields in the state are modified automatically
       *  - the schedule may have been modified by UpdateSchedule or PatchSchedule
       */
      schedule?: components['schemas']['Schedule'];
      /** @description Extra schedule state info. */
      info?: components['schemas']['ScheduleInfo'];
      /** @description The memo and search attributes that the schedule was created with. */
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      /**
       * Format: bytes
       * @description This value can be passed back to UpdateSchedule to ensure that the
       *  schedule was not modified between a Describe and an Update, which could
       *  lead to lost updates and other confusion.
       */
      conflictToken?: string;
    };
    DescribeTaskQueueResponse: {
      /**
       * @description Deprecated. Use `versions_info.types_info.pollers` with `ENHANCED` mode instead.
       *  Not set in `ENHANCED` mode.
       */
      pollers?: components['schemas']['PollerInfo'][];
      /** @description Deprecated. Not set in `ENHANCED` mode. */
      taskQueueStatus?: components['schemas']['TaskQueueStatus'];
      /**
       * @description This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
       *  Only set in `ENHANCED` mode.
       */
      versionsInfo?: {
        [key: string]: components['schemas']['TaskQueueVersionInfo'];
      };
    };
    DescribeWorkflowExecutionResponse: {
      executionConfig?: components['schemas']['WorkflowExecutionConfig'];
      workflowExecutionInfo?: components['schemas']['WorkflowExecutionInfo'];
      pendingActivities?: components['schemas']['PendingActivityInfo'][];
      pendingChildren?: components['schemas']['PendingChildExecutionInfo'][];
      pendingWorkflowTask?: components['schemas']['PendingWorkflowTaskInfo'];
      callbacks?: components['schemas']['CallbackInfo'][];
      pendingNexusOperations?: components['schemas']['PendingNexusOperationInfo'][];
    };
    /** @description A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests. */
    Endpoint: {
      /** @description Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API. */
      version?: string;
      /** @description Unique server-generated endpoint ID. */
      id?: string;
      /** @description Spec for the endpoint. */
      spec?: components['schemas']['EndpointSpec'];
      /**
       * Format: date-time
       * @description The date and time when the endpoint was created.
       *  (-- api-linter: core::0142::time-field-names=disabled
       *      aip.dev/not-precedent: Not following linter rules. --)
       */
      createdTime?: string;
      /**
       * Format: date-time
       * @description The date and time when the endpoint was last modified.
       *  Will not be set if the endpoint has never been modified.
       *  (-- api-linter: core::0142::time-field-names=disabled
       *      aip.dev/not-precedent: Not following linter rules. --)
       */
      lastModifiedTime?: string;
      /**
       * @description Server exposed URL prefix for invocation of operations on this endpoint.
       *  This doesn't include the protocol, hostname or port as the server does not know how it should be accessed
       *  publicly. The URL is stable in the face of endpoint renames.
       */
      urlPrefix?: string;
    };
    /** @description Contains mutable fields for an Endpoint. */
    EndpointSpec: {
      /**
       * @description Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.
       *  Renaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail.
       */
      name?: string;
      /**
       * @description Markdown description serialized as a single JSON string.
       *  If the Payload is encrypted, the UI and CLI may decrypt with the configured codec server endpoint.
       */
      description?: components['schemas']['Payload'];
      /** @description Target to route requests to. */
      target?: components['schemas']['EndpointTarget'];
    };
    /** @description Target to route requests to. */
    EndpointTarget: {
      worker?: components['schemas']['EndpointTarget_Worker'];
      external?: components['schemas']['EndpointTarget_External'];
    };
    /**
     * @description Target an external server by URL.
     *  At a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected
     *  into the server to modify the request.
     */
    EndpointTarget_External: {
      /** @description URL to call. */
      url?: string;
    };
    /** @description Target a worker polling on a Nexus task queue in a specific namespace. */
    EndpointTarget_Worker: {
      /** @description Namespace to route requests to. */
      namespace?: string;
      /** @description Nexus task queue to route requests to. */
      taskQueue?: string;
    };
    ExecuteMultiOperationRequest: {
      namespace?: string;
      /**
       * @description List of operations to execute within a single workflow.
       *
       *  Preconditions:
       *  - The list of operations must not be empty.
       *  - The workflow ids must match across operations.
       *  - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
       *
       *  Note that additional operation-specific restrictions have to be considered.
       */
      operations?: components['schemas']['ExecuteMultiOperationRequest_Operation'][];
    };
    ExecuteMultiOperationRequest_Operation: {
      /**
       * @description Additional restrictions:
       *  - setting `cron_schedule` is invalid
       *  - setting `request_eager_execution` is invalid
       */
      startWorkflow?: components['schemas']['StartWorkflowExecutionRequest'];
      updateWorkflow?: components['schemas']['UpdateWorkflowExecutionRequest'];
    };
    ExecuteMultiOperationResponse: {
      responses?: components['schemas']['ExecuteMultiOperationResponse_Response'][];
    };
    ExecuteMultiOperationResponse_Response: {
      startWorkflow?: components['schemas']['StartWorkflowExecutionResponse'];
      updateWorkflow?: components['schemas']['UpdateWorkflowExecutionResponse'];
    };
    ExternalWorkflowExecutionCancelRequestedEventAttributes: {
      /**
       * @description id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds
       *  to
       */
      initiatedEventId?: string;
      /**
       * @description Namespace of the to-be-cancelled workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
    };
    ExternalWorkflowExecutionSignaledEventAttributes: {
      /** @description id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to */
      initiatedEventId?: string;
      /**
       * @description Namespace of the workflow which was signaled.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description Deprecated */
      control?: string;
    };
    /** @description Represents a historical replication status of a Namespace */
    FailoverStatus: {
      /**
       * Format: date-time
       * @description Timestamp when the Cluster switched to the following failover_version
       */
      failoverTime?: string;
      failoverVersion?: string;
    };
    Failure: {
      message?: string;
      /**
       * @description The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
       *  In some SDKs this is used to rehydrate the stack trace into an exception object.
       */
      source?: string;
      stackTrace?: string;
      /**
       * @description Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
       *  errors originating in user code which might contain sensitive information.
       *  The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
       *  message.
       *
       *  SDK authors:
       *  - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
       *    - Uses a JSON object to represent `{ message, stack_trace }`.
       *    - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
       *    - Overwrites the original stack_trace with an empty string.
       *    - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
       *      by the user-provided PayloadCodec
       *
       *  - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
       */
      encodedAttributes?: components['schemas']['Payload'];
      cause?: components['schemas']['Failure'];
      applicationFailureInfo?: components['schemas']['ApplicationFailureInfo'];
      timeoutFailureInfo?: components['schemas']['TimeoutFailureInfo'];
      canceledFailureInfo?: components['schemas']['CanceledFailureInfo'];
      terminatedFailureInfo?: components['schemas']['TerminatedFailureInfo'];
      serverFailureInfo?: components['schemas']['ServerFailureInfo'];
      resetWorkflowFailureInfo?: components['schemas']['ResetWorkflowFailureInfo'];
      activityFailureInfo?: components['schemas']['ActivityFailureInfo'];
      childWorkflowExecutionFailureInfo?: components['schemas']['ChildWorkflowExecutionFailureInfo'];
      nexusOperationExecutionFailureInfo?: components['schemas']['NexusOperationFailureInfo'];
    };
    /** @description GetClusterInfoResponse contains information about Temporal cluster. */
    GetClusterInfoResponse: {
      /**
       * @description Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
       *  Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
       */
      supportedClients?: {
        [key: string]: string;
      };
      serverVersion?: string;
      clusterId?: string;
      versionInfo?: components['schemas']['VersionInfo'];
      clusterName?: string;
      /** Format: int32 */
      historyShardCount?: number;
      persistenceStore?: string;
      visibilityStore?: string;
    };
    GetNexusEndpointResponse: {
      endpoint?: components['schemas']['Endpoint'];
    };
    GetSystemInfoResponse: {
      /** @description Version of the server. */
      serverVersion?: string;
      /** @description All capabilities the system supports. */
      capabilities?: components['schemas']['GetSystemInfoResponse_Capabilities'];
    };
    /** @description System capability details. */
    GetSystemInfoResponse_Capabilities: {
      /** @description True if signal and query headers are supported. */
      signalAndQueryHeader?: boolean;
      /**
       * @description True if internal errors are differentiated from other types of errors for purposes of
       *  retrying non-internal errors.
       *
       *  When unset/false, clients retry all failures. When true, clients should only retry
       *  non-internal errors.
       */
      internalErrorDifferentiation?: boolean;
      /** @description True if RespondActivityTaskFailed API supports including heartbeat details */
      activityFailureIncludeHeartbeat?: boolean;
      /** @description Supports scheduled workflow features. */
      supportsSchedules?: boolean;
      /** @description True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes */
      encodedFailureAttributes?: boolean;
      /**
       * @description True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
       *  (see:
       *  https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
       */
      buildIdBasedVersioning?: boolean;
      /** @description True if server supports upserting workflow memo */
      upsertMemo?: boolean;
      /** @description True if server supports eager workflow task dispatching for the StartWorkflowExecution API */
      eagerWorkflowStart?: boolean;
      /**
       * @description True if the server knows about the sdk metadata field on WFT completions and will record
       *  it in history
       */
      sdkMetadata?: boolean;
      /** @description True if the server supports count group by execution status */
      countGroupByExecutionStatus?: boolean;
    };
    GetWorkerBuildIdCompatibilityResponse: {
      /**
       * @description Major version sets, in order from oldest to newest. The last element of the list will always
       *  be the current default major version. IE: New workflows will target the most recent version
       *  in that version set.
       *
       *  There may be fewer sets returned than exist, if the request chose to limit this response.
       */
      majorVersionSets?: components['schemas']['CompatibleVersionSet'][];
    };
    /** @description Deprecated. Use `DescribeTaskQueue`. */
    GetWorkerTaskReachabilityResponse: {
      /**
       * @description Task reachability, broken down by build id and then task queue.
       *  When requesting a large number of task queues or all task queues associated with the given build ids in a
       *  namespace, all task queues will be listed in the response but some of them may not contain reachability
       *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
       *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
       *  another call to get the reachability for those task queues.
       *
       *  Open source users can adjust this limit by setting the server's dynamic config value for
       *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
       */
      buildIdReachability?: components['schemas']['BuildIdReachability'][];
    };
    GetWorkerVersioningRulesResponse: {
      assignmentRules?: components['schemas']['TimestampedBuildIdAssignmentRule'][];
      compatibleRedirectRules?: components['schemas']['TimestampedCompatibleBuildIdRedirectRule'][];
      /**
       * Format: bytes
       * @description This value can be passed back to UpdateWorkerVersioningRulesRequest to
       *  ensure that the rules were not modified between this List and the Update,
       *  which could lead to lost updates and other confusion.
       */
      conflictToken?: string;
    };
    GetWorkflowExecutionHistoryResponse: {
      history?: components['schemas']['History'];
      /**
       * @description Raw history is an alternate representation of history that may be returned if configured on
       *  the frontend. This is not supported by all SDKs. Either this or `history` will be set.
       */
      rawHistory?: components['schemas']['DataBlob'][];
      /**
       * Format: bytes
       * @description Will be set if there are more history events than were included in this response
       */
      nextPageToken?: string;
      archived?: boolean;
    };
    GetWorkflowExecutionHistoryReverseResponse: {
      history?: components['schemas']['History'];
      /**
       * Format: bytes
       * @description Will be set if there are more history events than were included in this response
       */
      nextPageToken?: string;
    };
    /** @description Contains an arbitrary serialized message along with a @type that describes the type of the serialized message. */
    GoogleProtobufAny: {
      /** @description The type of the serialized message. */
      '@type'?: string;
      [key: string]: unknown;
    };
    /**
     * @description Contains metadata that can be attached to a variety of requests, like starting a workflow, and
     *  can be propagated between, for example, workflows and activities.
     */
    Header: {
      fields?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    History: {
      events?: components['schemas']['HistoryEvent'][];
    };
    /**
     * @description History events are the method by which Temporal SDKs advance (or recreate) workflow state.
     *  See the `EventType` enum for more info about what each event is for.
     */
    HistoryEvent: {
      /** @description Monotonically increasing event number, starts at 1. */
      eventId?: string;
      /** Format: date-time */
      eventTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      eventType?:
        | 'EVENT_TYPE_UNSPECIFIED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_STARTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT'
        | 'EVENT_TYPE_WORKFLOW_TASK_SCHEDULED'
        | 'EVENT_TYPE_WORKFLOW_TASK_STARTED'
        | 'EVENT_TYPE_WORKFLOW_TASK_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT'
        | 'EVENT_TYPE_WORKFLOW_TASK_FAILED'
        | 'EVENT_TYPE_ACTIVITY_TASK_SCHEDULED'
        | 'EVENT_TYPE_ACTIVITY_TASK_STARTED'
        | 'EVENT_TYPE_ACTIVITY_TASK_COMPLETED'
        | 'EVENT_TYPE_ACTIVITY_TASK_FAILED'
        | 'EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT'
        | 'EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED'
        | 'EVENT_TYPE_ACTIVITY_TASK_CANCELED'
        | 'EVENT_TYPE_TIMER_STARTED'
        | 'EVENT_TYPE_TIMER_FIRED'
        | 'EVENT_TYPE_TIMER_CANCELED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED'
        | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
        | 'EVENT_TYPE_MARKER_RECORDED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW'
        | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT'
        | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED'
        | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
        | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
        | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED'
        | 'EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED'
        | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY'
        | 'EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY'
        | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED'
        | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED'
        | 'EVENT_TYPE_NEXUS_OPERATION_SCHEDULED'
        | 'EVENT_TYPE_NEXUS_OPERATION_STARTED'
        | 'EVENT_TYPE_NEXUS_OPERATION_COMPLETED'
        | 'EVENT_TYPE_NEXUS_OPERATION_FAILED'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCELED'
        | 'EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT'
        | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED';
      /** @description TODO: What is this? Appears unused by SDKs */
      version?: string;
      /** @description TODO: What is this? Appears unused by SDKs */
      taskId?: string;
      /**
       * @description Set to true when the SDK may ignore the event as it does not impact workflow state or
       *  information in any way that the SDK need be concerned with. If an SDK encounters an event
       *  type which it does not understand, it must error unless this is true. If it is true, it's
       *  acceptable for the event type and/or attributes to be uninterpretable.
       */
      workerMayIgnore?: boolean;
      workflowExecutionStartedEventAttributes?: components['schemas']['WorkflowExecutionStartedEventAttributes'];
      workflowExecutionCompletedEventAttributes?: components['schemas']['WorkflowExecutionCompletedEventAttributes'];
      workflowExecutionFailedEventAttributes?: components['schemas']['WorkflowExecutionFailedEventAttributes'];
      workflowExecutionTimedOutEventAttributes?: components['schemas']['WorkflowExecutionTimedOutEventAttributes'];
      workflowTaskScheduledEventAttributes?: components['schemas']['WorkflowTaskScheduledEventAttributes'];
      workflowTaskStartedEventAttributes?: components['schemas']['WorkflowTaskStartedEventAttributes'];
      workflowTaskCompletedEventAttributes?: components['schemas']['WorkflowTaskCompletedEventAttributes'];
      workflowTaskTimedOutEventAttributes?: components['schemas']['WorkflowTaskTimedOutEventAttributes'];
      workflowTaskFailedEventAttributes?: components['schemas']['WorkflowTaskFailedEventAttributes'];
      activityTaskScheduledEventAttributes?: components['schemas']['ActivityTaskScheduledEventAttributes'];
      activityTaskStartedEventAttributes?: components['schemas']['ActivityTaskStartedEventAttributes'];
      activityTaskCompletedEventAttributes?: components['schemas']['ActivityTaskCompletedEventAttributes'];
      activityTaskFailedEventAttributes?: components['schemas']['ActivityTaskFailedEventAttributes'];
      activityTaskTimedOutEventAttributes?: components['schemas']['ActivityTaskTimedOutEventAttributes'];
      timerStartedEventAttributes?: components['schemas']['TimerStartedEventAttributes'];
      timerFiredEventAttributes?: components['schemas']['TimerFiredEventAttributes'];
      activityTaskCancelRequestedEventAttributes?: components['schemas']['ActivityTaskCancelRequestedEventAttributes'];
      activityTaskCanceledEventAttributes?: components['schemas']['ActivityTaskCanceledEventAttributes'];
      timerCanceledEventAttributes?: components['schemas']['TimerCanceledEventAttributes'];
      markerRecordedEventAttributes?: components['schemas']['MarkerRecordedEventAttributes'];
      workflowExecutionSignaledEventAttributes?: components['schemas']['WorkflowExecutionSignaledEventAttributes'];
      workflowExecutionTerminatedEventAttributes?: components['schemas']['WorkflowExecutionTerminatedEventAttributes'];
      workflowExecutionCancelRequestedEventAttributes?: components['schemas']['WorkflowExecutionCancelRequestedEventAttributes'];
      workflowExecutionCanceledEventAttributes?: components['schemas']['WorkflowExecutionCanceledEventAttributes'];
      requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: components['schemas']['RequestCancelExternalWorkflowExecutionInitiatedEventAttributes'];
      requestCancelExternalWorkflowExecutionFailedEventAttributes?: components['schemas']['RequestCancelExternalWorkflowExecutionFailedEventAttributes'];
      externalWorkflowExecutionCancelRequestedEventAttributes?: components['schemas']['ExternalWorkflowExecutionCancelRequestedEventAttributes'];
      workflowExecutionContinuedAsNewEventAttributes?: components['schemas']['WorkflowExecutionContinuedAsNewEventAttributes'];
      startChildWorkflowExecutionInitiatedEventAttributes?: components['schemas']['StartChildWorkflowExecutionInitiatedEventAttributes'];
      startChildWorkflowExecutionFailedEventAttributes?: components['schemas']['StartChildWorkflowExecutionFailedEventAttributes'];
      childWorkflowExecutionStartedEventAttributes?: components['schemas']['ChildWorkflowExecutionStartedEventAttributes'];
      childWorkflowExecutionCompletedEventAttributes?: components['schemas']['ChildWorkflowExecutionCompletedEventAttributes'];
      childWorkflowExecutionFailedEventAttributes?: components['schemas']['ChildWorkflowExecutionFailedEventAttributes'];
      childWorkflowExecutionCanceledEventAttributes?: components['schemas']['ChildWorkflowExecutionCanceledEventAttributes'];
      childWorkflowExecutionTimedOutEventAttributes?: components['schemas']['ChildWorkflowExecutionTimedOutEventAttributes'];
      childWorkflowExecutionTerminatedEventAttributes?: components['schemas']['ChildWorkflowExecutionTerminatedEventAttributes'];
      signalExternalWorkflowExecutionInitiatedEventAttributes?: components['schemas']['SignalExternalWorkflowExecutionInitiatedEventAttributes'];
      signalExternalWorkflowExecutionFailedEventAttributes?: components['schemas']['SignalExternalWorkflowExecutionFailedEventAttributes'];
      externalWorkflowExecutionSignaledEventAttributes?: components['schemas']['ExternalWorkflowExecutionSignaledEventAttributes'];
      upsertWorkflowSearchAttributesEventAttributes?: components['schemas']['UpsertWorkflowSearchAttributesEventAttributes'];
      workflowExecutionUpdateAcceptedEventAttributes?: components['schemas']['WorkflowExecutionUpdateAcceptedEventAttributes'];
      workflowExecutionUpdateRejectedEventAttributes?: components['schemas']['WorkflowExecutionUpdateRejectedEventAttributes'];
      workflowExecutionUpdateCompletedEventAttributes?: components['schemas']['WorkflowExecutionUpdateCompletedEventAttributes'];
      workflowPropertiesModifiedExternallyEventAttributes?: components['schemas']['WorkflowPropertiesModifiedExternallyEventAttributes'];
      activityPropertiesModifiedExternallyEventAttributes?: components['schemas']['ActivityPropertiesModifiedExternallyEventAttributes'];
      workflowPropertiesModifiedEventAttributes?: components['schemas']['WorkflowPropertiesModifiedEventAttributes'];
      workflowExecutionUpdateAdmittedEventAttributes?: components['schemas']['WorkflowExecutionUpdateAdmittedEventAttributes'];
      nexusOperationScheduledEventAttributes?: components['schemas']['NexusOperationScheduledEventAttributes'];
      nexusOperationStartedEventAttributes?: components['schemas']['NexusOperationStartedEventAttributes'];
      nexusOperationCompletedEventAttributes?: components['schemas']['NexusOperationCompletedEventAttributes'];
      nexusOperationFailedEventAttributes?: components['schemas']['NexusOperationFailedEventAttributes'];
      nexusOperationCanceledEventAttributes?: components['schemas']['NexusOperationCanceledEventAttributes'];
      nexusOperationTimedOutEventAttributes?: components['schemas']['NexusOperationTimedOutEventAttributes'];
      nexusOperationCancelRequestedEventAttributes?: components['schemas']['NexusOperationCancelRequestedEventAttributes'];
    };
    Input: {
      /**
       * @description Headers that are passed with the update from the requesting entity.
       *  These can include things like auth or tracing tokens.
       */
      header?: components['schemas']['Header'];
      /** @description The name of the input handler to invoke on the target workflow */
      name?: string;
      /** @description The arguments to pass to the named handler. */
      args?: components['schemas']['Payloads'];
    };
    /**
     * @description IntervalSpec matches times that can be expressed as:
     *  epoch + n * interval + phase
     *  where n is an integer.
     *  phase defaults to zero if missing. interval is required.
     *  Both interval and phase must be non-negative and are truncated to the nearest
     *  second before any calculations.
     *  For example, an interval of 1 hour with phase of zero would match every hour,
     *  on the hour. The same interval but a phase of 19 minutes would match every
     *  xx:19:00. An interval of 28 days with phase zero would match
     *  2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
     *  days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
     */
    IntervalSpec: {
      interval?: string;
      phase?: string;
    };
    ListArchivedWorkflowExecutionsResponse: {
      executions?: components['schemas']['WorkflowExecutionInfo'][];
      /** Format: bytes */
      nextPageToken?: string;
    };
    ListBatchOperationsResponse: {
      /** @description BatchOperationInfo contains the basic info about batch operation */
      operationInfo?: components['schemas']['BatchOperationInfo'][];
      /** Format: bytes */
      nextPageToken?: string;
    };
    ListNamespacesResponse: {
      namespaces?: components['schemas']['DescribeNamespaceResponse'][];
      /** Format: bytes */
      nextPageToken?: string;
    };
    ListNexusEndpointsResponse: {
      /**
       * Format: bytes
       * @description Token for getting the next page.
       */
      nextPageToken?: string;
      endpoints?: components['schemas']['Endpoint'][];
    };
    ListScheduleMatchingTimesResponse: {
      startTime?: string[];
    };
    ListSchedulesResponse: {
      schedules?: components['schemas']['ScheduleListEntry'][];
      /** Format: bytes */
      nextPageToken?: string;
    };
    ListSearchAttributesResponse: {
      /** @description Mapping between custom (user-registered) search attribute name to its IndexedValueType. */
      customAttributes?: {
        [key: string]:
          | 'INDEXED_VALUE_TYPE_UNSPECIFIED'
          | 'INDEXED_VALUE_TYPE_TEXT'
          | 'INDEXED_VALUE_TYPE_KEYWORD'
          | 'INDEXED_VALUE_TYPE_INT'
          | 'INDEXED_VALUE_TYPE_DOUBLE'
          | 'INDEXED_VALUE_TYPE_BOOL'
          | 'INDEXED_VALUE_TYPE_DATETIME'
          | 'INDEXED_VALUE_TYPE_KEYWORD_LIST';
      };
      /** @description Mapping between system (predefined) search attribute name to its IndexedValueType. */
      systemAttributes?: {
        [key: string]:
          | 'INDEXED_VALUE_TYPE_UNSPECIFIED'
          | 'INDEXED_VALUE_TYPE_TEXT'
          | 'INDEXED_VALUE_TYPE_KEYWORD'
          | 'INDEXED_VALUE_TYPE_INT'
          | 'INDEXED_VALUE_TYPE_DOUBLE'
          | 'INDEXED_VALUE_TYPE_BOOL'
          | 'INDEXED_VALUE_TYPE_DATETIME'
          | 'INDEXED_VALUE_TYPE_KEYWORD_LIST';
      };
      /** @description Mapping from the attribute name to the visibility storage native type. */
      storageSchema?: {
        [key: string]: string;
      };
    };
    ListWorkflowExecutionsResponse: {
      executions?: components['schemas']['WorkflowExecutionInfo'][];
      /** Format: bytes */
      nextPageToken?: string;
    };
    MarkerRecordedEventAttributes: {
      /** @description Workers use this to identify the "types" of various markers. Ex: Local activity, side effect. */
      markerName?: string;
      /** @description Serialized information recorded in the marker */
      details?: {
        [key: string]: components['schemas']['Payloads'];
      };
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      header?: components['schemas']['Header'];
      /** @description Some uses of markers, like a local activity, could "fail". If they did that is recorded here. */
      failure?: components['schemas']['Failure'];
    };
    /** @description A user-defined set of *unindexed* fields that are exposed when listing/searching workflows */
    Memo: {
      fields?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    /**
     * @description (-- api-linter: core::0146::any=disabled
     *      aip.dev/not-precedent: We want runtime extensibility for the body field --)
     */
    Message: {
      /** @description An ID for this specific message. */
      id?: string;
      /**
       * @description Identifies the specific instance of a protocol to which this message
       *  belongs.
       */
      protocolInstanceId?: string;
      eventId?: string;
      commandIndex?: string;
      /**
       * @description The opaque data carried by this message. The protocol type can be
       *  extracted from the package name of the message carried inside the Any.
       */
      body?: components['schemas']['GoogleProtobufAny'];
    };
    /** @description Metadata about a workflow execution update. */
    Meta: {
      /** @description An ID with workflow-scoped uniqueness for this update */
      updateId?: string;
      /** @description A string identifying the agent that requested this update. */
      identity?: string;
    };
    /** @description Metadata relevant for metering purposes */
    MeteringMetadata: {
      /**
       * Format: uint32
       * @description Count of local activities which have begun an execution attempt during this workflow task,
       *  and whose first attempt occurred in some previous task. This is used for metering
       *  purposes, and does not affect workflow state.
       *
       *  (-- api-linter: core::0141::forbidden-types=disabled
       *      aip.dev/not-precedent: Negative values make no sense to represent. --)
       */
      nonfirstLocalActivityExecutionAttempts?: number;
    };
    NamespaceConfig: {
      workflowExecutionRetentionTtl?: string;
      badBinaries?: components['schemas']['BadBinaries'];
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      historyArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      historyArchivalUri?: string;
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      visibilityArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      visibilityArchivalUri?: string;
      /** @description Map from field name to alias. */
      customSearchAttributeAliases?: {
        [key: string]: string;
      };
    };
    NamespaceInfo: {
      name?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'NAMESPACE_STATE_UNSPECIFIED'
        | 'NAMESPACE_STATE_REGISTERED'
        | 'NAMESPACE_STATE_DEPRECATED'
        | 'NAMESPACE_STATE_DELETED';
      description?: string;
      ownerEmail?: string;
      /** @description A key-value map for any customized purpose. */
      data?: {
        [key: string]: string;
      };
      id?: string;
      /** @description All capabilities the namespace supports. */
      capabilities?: components['schemas']['NamespaceInfo_Capabilities'];
      /**
       * @description Whether scheduled workflows are supported on this namespace. This is only needed
       *  temporarily while the feature is experimental, so we can give it a high tag.
       */
      supportsSchedules?: boolean;
    };
    /** @description Namespace capability details. Should contain what features are enabled in a namespace. */
    NamespaceInfo_Capabilities: {
      /** @description True if the namespace supports eager workflow start. */
      eagerWorkflowStart?: boolean;
      /** @description True if the namespace supports sync update */
      syncUpdate?: boolean;
      /** @description True if the namespace supports async update */
      asyncUpdate?: boolean;
    };
    NamespaceReplicationConfig: {
      activeClusterName?: string;
      clusters?: components['schemas']['ClusterReplicationConfig'][];
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'REPLICATION_STATE_UNSPECIFIED'
        | 'REPLICATION_STATE_NORMAL'
        | 'REPLICATION_STATE_HANDOVER';
    };
    /**
     * @description NewWorkflowExecutionInfo is a shared message that encapsulates all the
     *  required arguments to starting a workflow in different contexts.
     */
    NewWorkflowExecutionInfo: {
      workflowId?: string;
      workflowType?: components['schemas']['WorkflowType'];
      taskQueue?: components['schemas']['TaskQueue'];
      /** @description Serialized arguments to the workflow. */
      input?: components['schemas']['Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /**
       * Format: enum
       * @description Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       * @enum {string}
       */
      workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /** @description The retry policy for the workflow. Will never exceed `workflow_execution_timeout`. */
      retryPolicy?: components['schemas']['RetryPolicy'];
      /** @description See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      header?: components['schemas']['Header'];
    };
    NexusOperationCancelRequestedEventAttributes: {
      /** @description The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to. */
      scheduledEventId?: string;
      /**
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *  with.
       */
      workflowTaskCompletedEventId?: string;
    };
    /** @description Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow. */
    NexusOperationCanceledEventAttributes: {
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      scheduledEventId?: string;
      /** @description Cancellation details. */
      failure?: components['schemas']['Failure'];
    };
    /** @description NexusOperationCancellationInfo contains the state of a nexus operation cancellation. */
    NexusOperationCancellationInfo: {
      /**
       * Format: date-time
       * @description The time when cancellation was requested.
       */
      requestedTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_FAILED'
        | 'NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT';
      /**
       * Format: int32
       * @description The number of attempts made to deliver the cancel operation request.
       *  This number represents a minimum bound since the attempt is incremented after the request completes.
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      lastAttemptCompleteTime?: string;
      /** @description The last attempt's failure, if any. */
      lastAttemptFailure?: components['schemas']['Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      nextAttemptScheduleTime?: string;
    };
    /** @description Nexus operation completed successfully. */
    NexusOperationCompletedEventAttributes: {
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      scheduledEventId?: string;
      /**
       * @description Serialized result of the Nexus operation. The response of the Nexus handler.
       *  Delivered either via a completion callback or as a response to a synchronous operation.
       */
      result?: components['schemas']['Payload'];
    };
    /** @description Nexus operation failed. */
    NexusOperationFailedEventAttributes: {
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      scheduledEventId?: string;
      /** @description Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo. */
      failure?: components['schemas']['Failure'];
    };
    NexusOperationFailureInfo: {
      /** @description The NexusOperationScheduled event ID. */
      scheduledEventId?: string;
      /** @description Endpoint name. */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      /** @description Operation ID - may be empty if the operation completed synchronously. */
      operationId?: string;
    };
    /** @description Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command. */
    NexusOperationScheduledEventAttributes: {
      /** @description Endpoint name, must exist in the endpoint registry. */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      /**
       * @description Input for the operation. The server converts this into Nexus request content and the appropriate content headers
       *  internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
       *  content is transformed back to the original Payload stored in this event.
       */
      input?: components['schemas']['Payload'];
      /**
       * @description Schedule-to-close timeout for this operation.
       *  Indicates how long the caller is willing to wait for operation completion.
       *  Calls are retried internally by the server.
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      scheduleToCloseTimeout?: string;
      /**
       * @description Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal
       *  activities and child workflows, these are transmitted to Nexus operations that may be external and are not
       *  traditional payloads.
       */
      nexusHeader?: {
        [key: string]: string;
      };
      /** @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with. */
      workflowTaskCompletedEventId?: string;
      /**
       * @description A unique ID generated by the history service upon creation of this event.
       *  The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key.
       */
      requestId?: string;
    };
    /**
     * @description Event marking an asynchronous operation was started by the responding Nexus handler.
     *  If the operation completes synchronously, this event is not generated.
     *  In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate
     *  this event upon receiving the operation completion via callback.
     */
    NexusOperationStartedEventAttributes: {
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to. */
      scheduledEventId?: string;
      /**
       * @description The operation ID returned by the Nexus handler in the response to the StartOperation request.
       *  This ID is used when canceling the operation.
       */
      operationId?: string;
    };
    /** @description Nexus operation timed out. */
    NexusOperationTimedOutEventAttributes: {
      /** @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation. */
      scheduledEventId?: string;
      /** @description Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo. */
      failure?: components['schemas']['Failure'];
    };
    /** @description The outcome of a workflow update - success or failure. */
    Outcome: {
      success?: components['schemas']['Payloads'];
      failure?: components['schemas']['Failure'];
    };
    PatchScheduleRequest: {
      /** @description The namespace of the schedule to patch. */
      namespace?: string;
      /** @description The id of the schedule to patch. */
      scheduleId?: string;
      patch?: components['schemas']['SchedulePatch'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description A unique identifier for this update request for idempotence. Typically UUIDv4. */
      requestId?: string;
    };
    PatchScheduleResponse: Record<string, never>;
    /**
     * @description Represents some binary (byte array) data (ex: activity input parameters or workflow result) with
     *  metadata which describes this binary data (format, encoding, encryption, etc). Serialization
     *  of the data may be user-defined.
     */
    Payload: unknown;
    /** @description See `Payload` */
    Payloads: {
      payloads?: components['schemas']['Payload'][];
    };
    PendingActivityInfo: {
      activityId?: string;
      activityType?: components['schemas']['ActivityType'];
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'PENDING_ACTIVITY_STATE_UNSPECIFIED'
        | 'PENDING_ACTIVITY_STATE_SCHEDULED'
        | 'PENDING_ACTIVITY_STATE_STARTED'
        | 'PENDING_ACTIVITY_STATE_CANCEL_REQUESTED';
      heartbeatDetails?: components['schemas']['Payloads'];
      /** Format: date-time */
      lastHeartbeatTime?: string;
      /** Format: date-time */
      lastStartedTime?: string;
      /** Format: int32 */
      attempt?: number;
      /** Format: int32 */
      maximumAttempts?: number;
      /** Format: date-time */
      scheduledTime?: string;
      /** Format: date-time */
      expirationTime?: string;
      lastFailure?: components['schemas']['Failure'];
      lastWorkerIdentity?: string;
      /**
       * @description This means the activity is independently versioned and not bound to the build ID of its workflow.
       *  The activity will use the build id in this field instead.
       *  If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
       *  rules.
       */
      lastIndependentlyAssignedBuildId?: string;
      /** @description The version stamp of the worker to whom this activity was most recently dispatched */
      lastWorkerVersionStamp?: components['schemas']['WorkerVersionStamp'];
    };
    PendingChildExecutionInfo: {
      workflowId?: string;
      runId?: string;
      workflowTypeName?: string;
      initiatedId?: string;
      /**
       * Format: enum
       * @description Default: PARENT_CLOSE_POLICY_TERMINATE.
       * @enum {string}
       */
      parentClosePolicy?:
        | 'PARENT_CLOSE_POLICY_UNSPECIFIED'
        | 'PARENT_CLOSE_POLICY_TERMINATE'
        | 'PARENT_CLOSE_POLICY_ABANDON'
        | 'PARENT_CLOSE_POLICY_REQUEST_CANCEL';
    };
    /** @description PendingNexusOperationInfo contains the state of a pending Nexus operation. */
    PendingNexusOperationInfo: {
      /**
       * @description Endpoint name.
       *  Resolved to a URL via the cluster's endpoint registry.
       */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      /** @description Operation ID. Only set for asynchronous operations after a successful StartOperation call. */
      operationId?: string;
      /**
       * @description Schedule-to-close timeout for this operation.
       *  This is the only timeout settable by a workflow.
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      scheduleToCloseTimeout?: string;
      /**
       * Format: date-time
       * @description The time when the operation was scheduled.
       */
      scheduledTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED'
        | 'PENDING_NEXUS_OPERATION_STATE_SCHEDULED'
        | 'PENDING_NEXUS_OPERATION_STATE_BACKING_OFF'
        | 'PENDING_NEXUS_OPERATION_STATE_STARTED';
      /**
       * Format: int32
       * @description The number of attempts made to deliver the start operation request.
       *  This number represents a minimum bound since the attempt is incremented after the request completes.
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      lastAttemptCompleteTime?: string;
      /** @description The last attempt's failure, if any. */
      lastAttemptFailure?: components['schemas']['Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      nextAttemptScheduleTime?: string;
      cancellationInfo?: components['schemas']['NexusOperationCancellationInfo'];
    };
    PendingWorkflowTaskInfo: {
      /**
       * Format: enum
       * @enum {string}
       */
      state?:
        | 'PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED'
        | 'PENDING_WORKFLOW_TASK_STATE_SCHEDULED'
        | 'PENDING_WORKFLOW_TASK_STATE_STARTED';
      /** Format: date-time */
      scheduledTime?: string;
      /**
       * Format: date-time
       * @description original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
       *  Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
       *  In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
       *  some threshold, the workflow task will be forced timeout.
       */
      originalScheduledTime?: string;
      /** Format: date-time */
      startedTime?: string;
      /** Format: int32 */
      attempt?: number;
    };
    PollWorkflowTaskQueueResponse: {
      /**
       * Format: bytes
       * @description A unique identifier for this task
       */
      taskToken?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      workflowType?: components['schemas']['WorkflowType'];
      /**
       * @description The last workflow task started event which was processed by some worker for this execution.
       *  Will be zero if no task has ever started.
       */
      previousStartedEventId?: string;
      /**
       * @description The id of the most recent workflow task started event, which will have been generated as a
       *  result of this poll request being served. Will be zero if the task
       *  does not contain any events which would advance history (no new WFT started).
       *  Currently this can happen for queries.
       */
      startedEventId?: string;
      /**
       * Format: int32
       * @description Starting at 1, the number of attempts to complete this task by any worker.
       */
      attempt?: number;
      /**
       * @description A hint that there are more tasks already present in this task queue. Can be used to
       *  prioritize draining a sticky queue before polling from a normal queue.
       */
      backlogCountHint?: string;
      /**
       * @description The history for this workflow, which will either be complete or partial. Partial histories
       *  are sent to workers who have signaled that they are using a sticky queue when completing
       *  a workflow task.
       */
      history?: components['schemas']['History'];
      /**
       * Format: bytes
       * @description Will be set if there are more history events than were included in this response. Such events
       *  should be fetched via `GetWorkflowExecutionHistory`.
       */
      nextPageToken?: string;
      /**
       * @description Legacy queries appear in this field. The query must be responded to via
       *  `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
       *  closed workflows) then the `history` field will be populated with the entire history. It
       *  may also be populated if this task originates on a non-sticky queue.
       */
      query?: components['schemas']['WorkflowQuery'];
      /**
       * @description The task queue this task originated from, which will always be the original non-sticky name
       *  for the queue, even if this response came from polling a sticky queue.
       */
      workflowExecutionTaskQueue?: components['schemas']['TaskQueue'];
      /**
       * Format: date-time
       * @description When this task was scheduled by the server
       */
      scheduledTime?: string;
      /**
       * Format: date-time
       * @description When the current workflow task started event was generated, meaning the current attempt.
       */
      startedTime?: string;
      /**
       * @description Queries that should be executed after applying the history in this task. Responses should be
       *  attached to `RespondWorkflowTaskCompletedRequest::query_results`
       */
      queries?: {
        [key: string]: components['schemas']['WorkflowQuery'];
      };
      /** @description Protocol messages piggybacking on a WFT as a transport */
      messages?: components['schemas']['Message'][];
    };
    PollerInfo: {
      /** Format: date-time */
      lastAccessTime?: string;
      identity?: string;
      /** Format: double */
      ratePerSecond?: number;
      /**
       * @description If a worker has opted into the worker versioning feature while polling, its capabilities will
       *  appear here.
       */
      workerVersionCapabilities?: components['schemas']['WorkerVersionCapabilities'];
    };
    QueryRejected: {
      /**
       * Format: enum
       * @enum {string}
       */
      status?:
        | 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED'
        | 'WORKFLOW_EXECUTION_STATUS_RUNNING'
        | 'WORKFLOW_EXECUTION_STATUS_COMPLETED'
        | 'WORKFLOW_EXECUTION_STATUS_FAILED'
        | 'WORKFLOW_EXECUTION_STATUS_CANCELED'
        | 'WORKFLOW_EXECUTION_STATUS_TERMINATED'
        | 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW'
        | 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT';
    };
    QueryWorkflowRequest: {
      namespace?: string;
      execution?: components['schemas']['WorkflowExecution'];
      query?: components['schemas']['WorkflowQuery'];
      /**
       * Format: enum
       * @description QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
       *  Default: QUERY_REJECT_CONDITION_NONE.
       * @enum {string}
       */
      queryRejectCondition?:
        | 'QUERY_REJECT_CONDITION_UNSPECIFIED'
        | 'QUERY_REJECT_CONDITION_NONE'
        | 'QUERY_REJECT_CONDITION_NOT_OPEN'
        | 'QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY';
    };
    QueryWorkflowResponse: {
      queryResult?: components['schemas']['Payloads'];
      queryRejected?: components['schemas']['QueryRejected'];
    };
    RampByPercentage: {
      /**
       * Format: float
       * @description Acceptable range is [0,100).
       */
      rampPercentage?: number;
    };
    /**
     * @description Range represents a set of integer values, used to match fields of a calendar
     *  time in StructuredCalendarSpec. If end < start, then end is interpreted as
     *  equal to start. This means you can use a Range with start set to a value, and
     *  end and step unset (defaulting to 0) to represent a single value.
     */
    Range: {
      /**
       * Format: int32
       * @description Start of range (inclusive).
       */
      start?: number;
      /**
       * Format: int32
       * @description End of range (inclusive).
       */
      end?: number;
      /**
       * Format: int32
       * @description Step (optional, default 1).
       */
      step?: number;
    };
    RecordActivityTaskHeartbeatByIdRequest: {
      /** @description Namespace of the workflow which scheduled this activity */
      namespace?: string;
      /** @description Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** @description Id of the activity we're heartbeating */
      activityId?: string;
      /** @description Arbitrary data, of which the most recent call is kept, to store for this activity */
      details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
    };
    RecordActivityTaskHeartbeatByIdResponse: {
      /**
       * @description Will be set to true if the activity has been asked to cancel itself. The SDK should then
       *  notify the activity of cancellation if it is still running.
       */
      cancelRequested?: boolean;
    };
    RecordActivityTaskHeartbeatRequest: {
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      taskToken?: string;
      /** @description Arbitrary data, of which the most recent call is kept, to store for this activity */
      details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
      namespace?: string;
    };
    RecordActivityTaskHeartbeatResponse: {
      /**
       * @description Will be set to true if the activity has been asked to cancel itself. The SDK should then
       *  notify the activity of cancellation if it is still running.
       */
      cancelRequested?: boolean;
    };
    RegisterNamespaceRequest: {
      namespace?: string;
      description?: string;
      ownerEmail?: string;
      workflowExecutionRetentionPeriod?: string;
      clusters?: components['schemas']['ClusterReplicationConfig'][];
      activeClusterName?: string;
      /** @description A key-value map for any customized purpose. */
      data?: {
        [key: string]: string;
      };
      securityToken?: string;
      isGlobalNamespace?: boolean;
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      historyArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      historyArchivalUri?: string;
      /**
       * Format: enum
       * @description If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
       * @enum {string}
       */
      visibilityArchivalState?:
        | 'ARCHIVAL_STATE_UNSPECIFIED'
        | 'ARCHIVAL_STATE_DISABLED'
        | 'ARCHIVAL_STATE_ENABLED';
      visibilityArchivalUri?: string;
    };
    RegisterNamespaceResponse: Record<string, never>;
    /** @description ReleaseInfo contains information about specific version of temporal. */
    ReleaseInfo: {
      version?: string;
      /** Format: date-time */
      releaseTime?: string;
      notes?: string;
    };
    /** @description The client request that triggers a workflow execution update */
    Request: {
      meta?: components['schemas']['Meta'];
      input?: components['schemas']['Input'];
    };
    RequestCancelExternalWorkflowExecutionFailedEventAttributes: {
      /**
       * Format: enum
       * @enum {string}
       */
      cause?:
        | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
        | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND'
        | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND';
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * @description Namespace of the workflow which failed to cancel.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure
       *  corresponds to
       */
      initiatedEventId?: string;
      /** @description Deprecated */
      control?: string;
    };
    RequestCancelExternalWorkflowExecutionInitiatedEventAttributes: {
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * @description The namespace the workflow to be cancelled lives in.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description Deprecated */
      control?: string;
      /**
       * @description Workers are expected to set this to true if the workflow they are requesting to cancel is
       *  a child of the workflow which issued the request
       */
      childWorkflowOnly?: boolean;
      /** @description Reason for requesting the cancellation */
      reason?: string;
    };
    RequestCancelWorkflowExecutionRequest: {
      namespace?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description The identity of the worker/client */
      identity?: string;
      /** @description Used to de-dupe cancellation requests */
      requestId?: string;
      /**
       * @description If set, this call will error if the most recent (if no run id is set on
       *  `workflow_execution`), or specified (if it is) workflow execution is not part of the same
       *  execution chain as this id.
       */
      firstExecutionRunId?: string;
      /** @description Reason for requesting the cancellation */
      reason?: string;
    };
    RequestCancelWorkflowExecutionResponse: Record<string, never>;
    /**
     * @description Describes where and how to reset a workflow, used for batch reset currently
     *  and may be used for single-workflow reset later.
     */
    ResetOptions: {
      /**
       * @description The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
       *  `WORKFLOW_TASK_STARTED` event to reset to.
       *  Note that this option doesn't make sense when used as part of a batch request.
       */
      workflowTaskId?: string;
      /**
       * @description Resets to the first workflow task processed by this build id.
       *  If the workflow was not processed by the build id, or the workflow task can't be
       *  determined, no reset will be performed.
       *  Note that by default, this reset is allowed to be to a prior run in a chain of
       *  continue-as-new.
       */
      buildId?: string;
      /**
       * Format: enum
       * @description Event types to be reapplied (deprecated)
       *  Default: RESET_REAPPLY_TYPE_SIGNAL
       * @enum {string}
       */
      resetReapplyType?:
        | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_TYPE_SIGNAL'
        | 'RESET_REAPPLY_TYPE_NONE'
        | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
      /**
       * @description If true, limit the reset to only within the current run. (Applies to build_id targets and
       *  possibly others in the future.)
       */
      currentRunOnly?: boolean;
      /** @description Event types not to be reapplied */
      resetReapplyExcludeTypes?: (
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UPDATE'
      )[];
    };
    /**
     * @description ResetPointInfo records the workflow event id that is the first one processed by a given
     *  build id or binary checksum. A new reset point will be created if either build id or binary
     *  checksum changes (although in general only one or the other will be used at a time).
     */
    ResetPointInfo: {
      /** @description Worker build id. */
      buildId?: string;
      /** @description A worker binary version identifier (deprecated). */
      binaryChecksum?: string;
      /** @description The first run ID in the execution chain that was touched by this worker build. */
      runId?: string;
      /** @description Event ID of the first WorkflowTaskCompleted event processed by this worker build. */
      firstWorkflowTaskCompletedId?: string;
      /** Format: date-time */
      createTime?: string;
      /**
       * Format: date-time
       * @description (-- api-linter: core::0214::resource-expiry=disabled
       *      aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
       *  The time that the run is deleted due to retention.
       */
      expireTime?: string;
      /** @description false if the reset point has pending childWFs/reqCancels/signalExternals. */
      resettable?: boolean;
    };
    ResetPoints: {
      points?: components['schemas']['ResetPointInfo'][];
    };
    ResetWorkflowExecutionRequest: {
      namespace?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      reason?: string;
      /**
       * @description The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
       *  `WORKFLOW_TASK_STARTED` event to reset to.
       */
      workflowTaskFinishEventId?: string;
      /** @description Used to de-dupe reset requests */
      requestId?: string;
      /**
       * Format: enum
       * @description Event types to be reapplied (deprecated)
       *  Default: RESET_REAPPLY_TYPE_SIGNAL
       * @enum {string}
       */
      resetReapplyType?:
        | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_TYPE_SIGNAL'
        | 'RESET_REAPPLY_TYPE_NONE'
        | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
      /** @description Event types not to be reapplied */
      resetReapplyExcludeTypes?: (
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL'
        | 'RESET_REAPPLY_EXCLUDE_TYPE_UPDATE'
      )[];
    };
    ResetWorkflowExecutionResponse: {
      runId?: string;
    };
    ResetWorkflowFailureInfo: {
      lastHeartbeatDetails?: components['schemas']['Payloads'];
    };
    RespondActivityTaskCanceledByIdRequest: {
      /** @description Namespace of the workflow which scheduled this activity */
      namespace?: string;
      /** @description Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** @description Id of the activity to confirm is cancelled */
      activityId?: string;
      /** @description Serialized additional information to attach to the cancellation */
      details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
    };
    RespondActivityTaskCanceledByIdResponse: Record<string, never>;
    RespondActivityTaskCanceledRequest: {
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      taskToken?: string;
      /** @description Serialized additional information to attach to the cancellation */
      details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
      namespace?: string;
      /**
       * @description Version info of the worker who processed this task. This message's `build_id` field should
       *  always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
       *  field to true. See message docstrings for more.
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    RespondActivityTaskCanceledResponse: Record<string, never>;
    RespondActivityTaskCompletedByIdRequest: {
      /** @description Namespace of the workflow which scheduled this activity */
      namespace?: string;
      /** @description Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** @description Id of the activity to complete */
      activityId?: string;
      /** @description The serialized result of activity execution */
      result?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
    };
    RespondActivityTaskCompletedByIdResponse: Record<string, never>;
    RespondActivityTaskCompletedRequest: {
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      taskToken?: string;
      /** @description The result of successfully executing the activity */
      result?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
      namespace?: string;
      /**
       * @description Version info of the worker who processed this task. This message's `build_id` field should
       *  always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
       *  field to true. See message docstrings for more.
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    RespondActivityTaskCompletedResponse: Record<string, never>;
    RespondActivityTaskFailedByIdRequest: {
      /** @description Namespace of the workflow which scheduled this activity */
      namespace?: string;
      /** @description Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** @description Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** @description Id of the activity to fail */
      activityId?: string;
      /** @description Detailed failure information */
      failure?: components['schemas']['Failure'];
      /** @description The identity of the worker/client */
      identity?: string;
      /** @description Additional details to be stored as last activity heartbeat */
      lastHeartbeatDetails?: components['schemas']['Payloads'];
    };
    RespondActivityTaskFailedByIdResponse: {
      /**
       * @description Server validation failures could include
       *  last_heartbeat_details payload is too large, request failure is too large
       */
      failures?: components['schemas']['Failure'][];
    };
    RespondActivityTaskFailedRequest: {
      /**
       * Format: bytes
       * @description The task token as received in `PollActivityTaskQueueResponse`
       */
      taskToken?: string;
      /** @description Detailed failure information */
      failure?: components['schemas']['Failure'];
      /** @description The identity of the worker/client */
      identity?: string;
      namespace?: string;
      /** @description Additional details to be stored as last activity heartbeat */
      lastHeartbeatDetails?: components['schemas']['Payloads'];
      /**
       * @description Version info of the worker who processed this task. This message's `build_id` field should
       *  always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
       *  field to true. See message docstrings for more.
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    RespondActivityTaskFailedResponse: {
      /**
       * @description Server validation failures could include
       *  last_heartbeat_details payload is too large, request failure is too large
       */
      failures?: components['schemas']['Failure'][];
    };
    /** @description How retries ought to be handled, usable by both workflows and activities */
    RetryPolicy: {
      /** @description Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries. */
      initialInterval?: string;
      /**
       * Format: double
       * @description Coefficient used to calculate the next retry interval.
       *  The next retry interval is previous interval multiplied by the coefficient.
       *  Must be 1 or larger.
       */
      backoffCoefficient?: number;
      /**
       * @description Maximum interval between retries. Exponential backoff leads to interval increase.
       *  This value is the cap of the increase. Default is 100x of the initial interval.
       */
      maximumInterval?: string;
      /**
       * Format: int32
       * @description Maximum number of attempts. When exceeded the retries stop even if not expired yet.
       *  1 disables retries. 0 means unlimited (up to the timeouts)
       */
      maximumAttempts?: number;
      /**
       * @description Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
       *  this is not a substring match, the error *type* (not message) must match exactly.
       */
      nonRetryableErrorTypes?: string[];
    };
    Schedule: {
      spec?: components['schemas']['ScheduleSpec'];
      action?: components['schemas']['ScheduleAction'];
      policies?: components['schemas']['SchedulePolicies'];
      state?: components['schemas']['ScheduleState'];
    };
    ScheduleAction: {
      /**
       * @description All fields of NewWorkflowExecutionInfo are valid except for:
       *  - workflow_id_reuse_policy
       *  - cron_schedule
       *  The workflow id of the started workflow may not match this exactly,
       *  it may have a timestamp appended for uniqueness.
       */
      startWorkflow?: components['schemas']['NewWorkflowExecutionInfo'];
    };
    ScheduleActionResult: {
      /**
       * Format: date-time
       * @description Time that the action was taken (according to the schedule, including jitter).
       */
      scheduleTime?: string;
      /**
       * Format: date-time
       * @description Time that the action was taken (real time).
       */
      actualTime?: string;
      /** @description If action was start_workflow: */
      startWorkflowResult?: components['schemas']['WorkflowExecution'];
    };
    ScheduleInfo: {
      /** @description Number of actions taken so far. */
      actionCount?: string;
      /** @description Number of times a scheduled action was skipped due to missing the catchup window. */
      missedCatchupWindow?: string;
      /** @description Number of skipped actions due to overlap. */
      overlapSkipped?: string;
      /** @description Number of dropped actions due to buffer limit. */
      bufferDropped?: string;
      /**
       * @description Number of actions in the buffer. The buffer holds the actions that cannot
       *  be immediately triggered (due to the overlap policy). These actions can be a result of
       *  the normal schedule or a backfill.
       */
      bufferSize?: string;
      /**
       * @description Currently-running workflows started by this schedule. (There might be
       *  more than one if the overlap policy allows overlaps.)
       *  Note that the run_ids in here are the original execution run ids as
       *  started by the schedule. If the workflows retried, did continue-as-new,
       *  or were reset, they might still be running but with a different run_id.
       */
      runningWorkflows?: components['schemas']['WorkflowExecution'][];
      /** @description Most recent ten actual action times (including manual triggers). */
      recentActions?: components['schemas']['ScheduleActionResult'][];
      /** @description Next ten scheduled action times. */
      futureActionTimes?: string[];
      /**
       * Format: date-time
       * @description Timestamps of schedule creation and last update.
       */
      createTime?: string;
      /** Format: date-time */
      updateTime?: string;
      invalidScheduleError?: string;
    };
    /** @description ScheduleListEntry is returned by ListSchedules. */
    ScheduleListEntry: {
      scheduleId?: string;
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      info?: components['schemas']['ScheduleListInfo'];
    };
    /**
     * @description ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
     *  that's returned in ListSchedules.
     */
    ScheduleListInfo: {
      /**
       * @description From spec:
       *  Some fields are dropped from this copy of spec: timezone_data
       */
      spec?: components['schemas']['ScheduleSpec'];
      /**
       * @description From action:
       *  Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
       *  well with JSON. If action is start_workflow, this is set:
       */
      workflowType?: components['schemas']['WorkflowType'];
      /** @description From state: */
      notes?: string;
      paused?: boolean;
      /** @description From info (maybe fewer entries): */
      recentActions?: components['schemas']['ScheduleActionResult'][];
      futureActionTimes?: string[];
    };
    SchedulePatch: {
      /** @description If set, trigger one action immediately. */
      triggerImmediately?: components['schemas']['TriggerImmediatelyRequest'];
      /**
       * @description If set, runs though the specified time period(s) and takes actions as if that time
       *  passed by right now, all at once. The overlap policy can be overridden for the
       *  scope of the backfill.
       */
      backfillRequest?: components['schemas']['BackfillRequest'][];
      /**
       * @description If set, change the state to paused or unpaused (respectively) and set the
       *  notes field to the value of the string.
       */
      pause?: string;
      unpause?: string;
    };
    SchedulePolicies: {
      /**
       * Format: enum
       * @description Policy for overlaps.
       *  Note that this can be changed after a schedule has taken some actions,
       *  and some changes might produce unintuitive results. In general, the later
       *  policy overrides the earlier policy.
       * @enum {string}
       */
      overlapPolicy?:
        | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
        | 'SCHEDULE_OVERLAP_POLICY_SKIP'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
        | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
      /**
       * @description Policy for catchups:
       *  If the Temporal server misses an action due to one or more components
       *  being down, and comes back up, the action will be run if the scheduled
       *  time is within this window from the current time.
       *  This value defaults to one year, and can't be less than 10 seconds.
       */
      catchupWindow?: string;
      /**
       * @description If true, and a workflow run fails or times out, turn on "paused".
       *  This applies after retry policies: the full chain of retries must fail to
       *  trigger a pause here.
       */
      pauseOnFailure?: boolean;
      /**
       * @description If true, and the action would start a workflow, a timestamp will not be
       *  appended to the scheduled workflow id.
       */
      keepOriginalWorkflowId?: boolean;
    };
    /**
     * @description ScheduleSpec is a complete description of a set of absolute timestamps
     *  (possibly infinite) that an action should occur at. The meaning of a
     *  ScheduleSpec depends only on its contents and never changes, except that the
     *  definition of a time zone can change over time (most commonly, when daylight
     *  saving time policy changes for an area). To create a totally self-contained
     *  ScheduleSpec, use UTC or include timezone_data.
     *
     *  For input, you can provide zero or more of: structured_calendar, calendar,
     *  cron_string, interval, and exclude_structured_calendar, and all of them will
     *  be used (the schedule will take action at the union of all of their times,
     *  minus the ones that match exclude_structured_calendar).
     *
     *  On input, calendar and cron_string fields will be compiled into
     *  structured_calendar (and maybe interval and timezone_name), so if you
     *  Describe a schedule, you'll see only structured_calendar, interval, etc.
     *
     *  If a spec has no matching times after the current time, then the schedule
     *  will be subject to automatic deletion (after several days).
     */
    ScheduleSpec: {
      /** @description Calendar-based specifications of times. */
      structuredCalendar?: components['schemas']['StructuredCalendarSpec'][];
      /**
       * @description cron_string holds a traditional cron specification as a string. It
       *  accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
       *  same way as CalendarSpec.
       *  5 fields:         minute, hour, day_of_month, month, day_of_week
       *  6 fields:         minute, hour, day_of_month, month, day_of_week, year
       *  7 fields: second, minute, hour, day_of_month, month, day_of_week, year
       *  If year is not given, it defaults to *. If second is not given, it
       *  defaults to 0.
       *  Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
       *  accepted instead of the 5-7 time fields.
       *  Optionally, the string can be preceded by CRON_TZ=<timezone name> or
       *  TZ=<timezone name>, which will get copied to timezone_name. (There must
       *  not also be a timezone_name present.)
       *  Optionally "#" followed by a comment can appear at the end of the string.
       *  Note that the special case that some cron implementations have for
       *  treating day_of_month and day_of_week as "or" instead of "and" when both
       *  are set is not implemented.
       *  @every <interval>[/<phase>] is accepted and gets compiled into an
       *  IntervalSpec instead. <interval> and <phase> should be a decimal integer
       *  with a unit suffix s, m, h, or d.
       */
      cronString?: string[];
      /** @description Calendar-based specifications of times. */
      calendar?: components['schemas']['CalendarSpec'][];
      /** @description Interval-based specifications of times. */
      interval?: components['schemas']['IntervalSpec'][];
      /** @description Any timestamps matching any of exclude_* will be skipped. */
      excludeCalendar?: components['schemas']['CalendarSpec'][];
      excludeStructuredCalendar?: components['schemas']['StructuredCalendarSpec'][];
      /**
       * Format: date-time
       * @description If start_time is set, any timestamps before start_time will be skipped.
       *  (Together, start_time and end_time make an inclusive interval.)
       */
      startTime?: string;
      /**
       * Format: date-time
       * @description If end_time is set, any timestamps after end_time will be skipped.
       */
      endTime?: string;
      /**
       * @description All timestamps will be incremented by a random value from 0 to this
       *  amount of jitter. Default: 0
       */
      jitter?: string;
      /**
       * @description Time zone to interpret all calendar-based specs in.
       *
       *  If unset, defaults to UTC. We recommend using UTC for your application if
       *  at all possible, to avoid various surprising properties of time zones.
       *
       *  Time zones may be provided by name, corresponding to names in the IANA
       *  time zone database (see https://www.iana.org/time-zones). The definition
       *  will be loaded by the Temporal server from the environment it runs in.
       *
       *  If your application requires more control over the time zone definition
       *  used, it may pass in a complete definition in the form of a TZif file
       *  from the time zone database. If present, this will be used instead of
       *  loading anything from the environment. You are then responsible for
       *  updating timezone_data when the definition changes.
       *
       *  Calendar spec matching is based on literal matching of the clock time
       *  with no special handling of DST: if you write a calendar spec that fires
       *  at 2:30am and specify a time zone that follows DST, that action will not
       *  be triggered on the day that has no 2:30am. Similarly, an action that
       *  fires at 1:30am will be triggered twice on the day that has two 1:30s.
       *
       *  Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
       */
      timezoneName?: string;
      /** Format: bytes */
      timezoneData?: string;
    };
    ScheduleState: {
      /**
       * @description Informative human-readable message with contextual notes, e.g. the reason
       *  a schedule is paused. The system may overwrite this message on certain
       *  conditions, e.g. when pause-on-failure happens.
       */
      notes?: string;
      /** @description If true, do not take any actions based on the schedule spec. */
      paused?: boolean;
      /**
       * @description If limited_actions is true, decrement remaining_actions after each
       *  action, and do not take any more scheduled actions if remaining_actions
       *  is zero. Actions may still be taken by explicit request (i.e. trigger
       *  immediately or backfill). Skipped actions (due to overlap policy) do not
       *  count against remaining actions.
       *  If a schedule has no more remaining actions, then the schedule will be
       *  subject to automatic deletion (after several days).
       */
      limitedActions?: boolean;
      remainingActions?: string;
    };
    /**
     * @description A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
     *  The payload is not serialized in a user-defined way.
     */
    SearchAttributes: {
      indexedFields?: {
        [key: string]: components['schemas']['Payload'];
      };
    };
    ServerFailureInfo: {
      nonRetryable?: boolean;
    };
    SignalExternalWorkflowExecutionFailedEventAttributes: {
      /**
       * Format: enum
       * @enum {string}
       */
      cause?:
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND'
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND'
        | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED';
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * @description Namespace of the workflow which failed the signal.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      initiatedEventId?: string;
      /** @description Deprecated */
      control?: string;
    };
    SignalExternalWorkflowExecutionInitiatedEventAttributes: {
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * @description Namespace of the to-be-signalled workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description name/type of the signal to fire in the external workflow */
      signalName?: string;
      /** @description Serialized arguments to provide to the signal handler */
      input?: components['schemas']['Payloads'];
      /** @description Deprecated */
      control?: string;
      /**
       * @description Workers are expected to set this to true if the workflow they are requesting to cancel is
       *  a child of the workflow which issued the request
       */
      childWorkflowOnly?: boolean;
      header?: components['schemas']['Header'];
    };
    SignalWithStartWorkflowExecutionRequest: {
      namespace?: string;
      workflowId?: string;
      workflowType?: components['schemas']['WorkflowType'];
      /** @description The task queue to start this workflow on, if it will be started */
      taskQueue?: components['schemas']['TaskQueue'];
      /** @description Serialized arguments to the workflow. These are passed as arguments to the workflow function. */
      input?: components['schemas']['Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task */
      workflowTaskTimeout?: string;
      /** @description The identity of the worker/client */
      identity?: string;
      /** @description Used to de-dupe signal w/ start requests */
      requestId?: string;
      /**
       * Format: enum
       * @description Defines whether to allow re-using the workflow id from a previously *closed* workflow.
       *  The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       *
       *  See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
       * @enum {string}
       */
      workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /**
       * Format: enum
       * @description Defines how to resolve a workflow id conflict with a *running* workflow.
       *  The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
       *  Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
       *
       *  See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
       * @enum {string}
       */
      workflowIdConflictPolicy?:
        | 'WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_CONFLICT_POLICY_FAIL'
        | 'WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING'
        | 'WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING';
      /** @description The workflow author-defined name of the signal to send to the workflow */
      signalName?: string;
      /** @description Serialized value(s) to provide with the signal */
      signalInput?: components['schemas']['Payloads'];
      /** @description Deprecated */
      control?: string;
      /** @description Retry policy for the workflow */
      retryPolicy?: components['schemas']['RetryPolicy'];
      /** @description See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      header?: components['schemas']['Header'];
      /**
       * @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *  Note that the signal will be delivered with the first workflow task. If the workflow gets
       *  another SignalWithStartWorkflow before the delay and `skip_generate_workflow_task` is false
       *  or not set, a workflow task will be dispatched immediately and the rest of the delay period
       *  will be ignored, even if that request also had a delay. Signal via SignalWorkflowExecution
       *  will not unblock the workflow.
       */
      workflowStartDelay?: string;
      /** @description Indicates that a new workflow task should not be generated when this signal is received. */
      skipGenerateWorkflowTask?: boolean;
    };
    SignalWithStartWorkflowExecutionResponse: {
      /** @description The run id of the workflow that was started - or just signaled, if it was already running. */
      runId?: string;
      /** @description If true, a new workflow was started. */
      started?: boolean;
    };
    SignalWorkflowExecutionRequest: {
      namespace?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description The workflow author-defined name of the signal to send to the workflow */
      signalName?: string;
      /** @description Serialized value(s) to provide with the signal */
      input?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
      /** @description Used to de-dupe sent signals */
      requestId?: string;
      /** @description Deprecated */
      control?: string;
      /**
       * @description Headers that are passed with the signal to the processing workflow.
       *  These can include things like auth or tracing tokens.
       */
      header?: components['schemas']['Header'];
      /** @description Indicates that a new workflow task should not be generated when this signal is received. */
      skipGenerateWorkflowTask?: boolean;
    };
    SignalWorkflowExecutionResponse: Record<string, never>;
    StartBatchOperationRequest: {
      /** @description Namespace that contains the batch operation */
      namespace?: string;
      /**
       * @description Visibility query defines the the group of workflow to apply the batch operation
       *  This field and `executions` are mutually exclusive
       */
      visibilityQuery?: string;
      /** @description Job ID defines the unique ID for the batch job */
      jobId?: string;
      /** @description Reason to perform the batch operation */
      reason?: string;
      /**
       * @description Executions to apply the batch operation
       *  This field and `visibility_query` are mutually exclusive
       */
      executions?: components['schemas']['WorkflowExecution'][];
      /**
       * Format: float
       * @description Limit for the number of operations processed per second within this batch.
       *  Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
       *  overload and minimize potential delays in executing ongoing tasks for user workers.
       *  Note that when no explicit limit is provided, the server will operate according to its limit defined by the
       *  dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
       *  server's configured limit.
       */
      maxOperationsPerSecond?: number;
      terminationOperation?: components['schemas']['BatchOperationTermination'];
      signalOperation?: components['schemas']['BatchOperationSignal'];
      cancellationOperation?: components['schemas']['BatchOperationCancellation'];
      deletionOperation?: components['schemas']['BatchOperationDeletion'];
      resetOperation?: components['schemas']['BatchOperationReset'];
    };
    StartBatchOperationResponse: Record<string, never>;
    StartChildWorkflowExecutionFailedEventAttributes: {
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowId?: string;
      workflowType?: components['schemas']['WorkflowType'];
      /**
       * Format: enum
       * @enum {string}
       */
      cause?:
        | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
        | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS'
        | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND';
      /** @description Deprecated */
      control?: string;
      /** @description Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to */
      initiatedEventId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
    };
    StartChildWorkflowExecutionInitiatedEventAttributes: {
      /**
       * @description Namespace of the child workflow.
       *  SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
       */
      namespace?: string;
      namespaceId?: string;
      workflowId?: string;
      workflowType?: components['schemas']['WorkflowType'];
      taskQueue?: components['schemas']['TaskQueue'];
      input?: components['schemas']['Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /**
       * Format: enum
       * @description Default: PARENT_CLOSE_POLICY_TERMINATE.
       * @enum {string}
       */
      parentClosePolicy?:
        | 'PARENT_CLOSE_POLICY_UNSPECIFIED'
        | 'PARENT_CLOSE_POLICY_TERMINATE'
        | 'PARENT_CLOSE_POLICY_ABANDON'
        | 'PARENT_CLOSE_POLICY_REQUEST_CANCEL';
      /** @description Deprecated */
      control?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * Format: enum
       * @description Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       * @enum {string}
       */
      workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      retryPolicy?: components['schemas']['RetryPolicy'];
      /** @description If this child runs on a cron schedule, it will appear here */
      cronSchedule?: string;
      header?: components['schemas']['Header'];
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      /**
       * @description If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
       *  rules of the child's Task Queue will be used to independently assign a Build ID to it.
       */
      inheritBuildId?: boolean;
    };
    StartWorkflowExecutionRequest: {
      namespace?: string;
      workflowId?: string;
      workflowType?: components['schemas']['WorkflowType'];
      taskQueue?: components['schemas']['TaskQueue'];
      /** @description Serialized arguments to the workflow. These are passed as arguments to the workflow function. */
      input?: components['schemas']['Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /** @description The identity of the client who initiated this request */
      identity?: string;
      /** @description A unique identifier for this start request. Typically UUIDv4. */
      requestId?: string;
      /**
       * Format: enum
       * @description Defines whether to allow re-using the workflow id from a previously *closed* workflow.
       *  The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
       *
       *  See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
       * @enum {string}
       */
      workflowIdReusePolicy?:
        | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
        | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
        | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
      /**
       * Format: enum
       * @description Defines how to resolve a workflow id conflict with a *running* workflow.
       *  The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
       *
       *  See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
       * @enum {string}
       */
      workflowIdConflictPolicy?:
        | 'WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED'
        | 'WORKFLOW_ID_CONFLICT_POLICY_FAIL'
        | 'WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING'
        | 'WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING';
      /** @description The retry policy for the workflow. Will never exceed `workflow_execution_timeout`. */
      retryPolicy?: components['schemas']['RetryPolicy'];
      /** @description See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      header?: components['schemas']['Header'];
      /**
       * @description Request to get the first workflow task inline in the response bypassing matching service and worker polling.
       *  If set to `true` the caller is expected to have a worker available and capable of processing the task.
       *  The returned task will be marked as started and is expected to be completed by the specified
       *  `workflow_task_timeout`.
       */
      requestEagerExecution?: boolean;
      /**
       * @description These values will be available as ContinuedFailure and LastCompletionResult in the
       *  WorkflowExecutionStarted event and through SDKs. The are currently only used by the
       *  server itself (for the schedules feature) and are not intended to be exposed in
       *  StartWorkflowExecution.
       */
      continuedFailure?: components['schemas']['Failure'];
      lastCompletionResult?: components['schemas']['Payloads'];
      /**
       * @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *  If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
       *  of the delay will be ignored.
       */
      workflowStartDelay?: string;
      /**
       * @description Callbacks to be called by the server when this workflow reaches a terminal state.
       *  If the workflow continues-as-new, these callbacks will be carried over to the new execution.
       *  Callback addresses must be whitelisted in the server's dynamic configuration.
       */
      completionCallbacks?: components['schemas']['Callback'][];
    };
    StartWorkflowExecutionResponse: {
      /** @description The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING). */
      runId?: string;
      /** @description If true, a new workflow was started. */
      started?: boolean;
      /**
       * @description When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
       *  return the first workflow task to be eagerly executed.
       *  The caller is expected to have a worker available to process the task.
       */
      eagerWorkflowTask?: components['schemas']['PollWorkflowTaskQueueResponse'];
    };
    /** @description The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). */
    Status: {
      /**
       * Format: int32
       * @description The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
       */
      code?: number;
      /** @description A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client. */
      message?: string;
      /** @description A list of messages that carry the error details.  There is a common set of message types for APIs to use. */
      details?: components['schemas']['GoogleProtobufAny'][];
    };
    StopBatchOperationRequest: {
      /** @description Namespace that contains the batch operation */
      namespace?: string;
      /** @description Batch job id */
      jobId?: string;
      /** @description Reason to stop a batch operation */
      reason?: string;
      /** @description Identity of the operator */
      identity?: string;
    };
    StopBatchOperationResponse: Record<string, never>;
    /**
     * @description StructuredCalendarSpec describes an event specification relative to the
     *  calendar, in a form that's easy to work with programmatically. Each field can
     *  be one or more ranges.
     *  A timestamp matches if at least one range of each field matches the
     *  corresponding fields of the timestamp, except for year: if year is missing,
     *  that means all years match. For all fields besides year, at least one Range
     *  must be present to match anything.
     *  TODO: add relative-to-end-of-month
     *  TODO: add nth day-of-week in month
     */
    StructuredCalendarSpec: {
      /** @description Match seconds (0-59) */
      second?: components['schemas']['Range'][];
      /** @description Match minutes (0-59) */
      minute?: components['schemas']['Range'][];
      /** @description Match hours (0-23) */
      hour?: components['schemas']['Range'][];
      /**
       * @description Match days of the month (1-31)
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: standard name of field --)
       */
      dayOfMonth?: components['schemas']['Range'][];
      /** @description Match months (1-12) */
      month?: components['schemas']['Range'][];
      /** @description Match years. */
      year?: components['schemas']['Range'][];
      /** @description Match days of the week (0-6; 0 is Sunday). */
      dayOfWeek?: components['schemas']['Range'][];
      /** @description Free-form comment describing the intention of this spec. */
      comment?: string;
    };
    TaskIdBlock: {
      startId?: string;
      endId?: string;
    };
    /** @description See https://docs.temporal.io/docs/concepts/task-queues/ */
    TaskQueue: {
      name?: string;
      /**
       * Format: enum
       * @description Default: TASK_QUEUE_KIND_NORMAL.
       * @enum {string}
       */
      kind?:
        | 'TASK_QUEUE_KIND_UNSPECIFIED'
        | 'TASK_QUEUE_KIND_NORMAL'
        | 'TASK_QUEUE_KIND_STICKY';
      /**
       * @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
       *  the normal task queue that the sticky worker is running on.
       */
      normalName?: string;
    };
    /** @description Reachability of tasks for a worker on a single task queue. */
    TaskQueueReachability: {
      taskQueue?: string;
      /**
       * @description Task reachability for a worker in a single task queue.
       *  See the TaskReachability docstring for information about each enum variant.
       *  If reachability is empty, this worker is considered unreachable in this task queue.
       */
      reachability?: (
        | 'TASK_REACHABILITY_UNSPECIFIED'
        | 'TASK_REACHABILITY_NEW_WORKFLOWS'
        | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
        | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
        | 'TASK_REACHABILITY_CLOSED_WORKFLOWS'
      )[];
    };
    /** @description Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior. */
    TaskQueueStatus: {
      backlogCountHint?: string;
      readLevel?: string;
      ackLevel?: string;
      /** Format: double */
      ratePerSecond?: number;
      taskIdBlock?: components['schemas']['TaskIdBlock'];
    };
    TaskQueueTypeInfo: {
      /** @description Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID. */
      pollers?: components['schemas']['PollerInfo'][];
    };
    TaskQueueVersionInfo: {
      /** @description Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum. */
      typesInfo?: {
        [key: string]: components['schemas']['TaskQueueTypeInfo'];
      };
      /**
       * Format: enum
       * @enum {string}
       */
      taskReachability?:
        | 'BUILD_ID_TASK_REACHABILITY_UNSPECIFIED'
        | 'BUILD_ID_TASK_REACHABILITY_REACHABLE'
        | 'BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY'
        | 'BUILD_ID_TASK_REACHABILITY_UNREACHABLE';
    };
    TerminateWorkflowExecutionRequest: {
      namespace?: string;
      workflowExecution?: components['schemas']['WorkflowExecution'];
      reason?: string;
      /** @description Serialized additional information to attach to the termination event */
      details?: components['schemas']['Payloads'];
      /** @description The identity of the worker/client */
      identity?: string;
      /**
       * @description If set, this call will error if the most recent (if no run id is set on
       *  `workflow_execution`), or specified (if it is) workflow execution is not part of the same
       *  execution chain as this id.
       */
      firstExecutionRunId?: string;
    };
    TerminateWorkflowExecutionResponse: Record<string, never>;
    TerminatedFailureInfo: Record<string, never>;
    TimeoutFailureInfo: {
      /**
       * Format: enum
       * @enum {string}
       */
      timeoutType?:
        | 'TIMEOUT_TYPE_UNSPECIFIED'
        | 'TIMEOUT_TYPE_START_TO_CLOSE'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_START'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_CLOSE'
        | 'TIMEOUT_TYPE_HEARTBEAT';
      lastHeartbeatDetails?: components['schemas']['Payloads'];
    };
    TimerCanceledEventAttributes: {
      /** @description Will match the `timer_id` from `TIMER_STARTED` event for this timer */
      timerId?: string;
      /** @description The id of the `TIMER_STARTED` event itself */
      startedEventId?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /** @description The id of the worker who requested this cancel */
      identity?: string;
    };
    TimerFiredEventAttributes: {
      /** @description Will match the `timer_id` from `TIMER_STARTED` event for this timer */
      timerId?: string;
      /** @description The id of the `TIMER_STARTED` event itself */
      startedEventId?: string;
    };
    TimerStartedEventAttributes: {
      /** @description The worker/user assigned id for this timer */
      timerId?: string;
      /**
       * @description How long until this timer fires
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      startToFireTimeout?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
    };
    TimestampedBuildIdAssignmentRule: {
      rule?: components['schemas']['BuildIdAssignmentRule'];
      /** Format: date-time */
      createTime?: string;
    };
    TimestampedCompatibleBuildIdRedirectRule: {
      rule?: components['schemas']['CompatibleBuildIdRedirectRule'];
      /** Format: date-time */
      createTime?: string;
    };
    TriggerImmediatelyRequest: {
      /**
       * Format: enum
       * @description If set, override overlap policy for this one request.
       * @enum {string}
       */
      overlapPolicy?:
        | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
        | 'SCHEDULE_OVERLAP_POLICY_SKIP'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
        | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
        | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
        | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
    };
    UpdateNamespaceInfo: {
      description?: string;
      ownerEmail?: string;
      /**
       * @description A key-value map for any customized purpose.
       *  If data already exists on the namespace,
       *  this will merge with the existing key values.
       */
      data?: {
        [key: string]: string;
      };
      /**
       * Format: enum
       * @description New namespace state, server will reject if transition is not allowed.
       *  Allowed transitions are:
       *   Registered -> [ Deleted | Deprecated | Handover ]
       *   Handover -> [ Registered ]
       *  Default is NAMESPACE_STATE_UNSPECIFIED which is do not change state.
       * @enum {string}
       */
      state?:
        | 'NAMESPACE_STATE_UNSPECIFIED'
        | 'NAMESPACE_STATE_REGISTERED'
        | 'NAMESPACE_STATE_DEPRECATED'
        | 'NAMESPACE_STATE_DELETED';
    };
    UpdateNamespaceRequest: {
      namespace?: string;
      updateInfo?: components['schemas']['UpdateNamespaceInfo'];
      config?: components['schemas']['NamespaceConfig'];
      replicationConfig?: components['schemas']['NamespaceReplicationConfig'];
      securityToken?: string;
      deleteBadBinary?: string;
      /** @description promote local namespace to global namespace. Ignored if namespace is already global namespace. */
      promoteNamespace?: boolean;
    };
    UpdateNamespaceResponse: {
      namespaceInfo?: components['schemas']['NamespaceInfo'];
      config?: components['schemas']['NamespaceConfig'];
      replicationConfig?: components['schemas']['NamespaceReplicationConfig'];
      failoverVersion?: string;
      isGlobalNamespace?: boolean;
    };
    UpdateNexusEndpointRequest: {
      /** @description Server-generated unique endpoint ID. */
      id?: string;
      /** @description Data version for this endpoint. Must match current version. */
      version?: string;
      spec?: components['schemas']['EndpointSpec'];
    };
    UpdateNexusEndpointResponse: {
      /** @description Data post acceptance. Can be used to issue additional updates to this record. */
      endpoint?: components['schemas']['Endpoint'];
    };
    /**
     * @description The data needed by a client to refer to a previously invoked workflow
     *  execution update process.
     */
    UpdateRef: {
      workflowExecution?: components['schemas']['WorkflowExecution'];
      updateId?: string;
    };
    UpdateScheduleRequest: {
      /** @description The namespace of the schedule to update. */
      namespace?: string;
      /** @description The id of the schedule to update. */
      scheduleId?: string;
      /**
       * @description The new schedule. The four main fields of the schedule (spec, action,
       *  policies, state) are replaced completely by the values in this message.
       */
      schedule?: components['schemas']['Schedule'];
      /**
       * Format: bytes
       * @description This can be the value of conflict_token from a DescribeScheduleResponse,
       *  which will cause this request to fail if the schedule has been modified
       *  between the Describe and this Update.
       *  If missing, the schedule will be updated unconditionally.
       */
      conflictToken?: string;
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description A unique identifier for this update request for idempotence. Typically UUIDv4. */
      requestId?: string;
      /**
       * @description Schedule search attributes to be updated.
       *  Do not set this field if you do not want to update the search attributes.
       *  A non-null empty object will set the search attributes to an empty map.
       *  Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
       *  you must also set the `schedule` field; otherwise, it will unset the schedule.
       */
      searchAttributes?: components['schemas']['SearchAttributes'];
    };
    UpdateScheduleResponse: Record<string, never>;
    /**
     * @description (-- api-linter: core::0134=disabled
     *      aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
     */
    UpdateWorkflowExecutionRequest: {
      /** @description The namespace name of the target workflow */
      namespace?: string;
      /**
       * @description The target workflow id and (optionally) a specific run thereof
       *  (-- api-linter: core::0203::optional=disabled
       *      aip.dev/not-precedent: false positive triggered by the word "optional" --)
       */
      workflowExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description If set, this call will error if the most recent (if no run id is set on
       *  `workflow_execution`), or specified (if it is) workflow execution is not
       *  part of the same execution chain as this id.
       */
      firstExecutionRunId?: string;
      /**
       * @description Describes when this request should return - basically whether the
       *  update is synchronous, asynchronous, or somewhere in between.
       */
      waitPolicy?: components['schemas']['WaitPolicy'];
      /**
       * @description The request information that will be delivered all the way down to the
       *  workflow execution.
       */
      request?: components['schemas']['Request'];
    };
    UpdateWorkflowExecutionResponse: {
      /** @description Enough information for subsequent poll calls if needed. Never null. */
      updateRef?: components['schemas']['UpdateRef'];
      /**
       * @description The outcome of the update if and only if the workflow execution update
       *  has completed. If this response is being returned before the update has
       *  completed then this field will not be set.
       */
      outcome?: components['schemas']['Outcome'];
      /**
       * Format: enum
       * @description The most advanced lifecycle stage that the Update is known to have
       *  reached, where lifecycle stages are ordered
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
       *  UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
       *  UNSPECIFIED will be returned if and only if the server's maximum wait
       *  time was reached before the Update reached the stage specified in the
       *  request WaitPolicy, and before the context deadline expired; clients may
       *  may then retry the call as needed.
       * @enum {string}
       */
      stage?:
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED';
    };
    UpsertWorkflowSearchAttributesEventAttributes: {
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      searchAttributes?: components['schemas']['SearchAttributes'];
    };
    /** @description VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions. */
    VersionInfo: {
      current?: components['schemas']['ReleaseInfo'];
      recommended?: components['schemas']['ReleaseInfo'];
      instructions?: string;
      alerts?: components['schemas']['Alert'][];
      /** Format: date-time */
      lastUpdateTime?: string;
    };
    /**
     * @description Specifies to the gRPC server how long the client wants the an update-related
     *  RPC call to wait before returning control to the caller.
     */
    WaitPolicy: {
      /**
       * Format: enum
       * @description Indicates the update lifecycle stage that the gRPC call should wait for
       *  before returning.
       * @enum {string}
       */
      lifecycleStage?:
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED'
        | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED';
    };
    /**
     * @description Identifies the version(s) that a worker is compatible with when polling or identifying itself,
     *  and whether or not this worker is opting into the build-id based versioning feature. This is
     *  used by matching to determine which workers ought to receive what tasks.
     */
    WorkerVersionCapabilities: {
      /** @description An opaque whole-worker identifier */
      buildId?: string;
      /**
       * @description If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
       *  tasks.
       */
      useVersioning?: boolean;
    };
    /** @description Identifies the version(s) of a worker that processed a task */
    WorkerVersionStamp: {
      /**
       * @description An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
       *  message is included in requests which previously used that.
       */
      buildId?: string;
      /**
       * @description If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
       *  marker for workflow reset points and the BuildIDs search attribute.
       */
      useVersioning?: boolean;
    };
    /**
     * @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
     *  uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
     *  run id as a way of saying "target the latest run of the workflow".
     */
    WorkflowExecution: {
      workflowId?: string;
      runId?: string;
    };
    WorkflowExecutionCancelRequestedEventAttributes: {
      /**
       * @description User provided reason for requesting cancellation
       *  TODO: shall we create a new field with name "reason" and deprecate this one?
       */
      cause?: string;
      /** @description TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one? */
      externalInitiatedEventId?: string;
      externalWorkflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description id of the worker or client who requested this cancel */
      identity?: string;
    };
    WorkflowExecutionCanceledEventAttributes: {
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      details?: components['schemas']['Payloads'];
    };
    WorkflowExecutionCompletedEventAttributes: {
      /** @description Serialized result of workflow completion (ie: The return value of the workflow function) */
      result?: components['schemas']['Payloads'];
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /** @description If another run is started by cron, this contains the new run id. */
      newExecutionRunId?: string;
    };
    WorkflowExecutionConfig: {
      taskQueue?: components['schemas']['TaskQueue'];
      workflowExecutionTimeout?: string;
      workflowRunTimeout?: string;
      defaultWorkflowTaskTimeout?: string;
    };
    WorkflowExecutionContinuedAsNewEventAttributes: {
      /** @description The run ID of the new workflow started by this continue-as-new */
      newExecutionRunId?: string;
      workflowType?: components['schemas']['WorkflowType'];
      taskQueue?: components['schemas']['TaskQueue'];
      input?: components['schemas']['Payloads'];
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /** @description TODO: How and is this used? */
      backoffStartInterval?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      initiator?:
        | 'CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED'
        | 'CONTINUE_AS_NEW_INITIATOR_WORKFLOW'
        | 'CONTINUE_AS_NEW_INITIATOR_RETRY'
        | 'CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE';
      /**
       * @description TODO: David are these right?
       *  Deprecated. If a workflow's retry policy would cause a new run to start when the current one
       *  has failed, this field would be populated with that failure. Now (when supported by server
       *  and sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set.
       */
      failure?: components['schemas']['Failure'];
      /** @description TODO: Is this the result of *this* workflow as it continued-as-new? */
      lastCompletionResult?: components['schemas']['Payloads'];
      header?: components['schemas']['Header'];
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      /**
       * @description If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
       *  the assignment rules will be used to independently assign a Build ID to the new execution.
       */
      inheritBuildId?: boolean;
    };
    WorkflowExecutionFailedEventAttributes: {
      /** @description Serialized result of workflow failure (ex: An exception thrown, or error returned) */
      failure?: components['schemas']['Failure'];
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /** @description If another run is started by cron or retry, this contains the new run id. */
      newExecutionRunId?: string;
    };
    WorkflowExecutionInfo: {
      execution?: components['schemas']['WorkflowExecution'];
      type?: components['schemas']['WorkflowType'];
      /** Format: date-time */
      startTime?: string;
      /** Format: date-time */
      closeTime?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      status?:
        | 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED'
        | 'WORKFLOW_EXECUTION_STATUS_RUNNING'
        | 'WORKFLOW_EXECUTION_STATUS_COMPLETED'
        | 'WORKFLOW_EXECUTION_STATUS_FAILED'
        | 'WORKFLOW_EXECUTION_STATUS_CANCELED'
        | 'WORKFLOW_EXECUTION_STATUS_TERMINATED'
        | 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW'
        | 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT';
      historyLength?: string;
      parentNamespaceId?: string;
      parentExecution?: components['schemas']['WorkflowExecution'];
      /** Format: date-time */
      executionTime?: string;
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      autoResetPoints?: components['schemas']['ResetPoints'];
      taskQueue?: string;
      stateTransitionCount?: string;
      historySizeBytes?: string;
      /** @description If set, the most recent worker version stamp that appeared in a workflow task completion */
      mostRecentWorkerVersionStamp?: components['schemas']['WorkerVersionStamp'];
      /**
       * @description Workflow execution duration is defined as difference between close time and execution time.
       *  This field is only populated if the workflow is closed.
       */
      executionDuration?: string;
      /**
       * @description Contains information about the root workflow execution.
       *  The root workflow execution is defined as follows:
       *  1. A workflow without parent workflow is its own root workflow.
       *  2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
       *  Note: workflows continued as new or reseted may or may not have parents, check examples below.
       *
       *  Examples:
       *    Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 3: Workflow W1 continued as new W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       *    Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
       *      - The root workflow of all three workflows is W1.
       *    Scenario 5: Workflow W1 is reseted, creating W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       */
      rootExecution?: components['schemas']['WorkflowExecution'];
      /**
       * @description The currently assigned build ID for this execution. Presence of this value means worker versioning is used
       *  for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
       *  when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
       *  again, the assigned build ID may change according to the latest versioning rules.
       *  Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
       *  this execution.
       */
      assignedBuildId?: string;
      /**
       * @description Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
       *  of using the assignment rules.
       */
      inheritedBuildId?: string;
    };
    WorkflowExecutionSignaledEventAttributes: {
      /** @description The name/type of the signal to fire */
      signalName?: string;
      /** @description Will be deserialized and provided as argument(s) to the signal handler */
      input?: components['schemas']['Payloads'];
      /** @description id of the worker/client who sent this signal */
      identity?: string;
      /**
       * @description Headers that were passed by the sender of the signal and copied by temporal
       *  server into the workflow task.
       */
      header?: components['schemas']['Header'];
      /** @description Indicates the signal did not generate a new workflow task when received. */
      skipGenerateWorkflowTask?: boolean;
      /** @description When signal origin is a workflow execution, this field is set. */
      externalWorkflowExecution?: components['schemas']['WorkflowExecution'];
    };
    /** @description Always the first event in workflow history */
    WorkflowExecutionStartedEventAttributes: {
      workflowType?: components['schemas']['WorkflowType'];
      /**
       * @description If this workflow is a child, the namespace our parent lives in.
       *  SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only.
       */
      parentWorkflowNamespace?: string;
      parentWorkflowNamespaceId?: string;
      /**
       * @description Contains information about parent workflow execution that initiated the child workflow these attributes belong to.
       *  If the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated.
       */
      parentWorkflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description EventID of the child execution initiated event in parent workflow */
      parentInitiatedEventId?: string;
      taskQueue?: components['schemas']['TaskQueue'];
      /** @description SDK will deserialize this and provide it as arguments to the workflow function */
      input?: components['schemas']['Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /**
       * @description Run id of the previous workflow which continued-as-new or retired or cron executed into this
       *  workflow.
       */
      continuedExecutionRunId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      initiator?:
        | 'CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED'
        | 'CONTINUE_AS_NEW_INITIATOR_WORKFLOW'
        | 'CONTINUE_AS_NEW_INITIATOR_RETRY'
        | 'CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE';
      continuedFailure?: components['schemas']['Failure'];
      lastCompletionResult?: components['schemas']['Payloads'];
      /**
       * @description This is the run id when the WorkflowExecutionStarted event was written.
       *  A workflow reset changes the execution run_id, but preserves this field.
       */
      originalExecutionRunId?: string;
      /** @description Identity of the client who requested this execution */
      identity?: string;
      /**
       * @description This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.
       *  Used to identify a chain.
       */
      firstExecutionRunId?: string;
      retryPolicy?: components['schemas']['RetryPolicy'];
      /**
       * Format: int32
       * @description Starting at 1, the number of times we have tried to execute this workflow
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The absolute time at which the workflow will be timed out.
       *  This is passed without change to the next run/retry of a workflow.
       */
      workflowExecutionExpirationTime?: string;
      /** @description If this workflow runs on a cron schedule, it will appear here */
      cronSchedule?: string;
      /**
       * @description For a cron workflow, this contains the amount of time between when this iteration of
       *  the cron workflow was scheduled and when it should run next per its cron_schedule.
       */
      firstWorkflowTaskBackoff?: string;
      memo?: components['schemas']['Memo'];
      searchAttributes?: components['schemas']['SearchAttributes'];
      prevAutoResetPoints?: components['schemas']['ResetPoints'];
      header?: components['schemas']['Header'];
      /**
       * @description Version of the child execution initiated event in parent workflow
       *  It should be used together with parent_initiated_event_id to identify
       *  a child initiated event for global namespace
       */
      parentInitiatedEventVersion?: string;
      /** @description This field is new in 1.21. */
      workflowId?: string;
      /**
       * @description If this workflow intends to use anything other than the current overall default version for
       *  the queue, then we include it here.
       *  Deprecated. use `inherited_build_id` instead
       */
      sourceVersionStamp?: components['schemas']['WorkerVersionStamp'];
      /** @description Completion callbacks attached when this workflow was started. */
      completionCallbacks?: components['schemas']['Callback'][];
      /**
       * @description Contains information about the root workflow execution.
       *  The root workflow execution is defined as follows:
       *  1. A workflow without parent workflow is its own root workflow.
       *  2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
       *  Note: workflows continued as new or reseted may or may not have parents, check examples below.
       *
       *  Examples:
       *    Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
       *      - The root workflow of all three workflows is W1.
       *    Scenario 3: Workflow W1 continued as new W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       *    Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
       *      - The root workflow of all three workflows is W1.
       *    Scenario 5: Workflow W1 is reseted, creating W2.
       *      - The root workflow of W1 is W1 and the root workflow of W2 is W2.
       */
      rootWorkflowExecution?: components['schemas']['WorkflowExecution'];
      /** @description When present, this execution is assigned to the build ID of its parent or previous execution. */
      inheritedBuildId?: string;
    };
    WorkflowExecutionTerminatedEventAttributes: {
      /** @description User/client provided reason for termination */
      reason?: string;
      details?: components['schemas']['Payloads'];
      /** @description id of the client who requested termination */
      identity?: string;
    };
    WorkflowExecutionTimedOutEventAttributes: {
      /**
       * Format: enum
       * @enum {string}
       */
      retryState?:
        | 'RETRY_STATE_UNSPECIFIED'
        | 'RETRY_STATE_IN_PROGRESS'
        | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
        | 'RETRY_STATE_TIMEOUT'
        | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
        | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
        | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
        | 'RETRY_STATE_CANCEL_REQUESTED';
      /** @description If another run is started by cron or retry, this contains the new run id. */
      newExecutionRunId?: string;
    };
    WorkflowExecutionUpdateAcceptedEventAttributes: {
      /** @description The instance ID of the update protocol that generated this event. */
      protocolInstanceId?: string;
      /**
       * @description The message ID of the original request message that initiated this
       *  update. Needed so that the worker can recreate and deliver that same
       *  message as part of replay.
       */
      acceptedRequestMessageId?: string;
      /** @description The event ID used to sequence the original request message. */
      acceptedRequestSequencingEventId?: string;
      /**
       * @description The message payload of the original request message that initiated this
       *  update.
       */
      acceptedRequest?: components['schemas']['Request'];
    };
    WorkflowExecutionUpdateAdmittedEventAttributes: {
      /** @description The update request associated with this event. */
      request?: components['schemas']['Request'];
      /**
       * Format: enum
       * @description An explanation of why this event was written to history.
       * @enum {string}
       */
      origin?:
        | 'UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED'
        | 'UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY';
    };
    WorkflowExecutionUpdateCompletedEventAttributes: {
      /** @description The metadata about this update. */
      meta?: components['schemas']['Meta'];
      /** @description The event ID indicating the acceptance of this update. */
      acceptedEventId?: string;
      /** @description The outcome of executing the workflow update function. */
      outcome?: components['schemas']['Outcome'];
    };
    WorkflowExecutionUpdateRejectedEventAttributes: {
      /** @description The instance ID of the update protocol that generated this event. */
      protocolInstanceId?: string;
      /**
       * @description The message ID of the original request message that initiated this
       *  update. Needed so that the worker can recreate and deliver that same
       *  message as part of replay.
       */
      rejectedRequestMessageId?: string;
      /** @description The event ID used to sequence the original request message. */
      rejectedRequestSequencingEventId?: string;
      /**
       * @description The message payload of the original request message that initiated this
       *  update.
       */
      rejectedRequest?: components['schemas']['Request'];
      /** @description The cause of rejection. */
      failure?: components['schemas']['Failure'];
    };
    WorkflowPropertiesModifiedEventAttributes: {
      /** @description The `WORKFLOW_TASK_COMPLETED` event which this command was reported with */
      workflowTaskCompletedEventId?: string;
      /**
       * @description If set, update the workflow memo with the provided values. The values will be merged with
       *  the existing memo. If the user wants to delete values, a default/empty Payload should be
       *  used as the value for the key being deleted.
       */
      upsertedMemo?: components['schemas']['Memo'];
    };
    WorkflowPropertiesModifiedExternallyEventAttributes: {
      /**
       * @description If set to a nonempty string, future workflow tasks for this workflow shall be dispatched on
       *  the provided queue.
       */
      newTaskQueue?: string;
      /** @description If set, update the workflow task timeout to this value. */
      newWorkflowTaskTimeout?: string;
      /** @description If set, update the workflow run timeout to this value. May be set to 0 for no timeout. */
      newWorkflowRunTimeout?: string;
      /** @description If set, update the workflow execution timeout to this value. May be set to 0 for no timeout. */
      newWorkflowExecutionTimeout?: string;
      /**
       * @description If set, update the workflow memo with the provided values. The values will be merged with
       *  the existing memo. If the user wants to delete values, a default/empty Payload should be
       *  used as the value for the key being deleted.
       */
      upsertedMemo?: components['schemas']['Memo'];
    };
    /** @description See https://docs.temporal.io/docs/concepts/queries/ */
    WorkflowQuery: {
      /** @description The workflow-author-defined identifier of the query. Typically a function name. */
      queryType?: string;
      /** @description Serialized arguments that will be provided to the query handler. */
      queryArgs?: components['schemas']['Payloads'];
      /**
       * @description Headers that were passed by the caller of the query and copied by temporal
       *  server into the workflow task.
       */
      header?: components['schemas']['Header'];
    };
    WorkflowTaskCompletedEventAttributes: {
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to */
      startedEventId?: string;
      /** @description Identity of the worker who completed this task */
      identity?: string;
      /** @description Binary ID of the worker who completed this task */
      binaryChecksum?: string;
      /**
       * @description Version info of the worker who processed this workflow task. If present, the `build_id` field
       *  within is also used as `binary_checksum`, which may be omitted in that case (it may also be
       *  populated to preserve compatibility).
       *  Deprecated. Use the info inside the corresponding WorkflowTaskStartedEvent
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
      /**
       * @description Data the SDK wishes to record for itself, but server need not interpret, and does not
       *  directly impact workflow state.
       */
      sdkMetadata?: components['schemas']['WorkflowTaskCompletedMetadata'];
      /** @description Local usage data sent during workflow task completion and recorded here for posterity */
      meteringMetadata?: components['schemas']['MeteringMetadata'];
    };
    WorkflowTaskCompletedMetadata: {
      /**
       * @description Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
       *
       *  During replay:
       *  * If a flag is not recognized (value is too high or not defined), it must fail the workflow
       *    task.
       *  * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
       *    that flag during and after this WFT are allowed to assume that the flag is present.
       *  * If a code check for a flag does not find the flag in the set of used flags, it must take
       *    the branch corresponding to the absence of that flag.
       *
       *  During non-replay execution of new WFTs:
       *  * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
       *    previously recorded) flags when completing the WFT.
       *
       *  SDKs which are too old to even know about this field at all are considered to produce
       *  undefined behavior if they replay workflows which used this mechanism.
       *
       *  (-- api-linter: core::0141::forbidden-types=disabled
       *      aip.dev/not-precedent: These really shouldn't have negative values. --)
       */
      coreUsedFlags?: number[];
      /**
       * @description Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
       *  here as processing a workflow with a different language than the one which authored it is
       *  already undefined behavior. See `core_used_patches` for more.
       *
       *  (-- api-linter: core::0141::forbidden-types=disabled
       *      aip.dev/not-precedent: These really shouldn't have negative values. --)
       */
      langUsedFlags?: number[];
      /**
       * @description Name of the SDK that processed the task. This is usually something like "temporal-go" and is
       *  usually the same as client-name gRPC header. This should only be set if its value changed
       *  since the last time recorded on the workflow (or be set on the first task).
       *
       *  (-- api-linter: core::0122::name-suffix=disabled
       *      aip.dev/not-precedent: We're ok with a name suffix here. --)
       */
      sdkName?: string;
      /**
       * @description Version of the SDK that processed the task. This is usually something like "1.20.0" and is
       *  usually the same as client-version gRPC header. This should only be set if its value changed
       *  since the last time recorded on the workflow (or be set on the first task).
       */
      sdkVersion?: string;
    };
    WorkflowTaskFailedEventAttributes: {
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to */
      startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      cause?:
        | 'WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID'
        | 'WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND'
        | 'WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY'
        | 'WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED'
        | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES'
        | 'WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED';
      /** @description The failure details */
      failure?: components['schemas']['Failure'];
      /** @description If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task? */
      identity?: string;
      /** @description The original run id of the workflow. For reset workflow. */
      baseRunId?: string;
      /** @description If the workflow is being reset, the new run id. */
      newRunId?: string;
      /** @description TODO: ? */
      forkEventVersion?: string;
      /**
       * @description DEPRECATED since 1.21 - use `worker_version` instead.
       *  If a worker explicitly failed this task, its binary id
       */
      binaryChecksum?: string;
      /**
       * @description Version info of the worker who processed this workflow task. If present, the `build_id` field
       *  within is also used as `binary_checksum`, which may be omitted in that case (it may also be
       *  populated to preserve compatibility).
       *  Deprecated. Use the info inside the corresponding WorkflowTaskStartedEvent
       */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
    };
    WorkflowTaskScheduledEventAttributes: {
      /** @description The task queue this workflow task was enqueued in, which could be a normal or sticky queue */
      taskQueue?: components['schemas']['TaskQueue'];
      /**
       * @description How long the worker has to process this task once receiving it before it times out
       *
       *  (-- api-linter: core::0140::prepositions=disabled
       *      aip.dev/not-precedent: "to" is used to indicate interval. --)
       */
      startToCloseTimeout?: string;
      /**
       * Format: int32
       * @description Starting at 1, how many attempts there have been to complete this task
       */
      attempt?: number;
    };
    WorkflowTaskStartedEventAttributes: {
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      scheduledEventId?: string;
      /** @description Identity of the worker who picked up this task */
      identity?: string;
      /** @description TODO: ? Appears unused? */
      requestId?: string;
      /**
       * @description True if this workflow should continue-as-new soon because its history size (in
       *  either event count or bytes) is getting large.
       */
      suggestContinueAsNew?: boolean;
      /**
       * @description Total history size in bytes, which the workflow might use to decide when to
       *  continue-as-new regardless of the suggestion. Note that history event count is
       *  just the event id of this event, so we don't include it explicitly here.
       */
      historySizeBytes?: string;
      /** @description Version info of the worker to whom this task was dispatched. */
      workerVersion?: components['schemas']['WorkerVersionStamp'];
      /**
       * @description Used by server internally to properly reapply build ID redirects to an execution
       *  when rebuilding it from events.
       */
      buildIdRedirectCounter?: string;
    };
    WorkflowTaskTimedOutEventAttributes: {
      /** @description The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to */
      scheduledEventId?: string;
      /** @description The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to */
      startedEventId?: string;
      /**
       * Format: enum
       * @enum {string}
       */
      timeoutType?:
        | 'TIMEOUT_TYPE_UNSPECIFIED'
        | 'TIMEOUT_TYPE_START_TO_CLOSE'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_START'
        | 'TIMEOUT_TYPE_SCHEDULE_TO_CLOSE'
        | 'TIMEOUT_TYPE_HEARTBEAT';
    };
    /**
     * @description Represents the identifier used by a workflow author to define the workflow. Typically, the
     *  name of a function. This is sometimes referred to as the workflow's "name"
     */
    WorkflowType: {
      name?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /** @description GetClusterInfo returns information about temporal cluster */
  GetClusterInfo: {
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetClusterInfoResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListNamespaces returns the information and configuration for all namespaces. */
  ListNamespaces: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /**
         * @description By default namespaces in NAMESPACE_STATE_DELETED state are not included.
         *  Setting include_deleted to true will include deleted namespaces.
         *  Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.
         */
        'namespaceFilter.includeDeleted'?: boolean;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListNamespacesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RegisterNamespace creates a new namespace which can be used as a container for all resources.
   *
   *  A Namespace is a top level entity within Temporal, and is used as a container for resources
   *  like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
   *  isolation for all resources within the namespace. All resources belongs to exactly one
   *  namespace.
   */
  RegisterNamespace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterNamespaceRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RegisterNamespaceResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description DescribeNamespace returns the information and configuration for a registered namespace. */
  DescribeNamespace: {
    parameters: {
      query?: {
        id?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DescribeNamespaceResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
   *
   *  This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
   *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
   *  no longer valid due to activity timeout, already being completed, or never having existed.
   */
  RespondActivityTaskCanceled: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RespondActivityTaskCanceledRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RespondActivityTaskCanceledResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskCanceled`. This version allows clients to record failures by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RespondActivityTaskCanceledById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RespondActivityTaskCanceledByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RespondActivityTaskCanceledByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RespondActivityTaskCompleted is called by workers when they successfully complete an activity
   *  task.
   *
   *  This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
   *  and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
   *  no longer valid due to activity timeout, already being completed, or never having existed.
   */
  RespondActivityTaskCompleted: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RespondActivityTaskCompletedRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RespondActivityTaskCompletedResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskCompleted`. This version allows clients to record completions by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RespondActivityTaskCompletedById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RespondActivityTaskCompletedByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RespondActivityTaskCompletedByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RespondActivityTaskFailed is called by workers when processing an activity task fails.
   *
   *  This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
   *  a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
   *  longer valid due to activity timeout, already being completed, or never having existed.
   */
  RespondActivityTaskFailed: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RespondActivityTaskFailedRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RespondActivityTaskFailedResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskFailed`. This version allows clients to record failures by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RespondActivityTaskFailedById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RespondActivityTaskFailedByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RespondActivityTaskFailedByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
   *
   *  If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
   *  then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
   *  the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
   *  such situations, in that event, the SDK should request cancellation of the activity.
   */
  RecordActivityTaskHeartbeat: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecordActivityTaskHeartbeatRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RecordActivityTaskHeartbeatResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
   *  namespace/workflow id/activity id instead of task token.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "By" is used to indicate request type. --)
   */
  RecordActivityTaskHeartbeatById: {
    parameters: {
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecordActivityTaskHeartbeatByIdRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RecordActivityTaskHeartbeatByIdResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
  ListArchivedWorkflowExecutions: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListArchivedWorkflowExecutionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListBatchOperations returns a list of batch operations */
  ListBatchOperations: {
    parameters: {
      query?: {
        /** @description List page size */
        pageSize?: number;
        /** @description Next page token */
        nextPageToken?: string;
      };
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListBatchOperationsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description DescribeBatchOperation returns the information about a batch operation */
  DescribeBatchOperation: {
    parameters: {
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DescribeBatchOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description StartBatchOperation starts a new batch operation */
  StartBatchOperation: {
    parameters: {
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Job ID defines the unique ID for the batch job */
        jobId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartBatchOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['StartBatchOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description StopBatchOperation stops a batch operation */
  StopBatchOperation: {
    parameters: {
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StopBatchOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['StopBatchOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description List all schedules in a namespace. */
  ListSchedules: {
    parameters: {
      query?: {
        /** @description How many to return at once. */
        maximumPageSize?: number;
        /** @description Token to get the next page of results. */
        nextPageToken?: string;
        /** @description Query to filter schedules. */
        query?: string;
      };
      path: {
        /** @description The namespace to list schedules in. */
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListSchedulesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Returns the schedule description and current state of an existing schedule. */
  DescribeSchedule: {
    parameters: {
      path: {
        /** @description The namespace of the schedule to describe. */
        namespace: string;
        /** @description The id of the schedule to describe. */
        scheduleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DescribeScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Creates a new schedule. */
  CreateSchedule: {
    parameters: {
      path: {
        /** @description The namespace the schedule should be created in. */
        namespace: string;
        /** @description The id of the new schedule. */
        scheduleId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateScheduleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['CreateScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Deletes a schedule, removing it from the system. */
  DeleteSchedule: {
    parameters: {
      query?: {
        /** @description The identity of the client who initiated this request. */
        identity?: string;
      };
      path: {
        /** @description The namespace of the schedule to delete. */
        namespace: string;
        /** @description The id of the schedule to delete. */
        scheduleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DeleteScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Lists matching times within a range. */
  ListScheduleMatchingTimes: {
    parameters: {
      query?: {
        /** @description Time range to query. */
        startTime?: string;
        endTime?: string;
      };
      path: {
        /** @description The namespace of the schedule to query. */
        namespace: string;
        /** @description The id of the schedule to query. */
        scheduleId: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListScheduleMatchingTimesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Makes a specific change to a schedule or triggers an immediate action. */
  PatchSchedule: {
    parameters: {
      path: {
        /** @description The namespace of the schedule to patch. */
        namespace: string;
        /** @description The id of the schedule to patch. */
        scheduleId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PatchScheduleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['PatchScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Changes the configuration or state of an existing schedule. */
  UpdateSchedule: {
    parameters: {
      path: {
        /** @description The namespace of the schedule to update. */
        namespace: string;
        /** @description The id of the schedule to update. */
        scheduleId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateScheduleRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['UpdateScheduleResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListSearchAttributes returns comprehensive information about search attributes. */
  ListSearchAttributes: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListSearchAttributesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Deprecated. Use `GetWorkerVersioningRules`.
   *  Fetches the worker build id versioning sets for a task queue.
   */
  GetWorkerBuildIdCompatibility: {
    parameters: {
      query?: {
        /**
         * @description Limits how many compatible sets will be returned. Specify 1 to only return the current
         *  default major version set. 0 returns all sets.
         */
        maxSets?: number;
      };
      path: {
        namespace: string;
        /** @description Must be set, the task queue to interrogate about worker id compatibility. */
        taskQueue: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetWorkerBuildIdCompatibilityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Fetches the Build ID assignment and redirect rules for a Task Queue.
   *  WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.
   */
  GetWorkerVersioningRules: {
    parameters: {
      path: {
        namespace: string;
        taskQueue: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetWorkerVersioningRulesResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
   *    - List of pollers
   *    - Workflow Reachability status
   *    - Backlog info for Workflow and/or Activity tasks
   */
  DescribeTaskQueue: {
    parameters: {
      query?: {
        'taskQueue.name'?: string;
        /** @description Default: TASK_QUEUE_KIND_NORMAL. */
        'taskQueue.kind'?:
          | 'TASK_QUEUE_KIND_UNSPECIFIED'
          | 'TASK_QUEUE_KIND_NORMAL'
          | 'TASK_QUEUE_KIND_STICKY';
        /**
         * @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
         *  the normal task queue that the sticky worker is running on.
         */
        'taskQueue.normalName'?: string;
        /**
         * @description Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.
         *  If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
         */
        taskQueueType?:
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS';
        /** @description Deprecated. Ignored in `ENHANCED` mode. */
        includeTaskQueueStatus?: boolean;
        /** @description All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode. */
        apiMode?:
          | 'DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED'
          | 'DESCRIBE_TASK_QUEUE_MODE_ENHANCED';
        /** @description Include specific Build IDs. */
        'versions.buildIds'?: string[];
        /** @description Include the unversioned queue. */
        'versions.unversioned'?: boolean;
        /**
         * @description Include all active versions. A version is considered active if it has had new
         *  tasks or polls recently.
         */
        'versions.allActive'?: boolean;
        /** @description Task queue types to report info about. If not specified, all types are considered. */
        taskQueueTypes?: (
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS'
        )[];
        /**
         * @description Report backlog info for the requested task queue types and versions
         *  bool report_backlog_info = 8;
         *  Report list of pollers for requested task queue types and versions
         */
        reportPollers?: boolean;
        /**
         * @description Report task reachability for the requested versions and all task types (task reachability is not reported
         *  per task type).
         */
        reportTaskReachability?: boolean;
      };
      path: {
        namespace: string;
        'task_queue.name': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DescribeTaskQueueResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description UpdateNamespace is used to update the information and configuration of a registered
   *  namespace.
   */
  UpdateNamespace: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNamespaceRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['UpdateNamespaceResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Deprecated. Use `DescribeTaskQueue`.
   *
   *  Fetches task reachability to determine whether a worker may be retired.
   *  The request may specify task queues to query for or let the server fetch all task queues mapped to the given
   *  build IDs.
   *
   *  When requesting a large number of task queues or all task queues associated with the given build ids in a
   *  namespace, all task queues will be listed in the response but some of them may not contain reachability
   *  information due to a server enforced limit. When reaching the limit, task queues that reachability information
   *  could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
   *  another call to get the reachability for those task queues.
   *
   *  Open source users can adjust this limit by setting the server's dynamic config value for
   *  `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
   */
  GetWorkerTaskReachability: {
    parameters: {
      query?: {
        /**
         * @description Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
         *  The number of build ids that can be queried in a single API call is limited.
         *  Open source users can adjust this limit by setting the server's dynamic config value for
         *  `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
         */
        buildIds?: string[];
        /**
         * @description Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
         *  build ids in the namespace.
         *  Must specify at least one task queue if querying for an unversioned worker.
         *  The number of task queues that the server will fetch reachability information for is limited.
         *  See the `GetWorkerTaskReachabilityResponse` documentation for more information.
         */
        taskQueues?: string[];
        /**
         * @description Type of reachability to query for.
         *  `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
         *  Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
         *  Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
         *  unspecified.
         *  See the TaskReachability docstring for information about each enum variant.
         */
        reachability?:
          | 'TASK_REACHABILITY_UNSPECIFIED'
          | 'TASK_REACHABILITY_NEW_WORKFLOWS'
          | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
          | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
          | 'TASK_REACHABILITY_CLOSED_WORKFLOWS';
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetWorkerTaskReachabilityResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
  CountWorkflowExecutions: {
    parameters: {
      query?: {
        query?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['CountWorkflowExecutionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
  ListWorkflowExecutions: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      path: {
        namespace: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListWorkflowExecutionsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description ExecuteMultiOperation executes multiple operations within a single workflow.
   *
   *  Operations are started atomically, meaning if *any* operation fails to be started, none are,
   *  and the request fails. Upon start, the API returns only when *all* operations have a response.
   *
   *  Upon failure, it returns `MultiOperationExecutionFailure` where the status code
   *  equals the status code of the *first* operation that failed to be started.
   *
   *  NOTE: Experimental API.
   */
  ExecuteMultiOperation: {
    parameters: {
      path: {
        namespace: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExecuteMultiOperationRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ExecuteMultiOperationResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description DescribeWorkflowExecution returns information about the specified workflow execution. */
  DescribeWorkflowExecution: {
    parameters: {
      query?: {
        'execution.workflowId'?: string;
        'execution.runId'?: string;
      };
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DescribeWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
   *  `NotFound` if the specified workflow execution is unknown to the service.
   */
  GetWorkflowExecutionHistory: {
    parameters: {
      query?: {
        'execution.workflowId'?: string;
        'execution.runId'?: string;
        maximumPageSize?: number;
        /**
         * @description If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
         *  these, it should be passed here to fetch the next page.
         */
        nextPageToken?: string;
        /**
         * @description If set to true, the RPC call will not resolve until there is a new event which matches
         *  the `history_event_filter_type`, or a timeout is hit.
         */
        waitNewEvent?: boolean;
        /**
         * @description Filter returned events such that they match the specified filter type.
         *  Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
         */
        historyEventFilterType?:
          | 'HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED'
          | 'HISTORY_EVENT_FILTER_TYPE_ALL_EVENT'
          | 'HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT';
        skipArchival?: boolean;
      };
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetWorkflowExecutionHistoryResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
   *  order (starting from last event). Fails with`NotFound` if the specified workflow execution is
   *  unknown to the service.
   */
  GetWorkflowExecutionHistoryReverse: {
    parameters: {
      query?: {
        'execution.workflowId'?: string;
        'execution.runId'?: string;
        maximumPageSize?: number;
        nextPageToken?: string;
      };
      path: {
        namespace: string;
        'execution.workflow_id': string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetWorkflowExecutionHistoryReverseResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description QueryWorkflow requests a query be executed for a specified workflow execution. */
  QueryWorkflow: {
    parameters: {
      path: {
        namespace: string;
        'execution.workflow_id': string;
        'query.query_type': string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryWorkflowRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['QueryWorkflowResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description StartWorkflowExecution starts a new workflow execution.
   *
   *  It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
   *  also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
   *  instance already exists with same workflow id.
   */
  StartWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        workflowId: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['StartWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
   *  it isn't yet started.
   *
   *  If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
   *  and a workflow task is generated.
   *
   *  If the workflow is not running or not found, then the workflow is created with
   *  `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
   *  workflow task is generated.
   *
   *  (-- api-linter: core::0136::prepositions=disabled
   *      aip.dev/not-precedent: "With" is used to indicate combined operation. --)
   */
  SignalWithStartWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        workflowId: string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SignalWithStartWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['SignalWithStartWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
   *  a workflow execution.
   *
   *  This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
   *  workflow history and a new workflow task created for the workflow. It returns success if the requested
   *  workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
   */
  RequestCancelWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RequestCancelWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['RequestCancelWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description ResetWorkflowExecution will reset an existing workflow execution to a specified
   *  `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
   *  execution instance.
   *  TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
   */
  ResetWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResetWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ResetWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description SignalWorkflowExecution is used to send a signal to a running workflow execution.
   *
   *  This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
   *  task being created for the execution.
   */
  SignalWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SignalWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['SignalWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description TerminateWorkflowExecution terminates an existing workflow execution by recording a
   *  `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
   *  execution instance.
   */
  TerminateWorkflowExecution: {
    parameters: {
      path: {
        namespace: string;
        'workflow_execution.workflow_id': string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TerminateWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['TerminateWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Invokes the specified update function on user workflow code. */
  UpdateWorkflowExecution: {
    parameters: {
      path: {
        /** @description The namespace name of the target workflow */
        namespace: string;
        'workflow_execution.workflow_id': string;
        'request.input.name': string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateWorkflowExecutionRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['UpdateWorkflowExecutionResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
   *  next_page_token field of the previous response to get the next page of results. An empty next_page_token
   *  indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
   *  earlier than the previous page's last endpoint's ID may be missed.
   */
  ListNexusEndpoints: {
    parameters: {
      query?: {
        pageSize?: number;
        /**
         * @description To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's
         *  response, the token will be empty if there's no other page.
         *  Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size.
         */
        nextPageToken?: string;
        /**
         * @description Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.
         *  (-- api-linter: core::203::field-behavior-required=disabled
         *      aip.dev/not-precedent: Not following linter rules. --)
         */
        name?: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['ListNexusEndpointsResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
   *  ALREADY_EXISTS.
   *  Returns the created endpoint with its initial version. You may use this version for subsequent updates.
   */
  CreateNexusEndpoint: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateNexusEndpointRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['CreateNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
  GetNexusEndpoint: {
    parameters: {
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description Delete an incoming Nexus service by ID. */
  DeleteNexusEndpoint: {
    parameters: {
      query?: {
        /** @description Data version for this endpoint. Must match current version. */
        version?: string;
      };
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['DeleteNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /**
   * @description Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
   *  `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
   *  match.
   *  Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
   *  need to increment the version yourself. The server will increment the version for you after each update.
   */
  UpdateNexusEndpoint: {
    parameters: {
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNexusEndpointRequest'];
      };
    };
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['UpdateNexusEndpointResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
  /** @description GetSystemInfo returns information about the system. */
  GetSystemInfo: {
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': components['schemas']['GetSystemInfoResponse'];
        };
      };
      /** @description Default error response */
      default: {
        content: {
          'application/json': components['schemas']['Status'];
        };
      };
    };
  };
}
