import { Meta } from '@storybook/blocks';
import { Markdown } from '@storybook/blocks';

import SearchAttributesForm from './search-attributes-form.stories.svelte';

<Meta of={SearchAttributesForm} />

# SearchAttributesForm Component

A reusable form component for managing custom search attributes with SuperForms validation.

## Features

- **Promise-Based Loading**: Async data loading with built-in error handling
- **SuperForms Integration**: Built-in validation with Zod schema and dirty state tracking
- **Comprehensive Error Handling**: Form state management with proper error display
- **i18n Support**: Full internationalization with translate() function calls
- **Accessibility**: Full ARIA support and keyboard navigation
- **Type Safety**: Full TypeScript support with Svelte 5 runes

## Architecture

The component uses two main parts:

1. **Parent Component**: Handles async data loading with `#await` pattern
2. **Content Component**: Renders the form with SuperForms configuration

## Props Interface

The component accepts the following props:

```typescript
interface Props {
  class?: string;
  initialAttributesPromise: Promise<SearchAttributeDefinition[]>;
  onSave: (attributes: SearchAttributeDefinition[]) => Promise<void>;
  onSuccess?: (attributes: SearchAttributeDefinition[]) => void;
  onCancel?: () => void;
  getSupportedTypes: () => SearchAttributeTypeOption[];
}
```

## Usage Examples

### Basic Usage

```svelte
<script lang="ts">
  import { page } from '$app/state';
  import SearchAttributesForm from '$lib/components/search-attributes-form/search-attributes-form.svelte';
  import { fetchSearchAttributesForNamespace } from '$lib/services/search-attributes-service';
  import { SEARCH_ATTRIBUTE_TYPE } from '$lib/types/workflows';
  import { translate } from '$lib/i18n/translate';

  const namespace = $derived(page.params.namespace);

  async function fetchAttributes(): Promise<SearchAttributeDefinition[]> {
    const response = await fetchSearchAttributesForNamespace(namespace);
    return Object.entries(response.customAttributes).map(([name, type]) => ({
      name,
      type,
    }));
  }

  async function handleSave(
    attributes: SearchAttributeDefinition[],
  ): Promise<void> {
    // Implement save logic
    await saveSearchAttributes(namespace, attributes);
  }

  function handleSuccess(attributes: SearchAttributeDefinition[]) {
    console.log('Successfully saved:', attributes);
    // Show toast, redirect, etc.
  }

  function handleCancel() {
    console.log('Form cancelled');
    // Navigate back, reset state, etc.
  }

  function getSupportedTypes(): SearchAttributeTypeOption[] {
    return [
      {
        label: translate('search-attributes.type-keyword'),
        value: SEARCH_ATTRIBUTE_TYPE.KEYWORD,
      },
      {
        label: translate('search-attributes.type-text'),
        value: SEARCH_ATTRIBUTE_TYPE.TEXT,
      },
      {
        label: translate('search-attributes.type-int'),
        value: SEARCH_ATTRIBUTE_TYPE.INT,
      },
      {
        label: translate('search-attributes.type-double'),
        value: SEARCH_ATTRIBUTE_TYPE.DOUBLE,
      },
      {
        label: translate('search-attributes.type-bool'),
        value: SEARCH_ATTRIBUTE_TYPE.BOOL,
      },
      {
        label: translate('search-attributes.type-datetime'),
        value: SEARCH_ATTRIBUTE_TYPE.DATETIME,
      },
      {
        label: translate('search-attributes.type-keywordlist'),
        value: SEARCH_ATTRIBUTE_TYPE.KEYWORDLIST,
      },
    ];
  }

  const initialAttributesPromise = fetchAttributes();
</script>

<SearchAttributesForm
  {initialAttributesPromise}
  onSave={handleSave}
  onSuccess={handleSuccess}
  onCancel={handleCancel}
  {getSupportedTypes}
/>
```

### Integration with SvelteKit

```svelte
<!-- src/routes/namespaces/[namespace]/search-attributes/+page.svelte -->
<script lang="ts">
  import { page } from '$app/state';
  import SearchAttributesForm from '$lib/components/search-attributes-form/search-attributes-form.svelte';
  import { translate } from '$lib/i18n/translate';
  import { fetchSearchAttributesForNamespace } from '$lib/services/search-attributes-service';
  import { SEARCH_ATTRIBUTE_TYPE } from '$lib/types/workflows';

  import type {
    SearchAttributeDefinition,
    SearchAttributeTypeOption,
  } from '$lib/components/search-attributes-form/types';

  const namespace = $derived(page.params.namespace);

  async function fetchAttributes(): Promise<SearchAttributeDefinition[]> {
    if (!namespace) {
      throw new Error('No namespace found in page params');
    }

    const response = await fetchSearchAttributesForNamespace(namespace);
    const attributes = Object.entries(response.customAttributes).map(
      ([name, type]) => ({ name, type }),
    );

    // Always return at least one empty row for the UI
    return attributes.length > 0
      ? attributes
      : [{ name: '', type: getSupportedTypes()[0]?.value || '' }];
  }

  async function handleSave(
    attributes: SearchAttributeDefinition[],
  ): Promise<void> {
    // TODO: Implement when SDK team adds CRUD endpoints
    throw new Error(translate('search-attributes.crud-not-implemented'));
  }

  function handleSuccess(attributes: SearchAttributeDefinition[]) {
    console.log('Search attributes saved successfully');
    // Add any other success handling here (toasts, navigation, etc.)
  }

  function handleCancel() {
    console.log('Search attributes form cancelled');
    // Add any cancel handling here (navigation, confirmation, etc.)
  }

  function getSupportedTypes(): SearchAttributeTypeOption[] {
    return [
      {
        label: translate('search-attributes.type-keyword'),
        value: SEARCH_ATTRIBUTE_TYPE.KEYWORD,
      },
      {
        label: translate('search-attributes.type-text'),
        value: SEARCH_ATTRIBUTE_TYPE.TEXT,
      },
      {
        label: translate('search-attributes.type-int'),
        value: SEARCH_ATTRIBUTE_TYPE.INT,
      },
      {
        label: translate('search-attributes.type-double'),
        value: SEARCH_ATTRIBUTE_TYPE.DOUBLE,
      },
      {
        label: translate('search-attributes.type-bool'),
        value: SEARCH_ATTRIBUTE_TYPE.BOOL,
      },
      {
        label: translate('search-attributes.type-datetime'),
        value: SEARCH_ATTRIBUTE_TYPE.DATETIME,
      },
      {
        label: translate('search-attributes.type-keywordlist'),
        value: SEARCH_ATTRIBUTE_TYPE.KEYWORDLIST,
      },
    ];
  }

  const initialAttributesPromise = fetchAttributes();
</script>

<svelte:head>
  <title>Custom Search Attributes</title>
</svelte:head>

<div class="space-y-6">
  <div>
    <h1 class="text-2xl font-bold">Custom Search Attributes</h1>
    <p class="text-gray-600 mt-2">
      Manage custom search attributes for this namespace.
    </p>
  </div>

  <SearchAttributesForm
    {initialAttributesPromise}
    onSave={handleSave}
    onSuccess={handleSuccess}
    onCancel={handleCancel}
    {getSupportedTypes}
  />
</div>
```

## Props

<Markdown>
  {`
| Prop                    | Type                                                    | Default    | Description                             |
| ----------------------- | ------------------------------------------------------- | ---------- | --------------------------------------- |
| initialAttributesPromise | Promise<SearchAttributeDefinition[]>                  | Required   | Promise that resolves to initial data  |
| onSave                  | (attributes: SearchAttributeDefinition[]) => Promise<void> | Required   | Save handler function                  |
| onSuccess               | (attributes: SearchAttributeDefinition[]) => void     | () => {}   | Success callback after save            |
| onCancel                | () => void                                            | () => {}   | Cancel callback                        |
| getSupportedTypes       | () => SearchAttributeTypeOption[]                     | Required   | Function returning supported types     |
| class                   | string                                                 | ''         | Additional CSS classes                 |
  `}
</Markdown>

## Loading States

The component automatically handles three states:

- **Loading**: Shows skeleton loaders while the promise resolves
- **Success**: Renders the form with loaded attributes
- **Error**: Shows error messages with retry functionality

## Error Handling

The component provides comprehensive error handling through SuperForms:

- **Form State Management**: Prevents form from getting stuck in "Saving..." state
- **SuperForms Integration**: Proper error handling with `onUpdate` callback
- **User-Friendly Messages**: Automatic conversion of technical errors to readable messages
- **Form-Level Validation**: Displays validation errors for unique constraints
- **Field-Level Validation**: Individual field validation with real-time feedback
- **API Error Display**: Status messages with proper intent styling
- **Dirty State Tracking**: Shows when form has unsaved changes
- **Form Reset**: Cancel button properly resets form to initial state

## Dirty State Management

The form automatically tracks unsaved changes using SuperForms `isTainted` function:

- **Visual Indicator**: Save button shows a badge when there are unsaved changes
- **Real-time Updates**: Badge updates immediately as user makes changes
- **Form Reset**: Cancel button clears dirty state and resets to initial values
- **Save Button State**: Disabled when no changes or while submitting

## Validation

Form validation is handled by Zod schema with the following rules:

- Attribute names are required (min 1 character)
- Attribute names must be unique within the form
- Attribute types must be one of the supported types

## Accessibility

- Proper ARIA labels and roles
- Keyboard navigation support
- Screen reader friendly error messages
- Focus management for form interactions

## Key Benefits

1. **Flexibility**: Each handler can be customized independently
2. **Testability**: Individual functions are easier to test in isolation
3. **Composability**: Functions can be shared across different components
4. **Type Safety**: Direct function signatures provide better TypeScript inference
5. **Simplicity**: Clean API with direct function props
6. **Tree Shaking**: Better optimization as unused functions can be eliminated
