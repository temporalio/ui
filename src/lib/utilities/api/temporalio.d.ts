/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/cluster-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetClusterInfo returns information about temporal cluster */
    get: operations['GetClusterInfo2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListNamespaces returns the information and configuration for all namespaces. */
    get: operations['ListNamespaces2'];
    put?: never;
    /**
     * RegisterNamespace creates a new namespace which can be used as a container for all resources.
     * @description A Namespace is a top level entity within Temporal, and is used as a container for resources
     *     like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
     *     isolation for all resources within the namespace. All resources belongs to exactly one
     *     namespace.
     */
    post: operations['RegisterNamespace2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeNamespace returns the information and configuration for a registered namespace. */
    get: operations['DescribeNamespace2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RespondActivityTaskFailed is called by workers when processing an activity task fails.
     * @description This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
     *     and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *     no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCanceled2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/cancel-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskCanceled`. This version allows clients to record failures by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RespondActivityTaskCanceledById2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RespondActivityTaskCompleted is called by workers when they successfully complete an activity
     *     task.
     * @description This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
     *     and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *     no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCompleted2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/complete-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskCompleted`. This version allows clients to record completions by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RespondActivityTaskCompletedById2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/fail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RespondActivityTaskFailed is called by workers when processing an activity task fails.
     * @description This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
     *     a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
     *     longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskFailed2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/fail-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskFailed`. This version allows clients to record failures by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RespondActivityTaskFailedById2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
     * @description If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
     *     then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
     *     the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
     *     such situations, in that event, the SDK should request cancellation of the activity.
     */
    post: operations['RecordActivityTaskHeartbeat2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/heartbeat-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RecordActivityTaskHeartbeatById2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/pause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * PauseActivity pauses the execution of an activity specified by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be paused
     * @description Pausing an activity means:
     *     - If the activity is currently waiting for a retry or is running and subsequently fails,
     *       it will not be rescheduled until it is unpaused.
     *     - If the activity is already paused, calling this method will have no effect.
     *     - If the activity is running and finishes successfully, the activity will be completed.
     *     - If the activity is running and finishes with failure:
     *       * if there is no retry left - the activity will be completed.
     *       * if there are more retries left - the activity will be paused.
     *     For long-running activities:
     *     - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
     *     - The activity should respond to the cancellation accordingly.
     *
     *     Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['PauseActivity2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * ResetActivity resets the execution of an activity specified by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be reset.
     * @description Resetting an activity means:
     *     * number of attempts will be reset to 0.
     *     * activity timeouts will be reset.
     *     * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
     *        it will be scheduled immediately (* see 'jitter' flag),
     *
     *     Flags:
     *
     *     'jitter': the activity will be scheduled at a random time within the jitter duration.
     *     If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
     *     'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
     *     'keep_paused': if the activity is paused, it will remain paused.
     *
     *     Returns a `NotFound` error if there is no pending activity with the provided ID or type.
     */
    post: operations['ResetActivity2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/unpause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * UnpauseActivity unpauses the execution of an activity specified by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be unpaused.
     * @description If activity is not paused, this call will have no effect.
     *     If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
     *     Once the activity is unpaused, all timeout timers will be regenerated.
     *
     *     Flags:
     *     'jitter': the activity will be scheduled at a random time within the jitter duration.
     *     'reset_attempts': the number of attempts will be reset.
     *     'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
     *
     *     Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['UnpauseActivity2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/activities/update-options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be updated. */
    post: operations['UpdateActivityOptions2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/archived-workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
    get: operations['ListArchivedWorkflowExecutions2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/batch-operations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListBatchOperations returns a list of batch operations */
    get: operations['ListBatchOperations2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/batch-operations/{jobId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeBatchOperation returns the information about a batch operation */
    get: operations['DescribeBatchOperation2'];
    put?: never;
    /** StartBatchOperation starts a new batch operation */
    post: operations['StartBatchOperation2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/batch-operations/{jobId}/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** StopBatchOperation stops a batch operation */
    post: operations['StopBatchOperation2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/current-deployment/{deployment.seriesName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Sets a deployment as the current deployment for its deployment series. Can optionally update
     *     the metadata of the deployment as well.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`. */
    post: operations['SetCurrentDeployment2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/current-deployment/{seriesName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the current deployment (and its info) for a given deployment series.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`. */
    get: operations['GetCurrentDeployment2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/deployments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists worker deployments in the namespace. Optionally can filter based on deployment series
     *     name.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced with `ListWorkerDeployments`. */
    get: operations['ListDeployments2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Describes a worker deployment.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced with `DescribeWorkerDeploymentVersion`. */
    get: operations['DescribeDeployment2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}/reachability': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the reachability level of a worker deployment to help users decide when it is time
     *     to decommission a deployment. Reachability level is calculated based on the deployment's
     *     `status` and existing workflows that depend on the given deployment for their execution.
     *     Calculating reachability is relatively expensive. Therefore, server might return a recently
     *     cached value. In such a case, the `last_update_time` will inform you about the actual
     *     reachability calculation time.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`. */
    get: operations['GetDeploymentReachability2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/schedules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all schedules in a namespace. */
    get: operations['ListSchedules2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the schedule description and current state of an existing schedule. */
    get: operations['DescribeSchedule2'];
    put?: never;
    /** Creates a new schedule. */
    post: operations['CreateSchedule2'];
    /** Deletes a schedule, removing it from the system. */
    delete: operations['DeleteSchedule2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/matching-times': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists matching times within a range. */
    get: operations['ListScheduleMatchingTimes2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/patch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Makes a specific change to a schedule or triggers an immediate action. */
    post: operations['PatchSchedule2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/schedules/{scheduleId}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Changes the configuration or state of an existing schedule. */
    post: operations['UpdateSchedule2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/search-attributes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListSearchAttributes returns comprehensive information about search attributes. */
    get: operations['ListSearchAttributes2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue.name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
     *       - List of pollers
     *       - Workflow Reachability status
     *       - Backlog info for Workflow and/or Activity tasks */
    get: operations['DescribeTaskQueue2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/update-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Updates task queue configuration.
     *     For the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,
     *     which uncouples the rate limit from the worker lifecycle.
     *     If the overall queue rate limit is unset, the worker-set rate limit takes effect. */
    post: operations['UpdateTaskQueueConfig2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Deprecated. Use `GetWorkerVersioningRules`.
     *     Fetches the worker build id versioning sets for a task queue. */
    get: operations['GetWorkerBuildIdCompatibility2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Fetches the Build ID assignment and redirect rules for a Task Queue.
     *     WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly. */
    get: operations['GetWorkerVersioningRules2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateNamespace is used to update the information and configuration of a registered
     *     namespace. */
    post: operations['UpdateNamespace2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Describes a worker deployment version.
     *     Experimental. This API might significantly change or be removed in a future release. */
    get: operations['DescribeWorkerDeploymentVersion2'];
    put?: never;
    post?: never;
    /** Used for manual deletion of Versions. User can delete a Version only when all the
     *     following conditions are met:
     *      - It is not the Current or Ramping Version of its Deployment.
     *      - It has no active pollers (none of the task queues in the Version have pollers)
     *      - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
     *        can be skipped by passing `skip-drainage=true`.
     *     Experimental. This API might significantly change or be removed in a future release. */
    delete: operations['DeleteWorkerDeploymentVersion2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}/update-metadata': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Updates the user-given metadata attached to a Worker Deployment Version.
     *     Experimental. This API might significantly change or be removed in a future release. */
    post: operations['UpdateWorkerDeploymentVersionMetadata2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-deployments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists all Worker Deployments that are tracked in the Namespace.
     *     Experimental. This API might significantly change or be removed in a future release. */
    get: operations['ListWorkerDeployments2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Describes a Worker Deployment.
     *     Experimental. This API might significantly change or be removed in a future release. */
    get: operations['DescribeWorkerDeployment2'];
    put?: never;
    post?: never;
    /** Deletes records of (an old) Deployment. A deployment can only be deleted if
     *     it has no Version in it.
     *     Experimental. This API might significantly change or be removed in a future release. */
    delete: operations['DeleteWorkerDeployment2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
     *     Version if it is the Version being set as Current.
     *     Experimental. This API might significantly change or be removed in a future release. */
    post: operations['SetWorkerDeploymentCurrentVersion2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
     *     gradual ramp to unversioned workers too.
     *     Experimental. This API might significantly change or be removed in a future release. */
    post: operations['SetWorkerDeploymentRampingVersion2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/worker-task-reachability': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Deprecated. Use `DescribeTaskQueue`.
     * @description Fetches task reachability to determine whether a worker may be retired.
     *     The request may specify task queues to query for or let the server fetch all task queues mapped to the given
     *     build IDs.
     *
     *     When requesting a large number of task queues or all task queues associated with the given build ids in a
     *     namespace, all task queues will be listed in the response but some of them may not contain reachability
     *     information due to a server enforced limit. When reaching the limit, task queues that reachability information
     *     could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
     *     another call to get the reachability for those task queues.
     *
     *     Open source users can adjust this limit by setting the server's dynamic config value for
     *     `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
     */
    get: operations['GetWorkerTaskReachability2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListWorkers is a visibility API to list worker status information in a specific namespace. */
    get: operations['ListWorkers2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workers/describe/{workerInstanceKey}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeWorker returns information about the specified worker. */
    get: operations['DescribeWorker2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workers/fetch-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** FetchWorkerConfig returns the worker configuration for a specific worker. */
    post: operations['FetchWorkerConfig2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workers/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** WorkerHeartbeat receive heartbeat request from the worker. */
    post: operations['RecordWorkerHeartbeat2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workers/update-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateWorkerConfig updates the worker configuration of one or more workers.
     *     Can be used to partially update the worker configuration.
     *     Can be used to update the configuration of multiple workers. */
    post: operations['UpdateWorkerConfig2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflow-count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
    get: operations['CountWorkflowExecutions2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflow-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Return all namespace workflow rules */
    get: operations['ListWorkflowRules2'];
    put?: never;
    /** Create a new workflow rule. The rules are used to control the workflow execution.
     *     The rule will be applied to all running and new workflows in the namespace.
     *     If the rule with such ID already exist this call will fail
     *     Note: the rules are part of namespace configuration and will be stored in the namespace config.
     *     Namespace config is eventually consistent. */
    post: operations['CreateWorkflowRule2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflow-rules/{ruleId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeWorkflowRule return the rule specification for existing rule id.
     *     If there is no rule with such id - NOT FOUND error will be returned. */
    get: operations['DescribeWorkflowRule2'];
    put?: never;
    post?: never;
    /** Delete rule by rule id */
    delete: operations['DeleteWorkflowRule2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
    get: operations['ListWorkflowExecutions2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/execute-multi-operation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * ExecuteMultiOperation executes multiple operations within a single workflow.
     * @description Operations are started atomically, meaning if *any* operation fails to be started, none are,
     *     and the request fails. Upon start, the API returns only when *all* operations have a response.
     *
     *     Upon failure, it returns `MultiOperationExecutionFailure` where the status code
     *     equals the status code of the *first* operation that failed to be started.
     *
     *     NOTE: Experimental API.
     */
    post: operations['ExecuteMultiOperation2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeWorkflowExecution returns information about the specified workflow execution. */
    get: operations['DescribeWorkflowExecution2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
     *     `NotFound` if the specified workflow execution is unknown to the service. */
    get: operations['GetWorkflowExecutionHistory2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/history-reverse': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
     *     order (starting from last event). Fails with`NotFound` if the specified workflow execution is
     *     unknown to the service. */
    get: operations['GetWorkflowExecutionHistoryReverse2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/query/{query.queryType}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** QueryWorkflow requests a query be executed for a specified workflow execution. */
    post: operations['QueryWorkflow2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/trigger-rule': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** TriggerWorkflowRule allows to:
     *      * trigger existing rule for a specific workflow execution;
     *      * trigger rule for a specific workflow execution without creating a rule;
     *     This is useful for one-off operations. */
    post: operations['TriggerWorkflowRule2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
     *     a workflow execution.
     * @description This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
     *     workflow history and a new workflow task created for the workflow. It returns success if the requested
     *     workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
     */
    post: operations['RequestCancelWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** ResetWorkflowExecution will reset an existing workflow execution to a specified
     *     `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
     *     execution instance.
     *     TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out? */
    post: operations['ResetWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/signal/{signalName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * SignalWorkflowExecution is used to send a signal to a running workflow execution.
     * @description This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
     *     task being created for the execution.
     */
    post: operations['SignalWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** TerminateWorkflowExecution terminates an existing workflow execution by recording a
     *     `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
     *     execution instance. */
    post: operations['TerminateWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update-options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution. */
    post: operations['UpdateWorkflowExecutionOptions2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update/{request.input.name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Invokes the specified Update function on user Workflow code. */
    post: operations['UpdateWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * StartWorkflowExecution starts a new workflow execution.
     * @description It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
     *     also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
     *     instance already exists with same workflow id.
     */
    post: operations['StartWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
     *     it isn't yet started.
     * @description If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
     *     and a workflow task is generated.
     *
     *     If the workflow is not running or not found, then the workflow is created with
     *     `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
     *     workflow task is generated.
     */
    post: operations['SignalWithStartWorkflowExecution2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/nexus/endpoints': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
     *     next_page_token field of the previous response to get the next page of results. An empty next_page_token
     *     indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
     *     earlier than the previous page's last endpoint's ID may be missed. */
    get: operations['ListNexusEndpoints2'];
    put?: never;
    /** Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
     *     ALREADY_EXISTS.
     *     Returns the created endpoint with its initial version. You may use this version for subsequent updates. */
    post: operations['CreateNexusEndpoint2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/nexus/endpoints/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
    get: operations['GetNexusEndpoint2'];
    put?: never;
    post?: never;
    /** Delete an incoming Nexus service by ID. */
    delete: operations['DeleteNexusEndpoint2'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/nexus/endpoints/{id}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
     *     `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
     *     match.
     *     Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
     *     need to increment the version yourself. The server will increment the version for you after each update. */
    post: operations['UpdateNexusEndpoint2'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/v1/system-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetSystemInfo returns information about the system. */
    get: operations['GetSystemInfo2'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetClusterInfo returns information about temporal cluster */
    get: operations['GetClusterInfo'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/namespaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListNamespaces returns the information and configuration for all namespaces. */
    get: operations['ListNamespaces'];
    put?: never;
    /**
     * RegisterNamespace creates a new namespace which can be used as a container for all resources.
     * @description A Namespace is a top level entity within Temporal, and is used as a container for resources
     *     like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
     *     isolation for all resources within the namespace. All resources belongs to exactly one
     *     namespace.
     */
    post: operations['RegisterNamespace'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/namespaces/{namespace}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeNamespace returns the information and configuration for a registered namespace. */
    get: operations['DescribeNamespace'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/namespaces/{namespace}/search-attributes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListSearchAttributes returns comprehensive information about search attributes. */
    get: operations['ListSearchAttributes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/namespaces/{namespace}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateNamespace is used to update the information and configuration of a registered
     *     namespace. */
    post: operations['UpdateNamespace'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/nexus/endpoints': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the
     *     next_page_token field of the previous response to get the next page of results. An empty next_page_token
     *     indicates that there are no more results. During pagination, a newly added service with an ID lexicographically
     *     earlier than the previous page's last endpoint's ID may be missed. */
    get: operations['ListNexusEndpoints'];
    put?: never;
    /** Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of
     *     ALREADY_EXISTS.
     *     Returns the created endpoint with its initial version. You may use this version for subsequent updates. */
    post: operations['CreateNexusEndpoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/nexus/endpoints/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates. */
    get: operations['GetNexusEndpoint'];
    put?: never;
    post?: never;
    /** Delete an incoming Nexus service by ID. */
    delete: operations['DeleteNexusEndpoint'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/cluster/nexus/endpoints/{id}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or
     *     `ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not
     *     match.
     *     Returns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't
     *     need to increment the version yourself. The server will increment the version for you after each update. */
    post: operations['UpdateNexusEndpoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RespondActivityTaskFailed is called by workers when processing an activity task fails.
     * @description This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
     *     and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *     no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCanceled'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/cancel-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskCanceled`. This version allows clients to record failures by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RespondActivityTaskCanceledById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RespondActivityTaskCompleted is called by workers when they successfully complete an activity
     *     task.
     * @description This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
     *     and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
     *     no longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskCompleted'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/complete-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskCompleted`. This version allows clients to record completions by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RespondActivityTaskCompletedById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/fail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RespondActivityTaskFailed is called by workers when processing an activity task fails.
     * @description This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
     *     a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
     *     longer valid due to activity timeout, already being completed, or never having existed.
     */
    post: operations['RespondActivityTaskFailed'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/fail-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskFailed`. This version allows clients to record failures by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RespondActivityTaskFailedById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
     * @description If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
     *     then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
     *     the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
     *     such situations, in that event, the SDK should request cancellation of the activity.
     */
    post: operations['RecordActivityTaskHeartbeat'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/heartbeat-by-id': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
     *     namespace/workflow id/activity id instead of task token. */
    post: operations['RecordActivityTaskHeartbeatById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/pause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * PauseActivity pauses the execution of an activity specified by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be paused
     * @description Pausing an activity means:
     *     - If the activity is currently waiting for a retry or is running and subsequently fails,
     *       it will not be rescheduled until it is unpaused.
     *     - If the activity is already paused, calling this method will have no effect.
     *     - If the activity is running and finishes successfully, the activity will be completed.
     *     - If the activity is running and finishes with failure:
     *       * if there is no retry left - the activity will be completed.
     *       * if there are more retries left - the activity will be paused.
     *     For long-running activities:
     *     - activities in paused state will send a cancellation with "activity_paused" set to 'true' in response to 'RecordActivityTaskHeartbeat'.
     *     - The activity should respond to the cancellation accordingly.
     *
     *     Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['PauseActivity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * ResetActivity resets the execution of an activity specified by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be reset.
     * @description Resetting an activity means:
     *     * number of attempts will be reset to 0.
     *     * activity timeouts will be reset.
     *     * if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:
     *        it will be scheduled immediately (* see 'jitter' flag),
     *
     *     Flags:
     *
     *     'jitter': the activity will be scheduled at a random time within the jitter duration.
     *     If the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.
     *     'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.
     *     'keep_paused': if the activity is paused, it will remain paused.
     *
     *     Returns a `NotFound` error if there is no pending activity with the provided ID or type.
     */
    post: operations['ResetActivity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/unpause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * UnpauseActivity unpauses the execution of an activity specified by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be unpaused.
     * @description If activity is not paused, this call will have no effect.
     *     If the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).
     *     Once the activity is unpaused, all timeout timers will be regenerated.
     *
     *     Flags:
     *     'jitter': the activity will be scheduled at a random time within the jitter duration.
     *     'reset_attempts': the number of attempts will be reset.
     *     'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.
     *
     *     Returns a `NotFound` error if there is no pending activity with the provided ID or type
     */
    post: operations['UnpauseActivity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/activities/update-options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.
     *     If there are multiple pending activities of the provided type - all of them will be updated. */
    post: operations['UpdateActivityOptions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/archived-workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace. */
    get: operations['ListArchivedWorkflowExecutions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/batch-operations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListBatchOperations returns a list of batch operations */
    get: operations['ListBatchOperations'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/batch-operations/{jobId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeBatchOperation returns the information about a batch operation */
    get: operations['DescribeBatchOperation'];
    put?: never;
    /** StartBatchOperation starts a new batch operation */
    post: operations['StartBatchOperation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/batch-operations/{jobId}/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** StopBatchOperation stops a batch operation */
    post: operations['StopBatchOperation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/current-deployment/{deployment.seriesName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Sets a deployment as the current deployment for its deployment series. Can optionally update
     *     the metadata of the deployment as well.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced by `SetWorkerDeploymentCurrentVersion`. */
    post: operations['SetCurrentDeployment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/current-deployment/{seriesName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the current deployment (and its info) for a given deployment series.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`. */
    get: operations['GetCurrentDeployment'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/deployments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists worker deployments in the namespace. Optionally can filter based on deployment series
     *     name.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced with `ListWorkerDeployments`. */
    get: operations['ListDeployments'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Describes a worker deployment.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced with `DescribeWorkerDeploymentVersion`. */
    get: operations['DescribeDeployment'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}/reachability': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the reachability level of a worker deployment to help users decide when it is time
     *     to decommission a deployment. Reachability level is calculated based on the deployment's
     *     `status` and existing workflows that depend on the given deployment for their execution.
     *     Calculating reachability is relatively expensive. Therefore, server might return a recently
     *     cached value. In such a case, the `last_update_time` will inform you about the actual
     *     reachability calculation time.
     *     Experimental. This API might significantly change or be removed in a future release.
     *     Deprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`. */
    get: operations['GetDeploymentReachability'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/schedules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all schedules in a namespace. */
    get: operations['ListSchedules'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/schedules/{scheduleId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the schedule description and current state of an existing schedule. */
    get: operations['DescribeSchedule'];
    put?: never;
    /** Creates a new schedule. */
    post: operations['CreateSchedule'];
    /** Deletes a schedule, removing it from the system. */
    delete: operations['DeleteSchedule'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/schedules/{scheduleId}/matching-times': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists matching times within a range. */
    get: operations['ListScheduleMatchingTimes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/schedules/{scheduleId}/patch': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Makes a specific change to a schedule or triggers an immediate action. */
    post: operations['PatchSchedule'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/schedules/{scheduleId}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Changes the configuration or state of an existing schedule. */
    post: operations['UpdateSchedule'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/task-queues/{taskQueue.name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:
     *       - List of pollers
     *       - Workflow Reachability status
     *       - Backlog info for Workflow and/or Activity tasks */
    get: operations['DescribeTaskQueue'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/task-queues/{taskQueue}/update-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Updates task queue configuration.
     *     For the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,
     *     which uncouples the rate limit from the worker lifecycle.
     *     If the overall queue rate limit is unset, the worker-set rate limit takes effect. */
    post: operations['UpdateTaskQueueConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Deprecated. Use `GetWorkerVersioningRules`.
     *     Fetches the worker build id versioning sets for a task queue. */
    get: operations['GetWorkerBuildIdCompatibility'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Fetches the Build ID assignment and redirect rules for a Task Queue.
     *     WARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly. */
    get: operations['GetWorkerVersioningRules'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Describes a worker deployment version.
     *     Experimental. This API might significantly change or be removed in a future release. */
    get: operations['DescribeWorkerDeploymentVersion'];
    put?: never;
    post?: never;
    /** Used for manual deletion of Versions. User can delete a Version only when all the
     *     following conditions are met:
     *      - It is not the Current or Ramping Version of its Deployment.
     *      - It has no active pollers (none of the task queues in the Version have pollers)
     *      - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
     *        can be skipped by passing `skip-drainage=true`.
     *     Experimental. This API might significantly change or be removed in a future release. */
    delete: operations['DeleteWorkerDeploymentVersion'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}/update-metadata': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Updates the user-given metadata attached to a Worker Deployment Version.
     *     Experimental. This API might significantly change or be removed in a future release. */
    post: operations['UpdateWorkerDeploymentVersionMetadata'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-deployments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists all Worker Deployments that are tracked in the Namespace.
     *     Experimental. This API might significantly change or be removed in a future release. */
    get: operations['ListWorkerDeployments'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-deployments/{deploymentName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Describes a Worker Deployment.
     *     Experimental. This API might significantly change or be removed in a future release. */
    get: operations['DescribeWorkerDeployment'];
    put?: never;
    post?: never;
    /** Deletes records of (an old) Deployment. A deployment can only be deleted if
     *     it has no Version in it.
     *     Experimental. This API might significantly change or be removed in a future release. */
    delete: operations['DeleteWorkerDeployment'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping
     *     Version if it is the Version being set as Current.
     *     Experimental. This API might significantly change or be removed in a future release. */
    post: operations['SetWorkerDeploymentCurrentVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for
     *     gradual ramp to unversioned workers too.
     *     Experimental. This API might significantly change or be removed in a future release. */
    post: operations['SetWorkerDeploymentRampingVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/worker-task-reachability': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Deprecated. Use `DescribeTaskQueue`.
     * @description Fetches task reachability to determine whether a worker may be retired.
     *     The request may specify task queues to query for or let the server fetch all task queues mapped to the given
     *     build IDs.
     *
     *     When requesting a large number of task queues or all task queues associated with the given build ids in a
     *     namespace, all task queues will be listed in the response but some of them may not contain reachability
     *     information due to a server enforced limit. When reaching the limit, task queues that reachability information
     *     could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
     *     another call to get the reachability for those task queues.
     *
     *     Open source users can adjust this limit by setting the server's dynamic config value for
     *     `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
     */
    get: operations['GetWorkerTaskReachability'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListWorkers is a visibility API to list worker status information in a specific namespace. */
    get: operations['ListWorkers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workers/describe/{workerInstanceKey}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeWorker returns information about the specified worker. */
    get: operations['DescribeWorker'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workers/fetch-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** FetchWorkerConfig returns the worker configuration for a specific worker. */
    post: operations['FetchWorkerConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workers/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** WorkerHeartbeat receive heartbeat request from the worker. */
    post: operations['RecordWorkerHeartbeat'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workers/update-config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateWorkerConfig updates the worker configuration of one or more workers.
     *     Can be used to partially update the worker configuration.
     *     Can be used to update the configuration of multiple workers. */
    post: operations['UpdateWorkerConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflow-count': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace. */
    get: operations['CountWorkflowExecutions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflow-rules': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Return all namespace workflow rules */
    get: operations['ListWorkflowRules'];
    put?: never;
    /** Create a new workflow rule. The rules are used to control the workflow execution.
     *     The rule will be applied to all running and new workflows in the namespace.
     *     If the rule with such ID already exist this call will fail
     *     Note: the rules are part of namespace configuration and will be stored in the namespace config.
     *     Namespace config is eventually consistent. */
    post: operations['CreateWorkflowRule'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflow-rules/{ruleId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeWorkflowRule return the rule specification for existing rule id.
     *     If there is no rule with such id - NOT FOUND error will be returned. */
    get: operations['DescribeWorkflowRule'];
    put?: never;
    post?: never;
    /** Delete rule by rule id */
    delete: operations['DeleteWorkflowRule'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace. */
    get: operations['ListWorkflowExecutions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/execute-multi-operation': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * ExecuteMultiOperation executes multiple operations within a single workflow.
     * @description Operations are started atomically, meaning if *any* operation fails to be started, none are,
     *     and the request fails. Upon start, the API returns only when *all* operations have a response.
     *
     *     Upon failure, it returns `MultiOperationExecutionFailure` where the status code
     *     equals the status code of the *first* operation that failed to be started.
     *
     *     NOTE: Experimental API.
     */
    post: operations['ExecuteMultiOperation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{execution.workflowId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** DescribeWorkflowExecution returns information about the specified workflow execution. */
    get: operations['DescribeWorkflowExecution'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{execution.workflowId}/history': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
     *     `NotFound` if the specified workflow execution is unknown to the service. */
    get: operations['GetWorkflowExecutionHistory'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{execution.workflowId}/history-reverse': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse
     *     order (starting from last event). Fails with`NotFound` if the specified workflow execution is
     *     unknown to the service. */
    get: operations['GetWorkflowExecutionHistoryReverse'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{execution.workflowId}/query/{query.queryType}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** QueryWorkflow requests a query be executed for a specified workflow execution. */
    post: operations['QueryWorkflow'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{execution.workflowId}/trigger-rule': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** TriggerWorkflowRule allows to:
     *      * trigger existing rule for a specific workflow execution;
     *      * trigger rule for a specific workflow execution without creating a rule;
     *     This is useful for one-off operations. */
    post: operations['TriggerWorkflowRule'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
     *     a workflow execution.
     * @description This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
     *     workflow history and a new workflow task created for the workflow. It returns success if the requested
     *     workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
     */
    post: operations['RequestCancelWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/reset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** ResetWorkflowExecution will reset an existing workflow execution to a specified
     *     `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
     *     execution instance.
     *     TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out? */
    post: operations['ResetWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/signal/{signalName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * SignalWorkflowExecution is used to send a signal to a running workflow execution.
     * @description This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
     *     task being created for the execution.
     */
    post: operations['SignalWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/terminate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** TerminateWorkflowExecution terminates an existing workflow execution by recording a
     *     `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
     *     execution instance. */
    post: operations['TerminateWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update-options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution. */
    post: operations['UpdateWorkflowExecutionOptions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update/{request.input.name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Invokes the specified Update function on user Workflow code. */
    post: operations['UpdateWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * StartWorkflowExecution starts a new workflow execution.
     * @description It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
     *     also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
     *     instance already exists with same workflow id.
     */
    post: operations['StartWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
     *     it isn't yet started.
     * @description If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
     *     and a workflow task is generated.
     *
     *     If the workflow is not running or not found, then the workflow is created with
     *     `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
     *     workflow task is generated.
     */
    post: operations['SignalWithStartWorkflowExecution'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/system-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** GetSystemInfo returns information about the system. */
    get: operations['GetSystemInfo'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    CallbackInfoTrigger: {
      workflowClosed?: components['schemas']['CallbackInfoWorkflowClosed'];
    };
    /** @description Trigger for when the workflow is closed. */
    CallbackInfoWorkflowClosed: Record<string, never>;
    /** @description Callbacks to be delivered internally within the system.
     *     This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.
     *     The only reason that this is exposed is because callbacks are replicated across clusters via the
     *     WorkflowExecutionStarted event, which is defined in the public API. */
    CallbackInternal: {
      /**
       * Format: byte
       * @description Opaque internal data.
       */
      data?: string;
    };
    CallbackNexus: {
      /** @description Callback URL. */
      url?: string;
      /** @description Header to attach to callback request. */
      header?: {
        [key: string]: string;
      };
    };
    CountWorkflowExecutionsResponseAggregationGroup: {
      groupValues?: components['schemas']['v1Payload'][];
      /** Format: int64 */
      count?: string;
    };
    DeploymentInfoTaskQueueInfo: {
      name?: string;
      type?: components['schemas']['v1TaskQueueType'];
      /**
       * Format: date-time
       * @description When server saw the first poller for this task queue in this deployment.
       */
      firstPollerTime?: string;
    };
    DescribeTaskQueueResponseEffectiveRateLimit: {
      /**
       * Format: float
       * @description The effective rate limit for the task queue.
       */
      requestsPerSecond?: number;
      rateLimitSource?: components['schemas']['v1RateLimitSource'];
    };
    DescribeWorkerDeploymentVersionResponseVersionTaskQueue: {
      name?: string;
      type?: components['schemas']['v1TaskQueueType'];
      stats?: components['schemas']['v1TaskQueueStats'];
      /** @description Task queue stats breakdown by priority key. Only contains actively used priority keys.
       *     Only set if `report_task_queue_stats` is set to true in the request. */
      statsByPriorityKey?: {
        [key: string]: components['schemas']['v1TaskQueueStats'];
      };
    };
    /** @description Target an external server by URL.
     *     At a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected
     *     into the server to modify the request. */
    EndpointTargetExternal: {
      /** @description URL to call. */
      url?: string;
    };
    /** @description Target a worker polling on a Nexus task queue in a specific namespace. */
    EndpointTargetWorker: {
      /** @description Namespace to route requests to. */
      namespace?: string;
      /** @description Nexus task queue to route requests to. */
      taskQueue?: string;
    };
    ExecuteMultiOperationRequestOperation: {
      startWorkflow?: components['schemas']['v1StartWorkflowExecutionRequest'];
      updateWorkflow?: components['schemas']['v1UpdateWorkflowExecutionRequest'];
    };
    /** @description A link to a built-in batch job.
     *     Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).
     *     This link can be put on workflow history events generated by actions taken by a batch job. */
    LinkBatchJob: {
      jobId?: string;
    };
    LinkWorkflowEvent: {
      namespace?: string;
      workflowId?: string;
      runId?: string;
      eventRef?: components['schemas']['WorkflowEventEventReference'];
      requestIdRef?: components['schemas']['WorkflowEventRequestIdReference'];
    };
    /** A subset of WorkerDeploymentInfo */
    ListWorkerDeploymentsResponseWorkerDeploymentSummary: {
      name?: string;
      /** Format: date-time */
      createTime?: string;
      routingConfig?: components['schemas']['v1RoutingConfig'];
      latestVersionSummary?: components['schemas']['WorkerDeploymentInfoWorkerDeploymentVersionSummary'];
      currentVersionSummary?: components['schemas']['WorkerDeploymentInfoWorkerDeploymentVersionSummary'];
      rampingVersionSummary?: components['schemas']['WorkerDeploymentInfoWorkerDeploymentVersionSummary'];
    };
    OperatorServiceUpdateNexusEndpointBody: {
      /**
       * Format: int64
       * @description Data version for this endpoint. Must match current version.
       */
      version?: string;
      spec?: components['schemas']['v1EndpointSpec'];
    };
    PauseInfoManual: {
      /** @description The identity of the actor that paused the activity. */
      identity?: string;
      /** @description Reason for pausing the activity. */
      reason?: string;
    };
    PauseInfoRule: {
      /** @description The rule that paused the activity. */
      ruleId?: string;
      /** @description The identity of the actor that created the rule. */
      identity?: string;
      /** @description Reason why rule was created. Populated from rule description. */
      reason?: string;
    };
    PendingActivityInfoPauseInfo: {
      /**
       * Format: date-time
       * @description The time when the activity was paused.
       */
      pauseTime?: string;
      manual?: components['schemas']['PauseInfoManual'];
      rule?: components['schemas']['PauseInfoRule'];
    };
    /** @description SignalWorkflow represents sending a signal after a workflow reset.
     *     Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest. */
    PostResetOperationSignalWorkflow: {
      /** @description The workflow author-defined name of the signal to send to the workflow. */
      signalName?: string;
      input?: components['schemas']['v1Payloads'];
      header?: components['schemas']['v1Header'];
      /** @description Links to be associated with the WorkflowExecutionSignaled event. */
      links?: components['schemas']['apicommonv1Link'][];
    };
    /** @description UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
     *     Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest. */
    PostResetOperationUpdateWorkflowOptions: {
      workflowExecutionOptions?: components['schemas']['v1WorkflowExecutionOptions'];
      /** @description Controls which fields from `workflow_execution_options` will be applied.
       *     To unset a field, set it to null and use the update mask to indicate that it should be mutated. */
      updateMask?: string;
    };
    /** @description The operation will complete asynchronously.
     *     The returned ID can be used to reference this operation. */
    StartOperationResponseAsync: {
      /** @description Deprecated. Renamed to operation_token. */
      operationId?: string;
      links?: components['schemas']['apinexusv1Link'][];
      operationToken?: string;
    };
    /** @description An operation completed successfully. */
    StartOperationResponseSync: {
      payload?: components['schemas']['v1Payload'];
      links?: components['schemas']['apinexusv1Link'][];
    };
    UpdateTaskQueueConfigRequestRateLimitUpdate: {
      rateLimit?: components['schemas']['v1RateLimit'];
      /** @description Reason for why the rate limit was set. */
      reason?: string;
    };
    UpdateWorkerBuildIdCompatibilityRequestAddNewCompatibleVersion: {
      /** @description A new id to be added to an existing compatible set. */
      newBuildId?: string;
      /** @description A build id which must already exist in the version sets known by the task queue. The new
       *     id will be stored in the set containing this id, marking it as compatible with
       *     the versions within. */
      existingCompatibleBuildId?: string;
      /** @description When set, establishes the compatible set being targeted as the overall default for the
       *     queue. If a different set was the current default, the targeted set will replace it as
       *     the new default. */
      makeSetDefault?: boolean;
    };
    UpdateWorkerBuildIdCompatibilityRequestMergeSets: {
      /** A build ID in the set whose default will become the merged set default */
      primarySetBuildId?: string;
      /** A build ID in the set which will be merged into the primary set */
      secondarySetBuildId?: string;
    };
    /** @description Adds the rule to the list of redirect rules for this Task Queue. There
     *     can be at most one redirect rule for each distinct Source Build ID. */
    UpdateWorkerVersioningRulesRequestAddCompatibleBuildIdRedirectRule: {
      rule?: components['schemas']['v1CompatibleBuildIdRedirectRule'];
    };
    /** @description This command is intended to be used to complete the rollout of a Build
     *     ID and cleanup unnecessary rules possibly created during a gradual
     *     rollout. Specifically, this command will make the following changes
     *     atomically:
     *      1. Adds an assignment rule (with full ramp) for the target Build ID at
     *         the end of the list.
     *      2. Removes all previously added assignment rules to the given target
     *         Build ID (if any).
     *      3. Removes any fully-ramped assignment rule for other Build IDs. */
    UpdateWorkerVersioningRulesRequestCommitBuildId: {
      targetBuildId?: string;
      /** @description To prevent committing invalid Build IDs, we reject the request if no
       *     pollers has been seen recently for this Build ID. Use the `force`
       *     option to disable this validation. */
      force?: boolean;
    };
    UpdateWorkerVersioningRulesRequestDeleteBuildIdAssignmentRule: {
      /** Format: int32 */
      ruleIndex?: number;
      /** By default presence of one unconditional rule is enforced, otherwise
       *     the delete operation will be rejected. Set `force` to true to
       *     bypass this validation. An unconditional assignment rule:
       *       - Has no hint filter
       *       - Has no ramp */
      force?: boolean;
    };
    UpdateWorkerVersioningRulesRequestDeleteCompatibleBuildIdRedirectRule: {
      sourceBuildId?: string;
    };
    /** @description Inserts the rule to the list of assignment rules for this Task Queue.
     *     The rules are evaluated in order, starting from index 0. The first
     *     applicable rule will be applied and the rest will be ignored. */
    UpdateWorkerVersioningRulesRequestInsertBuildIdAssignmentRule: {
      /**
       * Format: int32
       * @description Use this option to insert the rule in a particular index. By
       *     default, the new rule is inserted at the beginning of the list
       *     (index 0). If the given index is too larger the rule will be
       *     inserted at the end of the list.
       */
      ruleIndex?: number;
      rule?: components['schemas']['v1BuildIdAssignmentRule'];
    };
    /** @description Replaces the assignment rule at a given index. */
    UpdateWorkerVersioningRulesRequestReplaceBuildIdAssignmentRule: {
      /** Format: int32 */
      ruleIndex?: number;
      rule?: components['schemas']['v1BuildIdAssignmentRule'];
      /** By default presence of one unconditional rule is enforced, otherwise
       *     the replace operation will be rejected. Set `force` to true to
       *     bypass this validation. An unconditional assignment rule:
       *       - Has no hint filter
       *       - Has no ramp */
      force?: boolean;
    };
    /** @description Replaces the routing rule with the given source Build ID. */
    UpdateWorkerVersioningRulesRequestReplaceCompatibleBuildIdRedirectRule: {
      rule?: components['schemas']['v1CompatibleBuildIdRedirectRule'];
    };
    VersioningOverridePinnedOverride: {
      behavior?: components['schemas']['VersioningOverridePinnedOverrideBehavior'];
      version?: components['schemas']['v1WorkerDeploymentVersion'];
    };
    /**
     * @description Used to specify different sub-types of Pinned override that we plan to add in the future.
     *
     *      - PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED: Unspecified.
     *      - PINNED_OVERRIDE_BEHAVIOR_PINNED: Override workflow behavior to be Pinned.
     * @default PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED
     * @enum {string}
     */
    VersioningOverridePinnedOverrideBehavior:
      | 'PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED'
      | 'PINNED_OVERRIDE_BEHAVIOR_PINNED';
    WorkerConfigAutoscalingPollerBehavior: {
      /**
       * Format: int32
       * @description At least this many poll calls will always be attempted (assuming slots are available).
       *     Cannot be zero.
       */
      minPollers?: number;
      /**
       * Format: int32
       * @description At most this many poll calls will ever be open at once. Must be >= `minimum`.
       */
      maxPollers?: number;
      /**
       * Format: int32
       * @description This many polls will be attempted initially before scaling kicks in. Must be between
       *      `minimum` and `maximum`.
       */
      initialPollers?: number;
    };
    WorkerConfigSimplePollerBehavior: {
      /** Format: int32 */
      maxPollers?: number;
    };
    WorkerDeploymentInfoWorkerDeploymentVersionSummary: {
      /** @description Deprecated. Use `deployment_version`. */
      version?: string;
      status?: components['schemas']['v1WorkerDeploymentVersionStatus'];
      deploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /** Format: date-time */
      createTime?: string;
      drainageStatus?: components['schemas']['v1VersionDrainageStatus'];
      drainageInfo?: components['schemas']['v1VersionDrainageInfo'];
      /**
       * Format: date-time
       * @description Unset if not current.
       */
      currentSinceTime?: string;
      /**
       * Format: date-time
       * @description Unset if not ramping. Updated when the version first starts ramping, not on each ramp change.
       */
      rampingSinceTime?: string;
      /**
       * Format: date-time
       * @description Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
       */
      routingUpdateTime?: string;
      /**
       * Format: date-time
       * @description Timestamp when this version first became current or ramping.
       */
      firstActivationTime?: string;
      /**
       * Format: date-time
       * @description Timestamp when this version last stopped being current or ramping.
       */
      lastDeactivationTime?: string;
    };
    WorkerDeploymentVersionInfoVersionTaskQueueInfo: {
      name?: string;
      type?: components['schemas']['v1TaskQueueType'];
    };
    /** @description EventReference is a direct reference to a history event through the event ID. */
    WorkflowEventEventReference: {
      /** Format: int64 */
      eventId?: string;
      eventType?: components['schemas']['v1EventType'];
    };
    /** @description RequestIdReference is a indirect reference to a history event through the request ID. */
    WorkflowEventRequestIdReference: {
      requestId?: string;
      eventType?: components['schemas']['v1EventType'];
    };
    WorkflowRuleActionActionActivityPause: Record<string, never>;
    /** @description Activity trigger will be triggered when an activity is about to start. */
    WorkflowRuleSpecActivityStartingTrigger: {
      /** Activity predicate is a SQL-like string filter parameter.
       *     It is used to match against workflow data.
       *     The following activity attributes are supported as part of the predicate:
       *     - ActivityType: An Activity Type is the mapping of a name to an Activity Definition..
       *     - ActivityId: The ID of the activity.
       *     - ActivityAttempt: The number attempts of the activity.
       *     - BackoffInterval: The current amount of time between scheduled attempts of the activity.
       *     - ActivityStatus: The status of the activity. Can be one of "Scheduled", "Started", "Paused".
       *     - TaskQueue: The name of the task queue the workflow specified that the activity should run on.
       *     Activity predicate support the following operators:
       *      * =, !=, >, >=, <, <=
       *      * AND, OR, ()
       *      * BETWEEN ... AND
       *        STARTS_WITH */
      predicate?: string;
    };
    WorkflowServiceCreateScheduleBody: {
      schedule?: components['schemas']['v1Schedule'];
      initialPatch?: components['schemas']['v1SchedulePatch'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description A unique identifier for this create request for idempotence. Typically UUIDv4. */
      requestId?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
    };
    WorkflowServiceCreateWorkflowRuleBody: {
      spec?: components['schemas']['v1WorkflowRuleSpec'];
      /** @description If true, the rule will be applied to the currently running workflows via batch job.
       *     If not set , the rule will only be applied when triggering condition is satisfied.
       *     visibility_query in the rule will be used to select the workflows to apply the rule to. */
      forceScan?: boolean;
      /** @description Used to de-dupe requests. Typically should be UUID. */
      requestId?: string;
      /** @description Identity of the actor who created the rule. Will be stored with the rule. */
      identity?: string;
      /** @description Rule description.Will be stored with the rule. */
      description?: string;
    };
    WorkflowServiceExecuteMultiOperationBody: {
      /** @description List of operations to execute within a single workflow.
       *
       *     Preconditions:
       *     - The list of operations must not be empty.
       *     - The workflow ids must match across operations.
       *     - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
       *
       *     Note that additional operation-specific restrictions have to be considered. */
      operations?: components['schemas']['ExecuteMultiOperationRequestOperation'][];
    };
    WorkflowServiceFetchWorkerConfigBody: {
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description Reason for sending worker command, can be used for audit purpose. */
      reason?: string;
      selector?: components['schemas']['v1WorkerSelector'];
    };
    WorkflowServicePatchScheduleBody: {
      patch?: components['schemas']['v1SchedulePatch'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description A unique identifier for this update request for idempotence. Typically UUIDv4. */
      requestId?: string;
    };
    WorkflowServicePauseActivityBody: {
      execution?: components['schemas']['v1WorkflowExecution'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description Only the activity with this ID will be paused. */
      id?: string;
      /** @description Pause all running activities of this type. */
      type?: string;
      /** @description Reason to pause the activity. */
      reason?: string;
    };
    WorkflowServiceQueryWorkflowBody: {
      /** @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
       *     uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
       *     run id as a way of saying "target the latest run of the workflow". */
      execution?: {
        runId?: string;
      };
      /** See https://docs.temporal.io/docs/concepts/queries/ */
      query?: {
        queryArgs?: components['schemas']['v1Payloads'];
        header?: components['schemas']['v1Header'];
      };
      queryRejectCondition?: components['schemas']['v1QueryRejectCondition'];
    };
    WorkflowServiceRecordActivityTaskHeartbeatBody: {
      /**
       * The task token as received in `PollActivityTaskQueueResponse`
       * Format: byte
       */
      taskToken?: string;
      details?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
    };
    WorkflowServiceRecordActivityTaskHeartbeatByIdBody: {
      /** Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** Id of the activity we're heartbeating */
      activityId?: string;
      details?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
    };
    WorkflowServiceRecordWorkerHeartbeatBody: {
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      workerHeartbeat?: components['schemas']['v1WorkerHeartbeat'][];
    };
    WorkflowServiceRequestCancelWorkflowExecutionBody: {
      /** @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
       *     uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
       *     run id as a way of saying "target the latest run of the workflow". */
      workflowExecution?: {
        runId?: string;
      };
      /** The identity of the worker/client */
      identity?: string;
      /** Used to de-dupe cancellation requests */
      requestId?: string;
      /** @description If set, this call will error if the most recent (if no run id is set on
       *     `workflow_execution`), or specified (if it is) workflow execution is not part of the same
       *     execution chain as this id. */
      firstExecutionRunId?: string;
      /** Reason for requesting the cancellation */
      reason?: string;
      /** @description Links to be associated with the WorkflowExecutionCanceled event. */
      links?: components['schemas']['apicommonv1Link'][];
    };
    /** NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities */
    WorkflowServiceResetActivityBody: {
      execution?: components['schemas']['v1WorkflowExecution'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description Only activity with this ID will be reset. */
      id?: string;
      /** @description Reset all running activities with of this type. */
      type?: string;
      /** @description Reset all running activities. */
      matchAll?: boolean;
      /** @description Indicates that activity should reset heartbeat details.
       *     This flag will be applied only to the new instance of the activity. */
      resetHeartbeat?: boolean;
      /** If activity is paused, it will remain paused after reset */
      keepPaused?: boolean;
      /** If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
       *     (unless it is paused and keep_paused is set) */
      jitter?: string;
      /** @description If set, the activity options will be restored to the defaults.
       *     Default options are then options activity was created with.
       *     They are part of the first SCHEDULE event. */
      restoreOriginalOptions?: boolean;
    };
    WorkflowServiceResetWorkflowExecutionBody: {
      /**
       * The workflow to reset. If this contains a run ID then the workflow will be reset back to the
       *     provided event ID in that run. Otherwise it will be reset to the provided event ID in the
       *     current run. In all cases the current run will be terminated and a new run started.
       * @description The workflow to reset. If this contains a run ID then the workflow will be reset back to the
       *     provided event ID in that run. Otherwise it will be reset to the provided event ID in the
       *     current run. In all cases the current run will be terminated and a new run started.
       */
      workflowExecution?: {
        runId?: string;
      };
      reason?: string;
      /**
       * Format: int64
       * @description The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
       *     `WORKFLOW_TASK_STARTED` event to reset to.
       */
      workflowTaskFinishEventId?: string;
      /** Used to de-dupe reset requests */
      requestId?: string;
      resetReapplyType?: components['schemas']['v1ResetReapplyType'];
      /** Event types not to be reapplied */
      resetReapplyExcludeTypes?: components['schemas']['v1ResetReapplyExcludeType'][];
      /** Operations to perform after the workflow has been reset. These operations will be applied
       *     to the *new* run of the workflow execution in the order they are provided.
       *     All operations are applied to the workflow before the first new workflow task is generated */
      postResetOperations?: components['schemas']['v1PostResetOperation'][];
      /** The identity of the worker/client */
      identity?: string;
    };
    WorkflowServiceRespondActivityTaskCanceledBody: {
      /**
       * The task token as received in `PollActivityTaskQueueResponse`
       * Format: byte
       */
      taskToken?: string;
      details?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
      deployment?: components['schemas']['v1Deployment'];
      deploymentOptions?: components['schemas']['v1WorkerDeploymentOptions'];
    };
    WorkflowServiceRespondActivityTaskCanceledByIdBody: {
      /** Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** Id of the activity to confirm is cancelled */
      activityId?: string;
      details?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
      deploymentOptions?: components['schemas']['v1WorkerDeploymentOptions'];
    };
    WorkflowServiceRespondActivityTaskCompletedBody: {
      /**
       * The task token as received in `PollActivityTaskQueueResponse`
       * Format: byte
       */
      taskToken?: string;
      result?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
      deployment?: components['schemas']['v1Deployment'];
      deploymentOptions?: components['schemas']['v1WorkerDeploymentOptions'];
    };
    WorkflowServiceRespondActivityTaskCompletedByIdBody: {
      /** Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** Id of the activity to complete */
      activityId?: string;
      result?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
    };
    WorkflowServiceRespondActivityTaskFailedBody: {
      /**
       * The task token as received in `PollActivityTaskQueueResponse`
       * Format: byte
       */
      taskToken?: string;
      failure?: components['schemas']['apifailurev1Failure'];
      /** The identity of the worker/client */
      identity?: string;
      lastHeartbeatDetails?: components['schemas']['v1Payloads'];
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
      deployment?: components['schemas']['v1Deployment'];
      deploymentOptions?: components['schemas']['v1WorkerDeploymentOptions'];
    };
    WorkflowServiceRespondActivityTaskFailedByIdBody: {
      /** Id of the workflow which scheduled this activity */
      workflowId?: string;
      /** Run Id of the workflow which scheduled this activity */
      runId?: string;
      /** Id of the activity to fail */
      activityId?: string;
      failure?: components['schemas']['apifailurev1Failure'];
      /** The identity of the worker/client */
      identity?: string;
      lastHeartbeatDetails?: components['schemas']['v1Payloads'];
    };
    /** [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    WorkflowServiceSetCurrentDeploymentBody: {
      /** @description `Deployment` identifies a deployment of Temporal workers. The combination of deployment series
       *     name + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker
       *     programs to specify these values.
       *     Deprecated. */
      deployment?: {
        /** @description Build ID changes with each version of the worker when the worker program code and/or config
         *     changes. */
        buildId?: string;
      };
      /** @description Optional. The identity of the client who initiated this request. */
      identity?: string;
      updateMetadata?: components['schemas']['v1UpdateDeploymentMetadata'];
    };
    /** @description Set/unset the Current Version of a Worker Deployment. */
    WorkflowServiceSetWorkerDeploymentCurrentVersionBody: {
      /** @description Deprecated. Use `build_id`. */
      version?: string;
      /** The build id of the Version that you want to set as Current.
       *     Pass an empty value to set the Current Version to nil.
       *     A nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.) */
      buildId?: string;
      /**
       * Format: byte
       * @description Optional. This can be the value of conflict_token from a Describe, or another Worker
       *     Deployment API. Passing a non-nil conflict token will cause this request to fail if the
       *     Deployment's configuration has been modified between the API call that generated the
       *     token and this one.
       */
      conflictToken?: string;
      /** @description Optional. The identity of the client who initiated this request. */
      identity?: string;
      /** @description Optional. By default this request would be rejected if not all the expected Task Queues are
       *     being polled by the new Version, to protect against accidental removal of Task Queues, or
       *     worker health issues. Pass `true` here to bypass this protection.
       *     The set of expected Task Queues is the set of all the Task Queues that were ever poller by
       *     the existing Current Version of the Deployment, with the following exclusions:
       *       - Task Queues that are not used anymore (inferred by having empty backlog and a task
       *         add_rate of 0.)
       *       - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
       *         having a different Current Version than the Current Version of this deployment.)
       *     WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
       *     needed. If the request is unexpectedly rejected due to missing pollers, then that means the
       *     pollers have not reached to the server yet. Only set this if you expect those pollers to
       *     never arrive. */
      ignoreMissingTaskQueues?: boolean;
    };
    /** @description Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. */
    WorkflowServiceSetWorkerDeploymentRampingVersionBody: {
      /** @description Deprecated. Use `build_id`. */
      version?: string;
      /** The build id of the Version that you want to ramp traffic to.
       *     Pass an empty value to set the Ramping Version to nil.
       *     A nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.) */
      buildId?: string;
      /**
       * Format: float
       * @description Ramp percentage to set. Valid range: [0,100].
       */
      percentage?: number;
      /**
       * Format: byte
       * @description Optional. This can be the value of conflict_token from a Describe, or another Worker
       *     Deployment API. Passing a non-nil conflict token will cause this request to fail if the
       *     Deployment's configuration has been modified between the API call that generated the
       *     token and this one.
       */
      conflictToken?: string;
      /** @description Optional. The identity of the client who initiated this request. */
      identity?: string;
      /** @description Optional. By default this request would be rejected if not all the expected Task Queues are
       *     being polled by the new Version, to protect against accidental removal of Task Queues, or
       *     worker health issues. Pass `true` here to bypass this protection.
       *     The set of expected Task Queues equals to all the Task Queues ever polled from the existing
       *     Current Version of the Deployment, with the following exclusions:
       *       - Task Queues that are not used anymore (inferred by having empty backlog and a task
       *         add_rate of 0.)
       *       - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
       *         having a different Current Version than the Current Version of this deployment.)
       *     WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
       *     needed. If the request is unexpectedly rejected due to missing pollers, then that means the
       *     pollers have not reached to the server yet. Only set this if you expect those pollers to
       *     never arrive.
       *     Note: this check only happens when the ramping version is about to change, not every time
       *     that the percentage changes. Also note that the check is against the deployment's Current
       *     Version, not the previous Ramping Version. */
      ignoreMissingTaskQueues?: boolean;
    };
    WorkflowServiceSignalWithStartWorkflowExecutionBody: {
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** Total workflow execution timeout including retries and continue as new */
      workflowExecutionTimeout?: string;
      /** Timeout of a single workflow run */
      workflowRunTimeout?: string;
      /** Timeout of a single workflow task */
      workflowTaskTimeout?: string;
      /** The identity of the worker/client */
      identity?: string;
      /** Used to de-dupe signal w/ start requests */
      requestId?: string;
      workflowIdReusePolicy?: components['schemas']['v1WorkflowIdReusePolicy'];
      workflowIdConflictPolicy?: components['schemas']['v1WorkflowIdConflictPolicy'];
      signalInput?: components['schemas']['v1Payloads'];
      /** @description Deprecated. */
      control?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      header?: components['schemas']['v1Header'];
      /** @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *     Note that the signal will be delivered with the first workflow task. If the workflow gets
       *     another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
       *     and the rest of the delay period will be ignored, even if that request also had a delay.
       *     Signal via SignalWorkflowExecution will not unblock the workflow. */
      workflowStartDelay?: string;
      userMetadata?: components['schemas']['v1UserMetadata'];
      /** @description Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events. */
      links?: components['schemas']['apicommonv1Link'][];
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      priority?: components['schemas']['v1Priority'];
    };
    /** @description Keep the parameters in sync with:
     *       - temporal.api.batch.v1.BatchOperationSignal.
     *       - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow. */
    WorkflowServiceSignalWorkflowExecutionBody: {
      /** @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
       *     uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
       *     run id as a way of saying "target the latest run of the workflow". */
      workflowExecution?: {
        runId?: string;
      };
      input?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
      /** Used to de-dupe sent signals */
      requestId?: string;
      /** @description Deprecated. */
      control?: string;
      header?: components['schemas']['v1Header'];
      /** @description Links to be associated with the WorkflowExecutionSignaled event. */
      links?: components['schemas']['apicommonv1Link'][];
    };
    WorkflowServiceStartBatchOperationBody: {
      /** Visibility query defines the the group of workflow to apply the batch operation
       *     This field and `executions` are mutually exclusive */
      visibilityQuery?: string;
      /** Reason to perform the batch operation */
      reason?: string;
      /** Executions to apply the batch operation
       *     This field and `visibility_query` are mutually exclusive */
      executions?: components['schemas']['v1WorkflowExecution'][];
      /**
       * Format: float
       * @description Limit for the number of operations processed per second within this batch.
       *     Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
       *     overload and minimize potential delays in executing ongoing tasks for user workers.
       *     Note that when no explicit limit is provided, the server will operate according to its limit defined by the
       *     dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
       *     server's configured limit.
       */
      maxOperationsPerSecond?: number;
      terminationOperation?: components['schemas']['v1BatchOperationTermination'];
      signalOperation?: components['schemas']['v1BatchOperationSignal'];
      cancellationOperation?: components['schemas']['v1BatchOperationCancellation'];
      deletionOperation?: components['schemas']['v1BatchOperationDeletion'];
      resetOperation?: components['schemas']['v1BatchOperationReset'];
      updateWorkflowOptionsOperation?: components['schemas']['v1BatchOperationUpdateWorkflowExecutionOptions'];
      unpauseActivitiesOperation?: components['schemas']['v1BatchOperationUnpauseActivities'];
      resetActivitiesOperation?: components['schemas']['v1BatchOperationResetActivities'];
      updateActivityOptionsOperation?: components['schemas']['v1BatchOperationUpdateActivityOptions'];
    };
    WorkflowServiceStartWorkflowExecutionBody: {
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /** The identity of the client who initiated this request */
      identity?: string;
      /** @description A unique identifier for this start request. Typically UUIDv4. */
      requestId?: string;
      workflowIdReusePolicy?: components['schemas']['v1WorkflowIdReusePolicy'];
      workflowIdConflictPolicy?: components['schemas']['v1WorkflowIdConflictPolicy'];
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      header?: components['schemas']['v1Header'];
      /** @description Request to get the first workflow task inline in the response bypassing matching service and worker polling.
       *     If set to `true` the caller is expected to have a worker available and capable of processing the task.
       *     The returned task will be marked as started and is expected to be completed by the specified
       *     `workflow_task_timeout`. */
      requestEagerExecution?: boolean;
      continuedFailure?: components['schemas']['apifailurev1Failure'];
      lastCompletionResult?: components['schemas']['v1Payloads'];
      /** @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *     If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
       *     of the delay will be ignored. */
      workflowStartDelay?: string;
      /** @description Callbacks to be called by the server when this workflow reaches a terminal state.
       *     If the workflow continues-as-new, these callbacks will be carried over to the new execution.
       *     Callback addresses must be whitelisted in the server's dynamic configuration. */
      completionCallbacks?: components['schemas']['v1Callback'][];
      userMetadata?: components['schemas']['v1UserMetadata'];
      /** @description Links to be associated with the workflow. */
      links?: components['schemas']['apicommonv1Link'][];
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      onConflictOptions?: components['schemas']['v1OnConflictOptions'];
      priority?: components['schemas']['v1Priority'];
    };
    WorkflowServiceStopBatchOperationBody: {
      /** Reason to stop a batch operation */
      reason?: string;
      /** Identity of the operator */
      identity?: string;
    };
    WorkflowServiceTerminateWorkflowExecutionBody: {
      /** @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
       *     uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
       *     run id as a way of saying "target the latest run of the workflow". */
      workflowExecution?: {
        runId?: string;
      };
      reason?: string;
      details?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
      /** @description If set, this call will error if the most recent (if no run id is set on
       *     `workflow_execution`), or specified (if it is) workflow execution is not part of the same
       *     execution chain as this id. */
      firstExecutionRunId?: string;
      /** @description Links to be associated with the WorkflowExecutionTerminated event. */
      links?: components['schemas']['apicommonv1Link'][];
    };
    WorkflowServiceTriggerWorkflowRuleBody: {
      /** Execution info of the workflow which scheduled this activity */
      execution?: {
        runId?: string;
      };
      id?: string;
      spec?: components['schemas']['v1WorkflowRuleSpec'];
      /** The identity of the client who initiated this request */
      identity?: string;
    };
    WorkflowServiceUnpauseActivityBody: {
      execution?: components['schemas']['v1WorkflowExecution'];
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description Only the activity with this ID will be unpaused. */
      id?: string;
      /** @description Unpause all running activities with of this type. */
      type?: string;
      /** @description Unpause all running activities. */
      unpauseAll?: boolean;
      /** @description Providing this flag will also reset the number of attempts. */
      resetAttempts?: boolean;
      /** @description Providing this flag will also reset the heartbeat details. */
      resetHeartbeat?: boolean;
      /** @description If set, the activity will start at a random time within the specified jitter duration. */
      jitter?: string;
    };
    /** NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions */
    WorkflowServiceUpdateActivityOptionsBody: {
      execution?: components['schemas']['v1WorkflowExecution'];
      /** The identity of the client who initiated this request */
      identity?: string;
      activityOptions?: components['schemas']['v1ActivityOptions'];
      /** Controls which fields from `activity_options` will be applied */
      updateMask?: string;
      /** @description Only activity with this ID will be updated. */
      id?: string;
      /** @description Update all running activities of this type. */
      type?: string;
      /** @description Update all running activities. */
      matchAll?: boolean;
      /** @description If set, the activity options will be restored to the default.
       *     Default options are then options activity was created with.
       *     They are part of the first SCHEDULE event.
       *     This flag cannot be combined with any other option; if you supply
       *     restore_original together with other options, the request will be rejected. */
      restoreOriginal?: boolean;
    };
    WorkflowServiceUpdateNamespaceBody: {
      updateInfo?: components['schemas']['v1UpdateNamespaceInfo'];
      config?: components['schemas']['v1NamespaceConfig'];
      replicationConfig?: components['schemas']['v1NamespaceReplicationConfig'];
      securityToken?: string;
      deleteBadBinary?: string;
      /** @description promote local namespace to global namespace. Ignored if namespace is already global namespace. */
      promoteNamespace?: boolean;
    };
    WorkflowServiceUpdateScheduleBody: {
      schedule?: components['schemas']['v1Schedule'];
      /**
       * Format: byte
       * @description This can be the value of conflict_token from a DescribeScheduleResponse,
       *     which will cause this request to fail if the schedule has been modified
       *     between the Describe and this Update.
       *     If missing, the schedule will be updated unconditionally.
       */
      conflictToken?: string;
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description A unique identifier for this update request for idempotence. Typically UUIDv4. */
      requestId?: string;
      searchAttributes?: components['schemas']['v1SearchAttributes'];
    };
    WorkflowServiceUpdateTaskQueueConfigBody: {
      identity?: string;
      taskQueueType?: components['schemas']['v1TaskQueueType'];
      updateQueueRateLimit?: components['schemas']['UpdateTaskQueueConfigRequestRateLimitUpdate'];
      updateFairnessKeyRateLimitDefault?: components['schemas']['UpdateTaskQueueConfigRequestRateLimitUpdate'];
    };
    WorkflowServiceUpdateWorkerConfigBody: {
      /** @description The identity of the client who initiated this request. */
      identity?: string;
      /** @description Reason for sending worker command, can be used for audit purpose. */
      reason?: string;
      workerConfig?: components['schemas']['v1WorkerConfig'];
      /** Controls which fields from `worker_config` will be applied */
      updateMask?: string;
      selector?: components['schemas']['v1WorkerSelector'];
    };
    /** @description Used to update the user-defined metadata of a Worker Deployment Version. */
    WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody: {
      /** @description Deprecated. Use `deployment_version`. */
      version?: string;
      /**
       * Required.
       * @description Required.
       */
      deploymentVersion?: Record<string, never>;
      upsertEntries?: {
        [key: string]: components['schemas']['v1Payload'];
      };
      /** @description List of keys to remove from the metadata. */
      removeEntries?: string[];
      /** @description Optional. The identity of the client who initiated this request. */
      identity?: string;
    };
    WorkflowServiceUpdateWorkflowExecutionBody: {
      /**
       * The target Workflow Id and (optionally) a specific Run Id thereof.
       * @description The target Workflow Id and (optionally) a specific Run Id thereof.
       */
      workflowExecution?: {
        runId?: string;
      };
      /** @description If set, this call will error if the most recent (if no Run Id is set on
       *     `workflow_execution`), or specified (if it is) Workflow Execution is not
       *     part of the same execution chain as this Id. */
      firstExecutionRunId?: string;
      waitPolicy?: components['schemas']['v1WaitPolicy'];
      /**
       * The request information that will be delivered all the way down to the
       *     Workflow Execution.
       * @description The request information that will be delivered all the way down to the
       *     Workflow Execution.
       */
      request?: {
        meta?: components['schemas']['v1Meta'];
        input?: {
          header?: components['schemas']['v1Header'];
          args?: components['schemas']['v1Payloads'];
        };
      };
    };
    /** @description Keep the parameters in sync with:
     *       - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
     *       - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions. */
    WorkflowServiceUpdateWorkflowExecutionOptionsBody: {
      /**
       * The target Workflow Id and (optionally) a specific Run Id thereof.
       * @description The target Workflow Id and (optionally) a specific Run Id thereof.
       */
      workflowExecution?: {
        runId?: string;
      };
      workflowExecutionOptions?: components['schemas']['v1WorkflowExecutionOptions'];
      /** @description Controls which fields from `workflow_execution_options` will be applied.
       *     To unset a field, set it to null and use the update mask to indicate that it should be mutated. */
      updateMask?: string;
    };
    /** @description Link can be associated with history events. It might contain information about an external entity
     *     related to the history event. For example, workflow A makes a Nexus call that starts workflow B:
     *     in this case, a history event in workflow A could contain a Link to the workflow started event in
     *     workflow B, and vice-versa. */
    apicommonv1Link: {
      workflowEvent?: components['schemas']['LinkWorkflowEvent'];
      batchJob?: components['schemas']['LinkBatchJob'];
    };
    apifailurev1Failure: {
      message?: string;
      /** @description The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
       *     In some SDKs this is used to rehydrate the stack trace into an exception object. */
      source?: string;
      stackTrace?: string;
      encodedAttributes?: components['schemas']['v1Payload'];
      cause?: components['schemas']['apifailurev1Failure'];
      applicationFailureInfo?: components['schemas']['v1ApplicationFailureInfo'];
      timeoutFailureInfo?: components['schemas']['v1TimeoutFailureInfo'];
      canceledFailureInfo?: components['schemas']['v1CanceledFailureInfo'];
      terminatedFailureInfo?: components['schemas']['v1TerminatedFailureInfo'];
      serverFailureInfo?: components['schemas']['v1ServerFailureInfo'];
      resetWorkflowFailureInfo?: components['schemas']['v1ResetWorkflowFailureInfo'];
      activityFailureInfo?: components['schemas']['v1ActivityFailureInfo'];
      childWorkflowExecutionFailureInfo?: components['schemas']['v1ChildWorkflowExecutionFailureInfo'];
      nexusOperationExecutionFailureInfo?: components['schemas']['v1NexusOperationFailureInfo'];
      nexusHandlerFailureInfo?: components['schemas']['v1NexusHandlerFailureInfo'];
    };
    /** A general purpose failure message.
     *     See: https://github.com/nexus-rpc/api/blob/main/SPEC.md#failure */
    apinexusv1Failure: {
      message?: string;
      metadata?: {
        [key: string]: string;
      };
      /**
       * Format: byte
       * @description UTF-8 encoded JSON serializable details.
       */
      details?: string;
    };
    apinexusv1Link: {
      /** @description See https://github.com/nexus-rpc/api/blob/main/SPEC.md#links. */
      url?: string;
      type?: string;
    };
    /** @description A Nexus request. */
    apinexusv1Request: {
      /** @description Headers extracted from the original request in the Temporal frontend.
       *     When using Nexus over HTTP, this includes the request's HTTP headers ignoring multiple values. */
      header?: {
        [key: string]: string;
      };
      /**
       * Format: date-time
       * @description The timestamp when the request was scheduled in the frontend.
       */
      scheduledTime?: string;
      startOperation?: components['schemas']['v1StartOperationRequest'];
      cancelOperation?: components['schemas']['v1CancelOperationRequest'];
    };
    /** @description A response indicating that the handler has successfully processed a request. */
    apinexusv1Response: {
      startOperation?: components['schemas']['v1StartOperationResponse'];
      cancelOperation?: components['schemas']['v1CancelOperationResponse'];
    };
    /** @description The client request that triggers a Workflow Update. */
    apiupdatev1Request: {
      meta?: components['schemas']['v1Meta'];
      input?: components['schemas']['v1Input'];
    };
    /** @description `Any` contains an arbitrary serialized protocol buffer message along with a
     *     URL that describes the type of the serialized message.
     *
     *     Protobuf library provides support to pack/unpack Any values in the form
     *     of utility functions or additional generated methods of the Any type.
     *
     *     Example 1: Pack and unpack a message in C++.
     *
     *         Foo foo = ...;
     *         Any any;
     *         any.PackFrom(foo);
     *         ...
     *         if (any.UnpackTo(&foo)) {
     *           ...
     *         }
     *
     *     Example 2: Pack and unpack a message in Java.
     *
     *         Foo foo = ...;
     *         Any any = Any.pack(foo);
     *         ...
     *         if (any.is(Foo.class)) {
     *           foo = any.unpack(Foo.class);
     *         }
     *         // or ...
     *         if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     *           foo = any.unpack(Foo.getDefaultInstance());
     *         }
     *
     *      Example 3: Pack and unpack a message in Python.
     *
     *         foo = Foo(...)
     *         any = Any()
     *         any.Pack(foo)
     *         ...
     *         if any.Is(Foo.DESCRIPTOR):
     *           any.Unpack(foo)
     *           ...
     *
     *      Example 4: Pack and unpack a message in Go
     *
     *          foo := &pb.Foo{...}
     *          any, err := anypb.New(foo)
     *          if err != nil {
     *            ...
     *          }
     *          ...
     *          foo := &pb.Foo{}
     *          if err := any.UnmarshalTo(foo); err != nil {
     *            ...
     *          }
     *
     *     The pack methods provided by protobuf library will by default use
     *     'type.googleapis.com/full.type.name' as the type URL and the unpack
     *     methods only use the fully qualified type name after the last '/'
     *     in the type URL, for example "foo.bar.com/x/y.z" will yield type
     *     name "y.z".
     *
     *     JSON
     *     ====
     *     The JSON representation of an `Any` value uses the regular
     *     representation of the deserialized, embedded message, with an
     *     additional field `@type` which contains the type URL. Example:
     *
     *         package google.profile;
     *         message Person {
     *           string first_name = 1;
     *           string last_name = 2;
     *         }
     *
     *         {
     *           "@type": "type.googleapis.com/google.profile.Person",
     *           "firstName": <string>,
     *           "lastName": <string>
     *         }
     *
     *     If the embedded message type is well-known and has a custom JSON
     *     representation, that representation will be embedded adding a field
     *     `value` which holds the custom JSON in addition to the `@type`
     *     field. Example (for message [google.protobuf.Duration][]):
     *
     *         {
     *           "@type": "type.googleapis.com/google.protobuf.Duration",
     *           "value": "1.212s"
     *         } */
    protobufAny: {
      /** @description A URL/resource name that uniquely identifies the type of the serialized
       *     protocol buffer message. This string must contain at least
       *     one "/" character. The last segment of the URL's path must represent
       *     the fully qualified name of the type (as in
       *     `path/google.protobuf.Duration`). The name should be in a canonical form
       *     (e.g., leading "." is not accepted).
       *
       *     In practice, teams usually precompile into the binary all types that they
       *     expect it to use in the context of Any. However, for URLs which use the
       *     scheme `http`, `https`, or no scheme, one can optionally set up a type
       *     server that maps type URLs to message definitions as follows:
       *
       *     * If no scheme is provided, `https` is assumed.
       *     * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *       value in binary format, or produce an error.
       *     * Applications are allowed to cache lookup results based on the
       *       URL, or have them precompiled into a binary to avoid any
       *       lookup. Therefore, binary compatibility needs to be preserved
       *       on changes to types. (Use versioned type names to manage
       *       breaking changes.)
       *
       *     Note: this functionality is not currently available in the official
       *     protobuf release, and it is not used for type URLs beginning with
       *     type.googleapis.com. As of May 2023, there are no widely used type server
       *     implementations and no plans to implement one.
       *
       *     Schemes other than `http`, `https` (or the empty scheme) might be
       *     used with implementation specific semantics. */
      '@type'?: string;
    } & {
      [key: string]: unknown;
    };
    rpcStatus: {
      /** Format: int32 */
      code?: number;
      message?: string;
      details?: components['schemas']['protobufAny'][];
    };
    v1ActivityFailureInfo: {
      /** Format: int64 */
      scheduledEventId?: string;
      /** Format: int64 */
      startedEventId?: string;
      identity?: string;
      activityType?: components['schemas']['v1ActivityType'];
      activityId?: string;
      retryState?: components['schemas']['v1RetryState'];
    };
    v1ActivityOptions: {
      taskQueue?: components['schemas']['v1TaskQueue'];
      /** @description Indicates how long the caller is willing to wait for an activity completion. Limits how long
       *     retries will be attempted. Either this or `start_to_close_timeout` must be specified.
       *      */
      scheduleToCloseTimeout?: string;
      /** @description Limits time an activity task can stay in a task queue before a worker picks it up. This
       *     timeout is always non retryable, as all a retry would achieve is to put it back into the same
       *     queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
       *     specified.
       *      */
      scheduleToStartTimeout?: string;
      /** @description Maximum time an activity is allowed to execute after being picked up by a worker. This
       *     timeout is always retryable. Either this or `schedule_to_close_timeout` must be
       *     specified.
       *      */
      startToCloseTimeout?: string;
      /** @description Maximum permitted time between successful worker heartbeats. */
      heartbeatTimeout?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
    };
    v1ActivityPropertiesModifiedExternallyEventAttributes: {
      /**
       * Format: int64
       * @description The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to.
       */
      scheduledEventId?: string;
      newRetryPolicy?: components['schemas']['v1RetryPolicy'];
    };
    v1ActivityTaskCancelRequestedEventAttributes: {
      /**
       * The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
    };
    v1ActivityTaskCanceledEventAttributes: {
      details?: components['schemas']['v1Payloads'];
      /**
       * id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same
       *     activity
       * Format: int64
       */
      latestCancelRequestedEventId?: string;
      /**
       * The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to
       * Format: int64
       */
      startedEventId?: string;
      /** id of the worker who canceled this activity */
      identity?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
    };
    v1ActivityTaskCompletedEventAttributes: {
      result?: components['schemas']['v1Payloads'];
      /**
       * The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to
       * Format: int64
       */
      startedEventId?: string;
      /** id of the worker that completed this task */
      identity?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
    };
    v1ActivityTaskFailedEventAttributes: {
      failure?: components['schemas']['apifailurev1Failure'];
      /**
       * The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to
       * Format: int64
       */
      startedEventId?: string;
      /** id of the worker that failed this task */
      identity?: string;
      retryState?: components['schemas']['v1RetryState'];
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
    };
    v1ActivityTaskScheduledEventAttributes: {
      /** The worker/user assigned identifier for the activity */
      activityId?: string;
      activityType?: components['schemas']['v1ActivityType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      header?: components['schemas']['v1Header'];
      input?: components['schemas']['v1Payloads'];
      /** @description Indicates how long the caller is willing to wait for an activity completion. Limits how long
       *     retries will be attempted. Either this or `start_to_close_timeout` must be specified.
       *      */
      scheduleToCloseTimeout?: string;
      /** @description Limits time an activity task can stay in a task queue before a worker picks it up. This
       *     timeout is always non retryable, as all a retry would achieve is to put it back into the same
       *     queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
       *     specified.
       *      */
      scheduleToStartTimeout?: string;
      /** @description Maximum time an activity is allowed to execute after being picked up by a worker. This
       *     timeout is always retryable. Either this or `schedule_to_close_timeout` must be
       *     specified.
       *      */
      startToCloseTimeout?: string;
      /** @description Maximum permitted time between successful worker heartbeats. */
      heartbeatTimeout?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
       *     Assignment rules of the activity's Task Queue will be used to determine the Build ID.
       *     Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv] */
      useWorkflowBuildId?: boolean;
      priority?: components['schemas']['v1Priority'];
    };
    v1ActivityTaskStartedEventAttributes: {
      /**
       * The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /** id of the worker that picked up this task */
      identity?: string;
      /** TODO ?? */
      requestId?: string;
      /**
       * Starting at 1, the number of times this task has been attempted
       * Format: int32
       */
      attempt?: number;
      lastFailure?: components['schemas']['apifailurev1Failure'];
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
      /**
       * Used by server internally to properly reapply build ID redirects to an execution
       *     when rebuilding it from events.
       *     Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       * Format: int64
       */
      buildIdRedirectCounter?: string;
    };
    v1ActivityTaskTimedOutEventAttributes: {
      failure?: components['schemas']['apifailurev1Failure'];
      /**
       * The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to
       * Format: int64
       */
      startedEventId?: string;
      retryState?: components['schemas']['v1RetryState'];
    };
    /** Represents the identifier used by a activity author to define the activity. Typically, the
     *     name of a function. This is sometimes referred to as the activity's "name" */
    v1ActivityType: {
      name?: string;
    };
    v1AddOrUpdateRemoteClusterResponse: Record<string, never>;
    v1AddSearchAttributesResponse: Record<string, never>;
    /** @description Alert contains notification and severity. */
    v1Alert: {
      message?: string;
      severity?: components['schemas']['v1Severity'];
    };
    /**
     * @description  - APPLICATION_ERROR_CATEGORY_BENIGN: Expected application error with little/no severity.
     * @default APPLICATION_ERROR_CATEGORY_UNSPECIFIED
     * @enum {string}
     */
    v1ApplicationErrorCategory:
      | 'APPLICATION_ERROR_CATEGORY_UNSPECIFIED'
      | 'APPLICATION_ERROR_CATEGORY_BENIGN';
    v1ApplicationFailureInfo: {
      type?: string;
      nonRetryable?: boolean;
      details?: components['schemas']['v1Payloads'];
      /** @description next_retry_delay can be used by the client to override the activity
       *     retry interval calculated by the retry policy. Retry attempts will
       *     still be subject to the maximum retries limit and total time limit
       *     defined by the policy. */
      nextRetryDelay?: string;
      category?: components['schemas']['v1ApplicationErrorCategory'];
    };
    /**
     * @default ARCHIVAL_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1ArchivalState:
      | 'ARCHIVAL_STATE_UNSPECIFIED'
      | 'ARCHIVAL_STATE_DISABLED'
      | 'ARCHIVAL_STATE_ENABLED';
    v1BackfillRequest: {
      /**
       * Format: date-time
       * @description Time range to evaluate schedule in. Currently, this time range is
       *     exclusive on start_time and inclusive on end_time. (This is admittedly
       *     counterintuitive and it may change in the future, so to be safe, use a
       *     start time strictly before a scheduled time.) Also note that an action
       *     nominally scheduled in the interval but with jitter that pushes it after
       *     end_time will not be included.
       */
      startTime?: string;
      /** Format: date-time */
      endTime?: string;
      overlapPolicy?: components['schemas']['v1ScheduleOverlapPolicy'];
    };
    v1BadBinaries: {
      binaries?: {
        [key: string]: components['schemas']['v1BadBinaryInfo'];
      };
    };
    v1BadBinaryInfo: {
      reason?: string;
      operator?: string;
      /** Format: date-time */
      createTime?: string;
    };
    /** @description BatchOperationCancellation sends cancel requests to batch workflows.
     *     Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
     *     Ignore first_execution_run_id because this is used for single workflow operation. */
    v1BatchOperationCancellation: {
      /** The identity of the worker/client */
      identity?: string;
    };
    /** @description BatchOperationDeletion sends deletion requests to batch workflows.
     *     Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest. */
    v1BatchOperationDeletion: {
      /** The identity of the worker/client */
      identity?: string;
    };
    v1BatchOperationInfo: {
      /** Batch job ID */
      jobId?: string;
      state?: components['schemas']['v1BatchOperationState'];
      /**
       * Batch operation start time
       * Format: date-time
       */
      startTime?: string;
      /**
       * Batch operation close time
       * Format: date-time
       */
      closeTime?: string;
    };
    /** @description BatchOperationReset sends reset requests to batch workflows.
     *     Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest. */
    v1BatchOperationReset: {
      /** @description The identity of the worker/client. */
      identity?: string;
      options?: components['schemas']['v1ResetOptions'];
      resetType?: components['schemas']['v1ResetType'];
      resetReapplyType?: components['schemas']['v1ResetReapplyType'];
      /** Operations to perform after the workflow has been reset. These operations will be applied
       *     to the *new* run of the workflow execution in the order they are provided.
       *     All operations are applied to the workflow before the first new workflow task is generated */
      postResetOperations?: components['schemas']['v1PostResetOperation'][];
    };
    /** BatchOperationResetActivities sends activity reset requests in a batch.
     *     NOTE: keep in sync with temporal.api.workflowservice.v1.ResetActivityRequest */
    v1BatchOperationResetActivities: {
      /** @description The identity of the worker/client. */
      identity?: string;
      type?: string;
      matchAll?: boolean;
      /** @description Setting this flag will also reset the number of attempts. */
      resetAttempts?: boolean;
      /** @description Setting this flag will also reset the heartbeat details. */
      resetHeartbeat?: boolean;
      /** If activity is paused, it will remain paused after reset */
      keepPaused?: boolean;
      /** @description If set, the activity will start at a random time within the specified jitter
       *     duration, introducing variability to the start time. */
      jitter?: string;
      /** @description If set, the activity options will be restored to the defaults.
       *     Default options are then options activity was created with.
       *     They are part of the first ActivityTaskScheduled event. */
      restoreOriginalOptions?: boolean;
    };
    /** @description BatchOperationSignal sends signals to batch workflows.
     *     Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest. */
    v1BatchOperationSignal: {
      /** The workflow author-defined name of the signal to send to the workflow */
      signal?: string;
      input?: components['schemas']['v1Payloads'];
      header?: components['schemas']['v1Header'];
      /** The identity of the worker/client */
      identity?: string;
    };
    /**
     * @default BATCH_OPERATION_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1BatchOperationState:
      | 'BATCH_OPERATION_STATE_UNSPECIFIED'
      | 'BATCH_OPERATION_STATE_RUNNING'
      | 'BATCH_OPERATION_STATE_COMPLETED'
      | 'BATCH_OPERATION_STATE_FAILED';
    /** @description BatchOperationTermination sends terminate requests to batch workflows.
     *     Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
     *     Ignore first_execution_run_id because this is used for single workflow operation. */
    v1BatchOperationTermination: {
      details?: components['schemas']['v1Payloads'];
      /** The identity of the worker/client */
      identity?: string;
    };
    /**
     * @default BATCH_OPERATION_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1BatchOperationType:
      | 'BATCH_OPERATION_TYPE_UNSPECIFIED'
      | 'BATCH_OPERATION_TYPE_TERMINATE'
      | 'BATCH_OPERATION_TYPE_CANCEL'
      | 'BATCH_OPERATION_TYPE_SIGNAL'
      | 'BATCH_OPERATION_TYPE_DELETE'
      | 'BATCH_OPERATION_TYPE_RESET'
      | 'BATCH_OPERATION_TYPE_UPDATE_EXECUTION_OPTIONS'
      | 'BATCH_OPERATION_TYPE_UNPAUSE_ACTIVITY'
      | 'BATCH_OPERATION_TYPE_UPDATE_ACTIVITY_OPTIONS'
      | 'BATCH_OPERATION_TYPE_RESET_ACTIVITY';
    /** @description BatchOperationUnpauseActivities sends unpause requests to batch workflows. */
    v1BatchOperationUnpauseActivities: {
      /** @description The identity of the worker/client. */
      identity?: string;
      type?: string;
      matchAll?: boolean;
      /** @description Setting this flag will also reset the number of attempts. */
      resetAttempts?: boolean;
      /** @description Setting this flag will also reset the heartbeat details. */
      resetHeartbeat?: boolean;
      /** @description If set, the activity will start at a random time within the specified jitter
       *     duration, introducing variability to the start time. */
      jitter?: string;
    };
    /** BatchOperationUpdateActivityOptions sends an update-activity-options requests in a batch.
     *     NOTE: keep in sync with temporal.api.workflowservice.v1.UpdateActivityRequest */
    v1BatchOperationUpdateActivityOptions: {
      /** @description The identity of the worker/client. */
      identity?: string;
      type?: string;
      matchAll?: boolean;
      activityOptions?: components['schemas']['v1ActivityOptions'];
      /** Controls which fields from `activity_options` will be applied */
      updateMask?: string;
      /** @description If set, the activity options will be restored to the default.
       *     Default options are then options activity was created with.
       *     They are part of the first ActivityTaskScheduled event.
       *     This flag cannot be combined with any other option; if you supply
       *     restore_original together with other options, the request will be rejected. */
      restoreOriginal?: boolean;
    };
    /** @description BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.
     *     Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest. */
    v1BatchOperationUpdateWorkflowExecutionOptions: {
      /** @description The identity of the worker/client. */
      identity?: string;
      workflowExecutionOptions?: components['schemas']['v1WorkflowExecutionOptions'];
      /** @description Controls which fields from `workflow_execution_options` will be applied.
       *     To unset a field, set it to null and use the update mask to indicate that it should be mutated. */
      updateMask?: string;
    };
    /** @description Assignment rules are applied to *new* Workflow and Activity executions at
     *     schedule time to assign them to a Build ID.
     *
     *     Assignment rules will not be used in the following cases:
     *        - Child Workflows or Continue-As-New Executions who inherit their
     *          parent/previous Workflow's assigned Build ID (by setting the
     *          `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
     *          is used.)
     *        - An Activity that inherits the assigned Build ID of its Workflow (by
     *          setting the `use_workflow_build_id` flag - default behavior in SDKs
     *          when the same Task Queue is used.)
     *
     *     In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
     *     the task will be dispatched to Workers of the Build ID determined by the
     *     assignment rules (or inherited). Otherwise, the final Build ID will be
     *     determined by the redirect rules.
     *
     *     Once a Workflow completes its first Workflow Task in a particular Build ID it
     *     stays in that Build ID regardless of changes to assignment rules. Redirect
     *     rules can be used to move the workflow to another compatible Build ID.
     *
     *     When using Worker Versioning on a Task Queue, in the steady state,
     *     there should typically be a single assignment rule to send all new executions
     *     to the latest Build ID. Existence of at least one such "unconditional"
     *     rule at all times is enforces by the system, unless the `force` flag is used
     *     by the user when replacing/deleting these rules (for exceptional cases).
     *
     *     During a deployment, one or more additional rules can be added to assign a
     *     subset of the tasks to a new Build ID based on a "ramp percentage".
     *
     *     When there are multiple assignment rules for a Task Queue, the rules are
     *     evaluated in order, starting from index 0. The first applicable rule will be
     *     applied and the rest will be ignored.
     *
     *     In the event that no assignment rule is applicable on a task (or the Task
     *     Queue is simply not versioned), the tasks will be dispatched to an
     *     unversioned Worker. */
    v1BuildIdAssignmentRule: {
      targetBuildId?: string;
      percentageRamp?: components['schemas']['v1RampByPercentage'];
    };
    /** @description Reachability of tasks for a worker by build id, in one or more task queues. */
    v1BuildIdReachability: {
      /** @description A build id or empty if unversioned. */
      buildId?: string;
      /** @description Reachability per task queue. */
      taskQueueReachability?: components['schemas']['v1TaskQueueReachability'][];
    };
    /**
     * @description Specifies which category of tasks may reach a versioned worker of a certain Build ID.
     *
     *     Task Reachability is eventually consistent; there may be a delay (up to few minutes) until it
     *     converges to the most accurate value but it is designed in a way to take the more conservative
     *     side until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
     *
     *     Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
     *     accounted for reachability as server cannot know if they'll happen as they do not use
     *     assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
     *     who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
     *     sure to query reachability for the parent/previous workflow's Task Queue as well.
     *
     *      - BUILD_ID_TASK_REACHABILITY_UNSPECIFIED: Task reachability is not reported
     *      - BUILD_ID_TASK_REACHABILITY_REACHABLE: Build ID may be used by new workflows or activities (base on versioning rules), or there MAY
     *     be open workflows or backlogged activities assigned to it.
     *      - BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY: Build ID does not have open workflows and is not reachable by new workflows,
     *     but MAY have closed workflows within the namespace retention period.
     *     Not applicable to activity-only task queues.
     *      - BUILD_ID_TASK_REACHABILITY_UNREACHABLE: Build ID is not used for new executions, nor it has been used by any existing execution
     *     within the retention period.
     * @default BUILD_ID_TASK_REACHABILITY_UNSPECIFIED
     * @enum {string}
     */
    v1BuildIdTaskReachability:
      | 'BUILD_ID_TASK_REACHABILITY_UNSPECIFIED'
      | 'BUILD_ID_TASK_REACHABILITY_REACHABLE'
      | 'BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY'
      | 'BUILD_ID_TASK_REACHABILITY_UNREACHABLE';
    /** @description CalendarSpec describes an event specification relative to the calendar,
     *     similar to a traditional cron specification, but with labeled fields. Each
     *     field can be one of:
     *       *: matches always
     *       x: matches when the field equals x
     *       x/y : matches when the field equals x+n*y where n is an integer
     *       x-z: matches when the field is between x and z inclusive
     *       w,x,y,...: matches when the field is one of the listed values
     *     Each x, y, z, ... is either a decimal integer, or a month or day of week name
     *     or abbreviation (in the appropriate fields).
     *     A timestamp matches if all fields match.
     *     Note that fields have different default values, for convenience.
     *     Note that the special case that some cron implementations have for treating
     *     day_of_month and day_of_week as "or" instead of "and" when both are set is
     *     not implemented.
     *     day_of_week can accept 0 or 7 as Sunday
     *     CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
     *     returned if you describe the schedule. */
    v1CalendarSpec: {
      /** Expression to match seconds. Default: 0 */
      second?: string;
      /** Expression to match minutes. Default: 0 */
      minute?: string;
      /** Expression to match hours. Default: 0 */
      hour?: string;
      /** Expression to match days of the month. Default: * */
      dayOfMonth?: string;
      /** Expression to match months. Default: * */
      month?: string;
      /** Expression to match years. Default: * */
      year?: string;
      /** Expression to match days of the week. Default: * */
      dayOfWeek?: string;
      /** @description Free-form comment describing the intention of this spec. */
      comment?: string;
    };
    /** @description Callback to attach to various events in the system, e.g. workflow run completion. */
    v1Callback: {
      nexus?: components['schemas']['CallbackNexus'];
      internal?: components['schemas']['CallbackInternal'];
      /** @description Links associated with the callback. It can be used to link to underlying resources of the
       *     callback. */
      links?: components['schemas']['apicommonv1Link'][];
    };
    /** @description CallbackInfo contains the state of an attached workflow callback. */
    v1CallbackInfo: {
      callback?: components['schemas']['v1Callback'];
      trigger?: components['schemas']['CallbackInfoTrigger'];
      /**
       * Format: date-time
       * @description The time when the callback was registered.
       */
      registrationTime?: string;
      state?: components['schemas']['v1CallbackState'];
      /**
       * Format: int32
       * @description The number of attempts made to deliver the callback.
       *     This number represents a minimum bound since the attempt is incremented after the callback request completes.
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      lastAttemptCompleteTime?: string;
      lastAttemptFailure?: components['schemas']['apifailurev1Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      nextAttemptScheduleTime?: string;
      /** @description If the state is BLOCKED, blocked reason provides additional information. */
      blockedReason?: string;
    };
    /**
     * @description State of a callback.
     *
     *      - CALLBACK_STATE_UNSPECIFIED: Default value, unspecified state.
     *      - CALLBACK_STATE_STANDBY: Callback is standing by, waiting to be triggered.
     *      - CALLBACK_STATE_SCHEDULED: Callback is in the queue waiting to be executed or is currently executing.
     *      - CALLBACK_STATE_BACKING_OFF: Callback has failed with a retryable error and is backing off before the next attempt.
     *      - CALLBACK_STATE_FAILED: Callback has failed.
     *      - CALLBACK_STATE_SUCCEEDED: Callback has succeeded.
     *      - CALLBACK_STATE_BLOCKED: Callback is blocked (eg: by circuit breaker).
     * @default CALLBACK_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1CallbackState:
      | 'CALLBACK_STATE_UNSPECIFIED'
      | 'CALLBACK_STATE_STANDBY'
      | 'CALLBACK_STATE_SCHEDULED'
      | 'CALLBACK_STATE_BACKING_OFF'
      | 'CALLBACK_STATE_FAILED'
      | 'CALLBACK_STATE_SUCCEEDED'
      | 'CALLBACK_STATE_BLOCKED';
    /**
     * @default CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED
     * @enum {string}
     */
    v1CancelExternalWorkflowExecutionFailedCause:
      | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
      | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND'
      | 'CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND';
    /** @description A request to cancel an operation. */
    v1CancelOperationRequest: {
      /** @description Service name. */
      service?: string;
      /** @description Type of operation to cancel. */
      operation?: string;
      /** @description Operation ID as originally generated by a Handler.
       *
       *     Deprecated. Renamed to operation_token. */
      operationId?: string;
      /** @description Operation token as originally generated by a Handler. */
      operationToken?: string;
    };
    /** @description Response variant for CancelOperationRequest. */
    v1CancelOperationResponse: Record<string, never>;
    v1CancelTimerCommandAttributes: {
      /** The same timer id from the start timer command */
      timerId?: string;
    };
    v1CancelWorkflowExecutionCommandAttributes: {
      details?: components['schemas']['v1Payloads'];
    };
    v1CanceledFailureInfo: {
      details?: components['schemas']['v1Payloads'];
    };
    v1ChildWorkflowExecutionCanceledEventAttributes: {
      details?: components['schemas']['v1Payloads'];
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /**
       * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
       * Format: int64
       */
      startedEventId?: string;
    };
    v1ChildWorkflowExecutionCompletedEventAttributes: {
      result?: components['schemas']['v1Payloads'];
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /**
       * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
       * Format: int64
       */
      startedEventId?: string;
    };
    v1ChildWorkflowExecutionFailedEventAttributes: {
      failure?: components['schemas']['apifailurev1Failure'];
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /**
       * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
       * Format: int64
       */
      startedEventId?: string;
      retryState?: components['schemas']['v1RetryState'];
    };
    v1ChildWorkflowExecutionFailureInfo: {
      namespace?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /** Format: int64 */
      initiatedEventId?: string;
      /** Format: int64 */
      startedEventId?: string;
      retryState?: components['schemas']['v1RetryState'];
    };
    v1ChildWorkflowExecutionStartedEventAttributes: {
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      header?: components['schemas']['v1Header'];
    };
    v1ChildWorkflowExecutionTerminatedEventAttributes: {
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /**
       * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
       * Format: int64
       */
      startedEventId?: string;
    };
    v1ChildWorkflowExecutionTimedOutEventAttributes: {
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /**
       * Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
       * Format: int64
       */
      startedEventId?: string;
      retryState?: components['schemas']['v1RetryState'];
    };
    v1ClusterMetadata: {
      /** @description Name of the cluster name. */
      clusterName?: string;
      /** @description Id of the cluster. */
      clusterId?: string;
      /** @description gRPC address. */
      address?: string;
      /** @description HTTP address, if one exists. */
      httpAddress?: string;
      /**
       * Format: int64
       * @description A unique failover version across all connected clusters.
       */
      initialFailoverVersion?: string;
      /**
       * Format: int32
       * @description History service shard number.
       */
      historyShardCount?: number;
      /** @description A flag to indicate if a connection is active. */
      isConnectionEnabled?: boolean;
    };
    v1ClusterReplicationConfig: {
      clusterName?: string;
    };
    v1Command: {
      commandType?: components['schemas']['v1CommandType'];
      userMetadata?: components['schemas']['v1UserMetadata'];
      scheduleActivityTaskCommandAttributes?: components['schemas']['v1ScheduleActivityTaskCommandAttributes'];
      startTimerCommandAttributes?: components['schemas']['v1StartTimerCommandAttributes'];
      completeWorkflowExecutionCommandAttributes?: components['schemas']['v1CompleteWorkflowExecutionCommandAttributes'];
      failWorkflowExecutionCommandAttributes?: components['schemas']['v1FailWorkflowExecutionCommandAttributes'];
      requestCancelActivityTaskCommandAttributes?: components['schemas']['v1RequestCancelActivityTaskCommandAttributes'];
      cancelTimerCommandAttributes?: components['schemas']['v1CancelTimerCommandAttributes'];
      cancelWorkflowExecutionCommandAttributes?: components['schemas']['v1CancelWorkflowExecutionCommandAttributes'];
      requestCancelExternalWorkflowExecutionCommandAttributes?: components['schemas']['v1RequestCancelExternalWorkflowExecutionCommandAttributes'];
      recordMarkerCommandAttributes?: components['schemas']['v1RecordMarkerCommandAttributes'];
      continueAsNewWorkflowExecutionCommandAttributes?: components['schemas']['v1ContinueAsNewWorkflowExecutionCommandAttributes'];
      startChildWorkflowExecutionCommandAttributes?: components['schemas']['v1StartChildWorkflowExecutionCommandAttributes'];
      signalExternalWorkflowExecutionCommandAttributes?: components['schemas']['v1SignalExternalWorkflowExecutionCommandAttributes'];
      upsertWorkflowSearchAttributesCommandAttributes?: components['schemas']['v1UpsertWorkflowSearchAttributesCommandAttributes'];
      protocolMessageCommandAttributes?: components['schemas']['v1ProtocolMessageCommandAttributes'];
      modifyWorkflowPropertiesCommandAttributes?: components['schemas']['v1ModifyWorkflowPropertiesCommandAttributes'];
      scheduleNexusOperationCommandAttributes?: components['schemas']['v1ScheduleNexusOperationCommandAttributes'];
      requestCancelNexusOperationCommandAttributes?: components['schemas']['v1RequestCancelNexusOperationCommandAttributes'];
    };
    /**
     * @description Whenever this list of command types is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering.
     * @default COMMAND_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1CommandType:
      | 'COMMAND_TYPE_UNSPECIFIED'
      | 'COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK'
      | 'COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK'
      | 'COMMAND_TYPE_START_TIMER'
      | 'COMMAND_TYPE_COMPLETE_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_CANCEL_TIMER'
      | 'COMMAND_TYPE_CANCEL_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_RECORD_MARKER'
      | 'COMMAND_TYPE_CONTINUE_AS_NEW_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION'
      | 'COMMAND_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES'
      | 'COMMAND_TYPE_PROTOCOL_MESSAGE'
      | 'COMMAND_TYPE_MODIFY_WORKFLOW_PROPERTIES'
      | 'COMMAND_TYPE_SCHEDULE_NEXUS_OPERATION'
      | 'COMMAND_TYPE_REQUEST_CANCEL_NEXUS_OPERATION';
    /** @description These rules apply to tasks assigned to a particular Build ID
     *     (`source_build_id`) to redirect them to another *compatible* Build ID
     *     (`target_build_id`).
     *
     *     It is user's responsibility to ensure that the target Build ID is compatible
     *     with the source Build ID (e.g. by using the Patching API).
     *
     *     Most deployments are not expected to need these rules, however following
     *     situations can greatly benefit from redirects:
     *      - Need to move long-running Workflow Executions from an old Build ID to a
     *        newer one.
     *      - Need to hotfix some broken or stuck Workflow Executions.
     *
     *     In steady state, redirect rules are beneficial when dealing with old
     *     Executions ran on now-decommissioned Build IDs:
     *      - To redirecting the Workflow Queries to the current (compatible) Build ID.
     *      - To be able to Reset an old Execution so it can run on the current
     *        (compatible) Build ID.
     *
     *     Redirect rules can be chained. */
    v1CompatibleBuildIdRedirectRule: {
      sourceBuildId?: string;
      /** @description Target Build ID must be compatible with the Source Build ID; that is it
       *     must be able to process event histories made by the Source Build ID by
       *     using [Patching](https://docs.temporal.io/workflows#patching) or other
       *     means. */
      targetBuildId?: string;
    };
    /** @description Used by the worker versioning APIs, represents an unordered set of one or more versions which are
     *     considered to be compatible with each other. Currently the versions are always worker build IDs. */
    v1CompatibleVersionSet: {
      /** @description All the compatible versions, unordered, except for the last element, which is considered the set "default". */
      buildIds?: string[];
    };
    v1CompleteWorkflowExecutionCommandAttributes: {
      result?: components['schemas']['v1Payloads'];
    };
    v1ConfigMetadata: {
      /** @description Reason for why the config was set. */
      reason?: string;
      /** @description Identity of the last updater.
       *     Set by the request's identity field. */
      updateIdentity?: string;
      /**
       * Format: date-time
       * @description Time of the last update.
       */
      updateTime?: string;
    };
    /**
     * - CONTINUE_AS_NEW_INITIATOR_WORKFLOW: The workflow itself requested to continue as new
     *      - CONTINUE_AS_NEW_INITIATOR_RETRY: The workflow continued as new because it is retrying
     *      - CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE: The workflow continued as new because cron has triggered a new execution
     * @default CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED
     * @enum {string}
     */
    v1ContinueAsNewInitiator:
      | 'CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED'
      | 'CONTINUE_AS_NEW_INITIATOR_WORKFLOW'
      | 'CONTINUE_AS_NEW_INITIATOR_RETRY'
      | 'CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE';
    v1ContinueAsNewWorkflowExecutionCommandAttributes: {
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /** @description How long the workflow start will be delayed - not really a "backoff" in the traditional sense. */
      backoffStartInterval?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      initiator?: components['schemas']['v1ContinueAsNewInitiator'];
      failure?: components['schemas']['apifailurev1Failure'];
      lastCompletionResult?: components['schemas']['v1Payloads'];
      /** @description Should be removed. Not necessarily unused but unclear and not exposed by SDKs. */
      cronSchedule?: string;
      header?: components['schemas']['v1Header'];
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      /** @description If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
       *     the assignment rules will be used to independently assign a Build ID to the new execution.
       *     Deprecated. Only considered for versioning v0.2. */
      inheritBuildId?: boolean;
    };
    v1CountWorkflowExecutionsResponse: {
      /**
       * Format: int64
       * @description If `query` is not grouping by any field, the count is an approximate number
       *     of workflows that matches the query.
       *     If `query` is grouping by a field, the count is simply the sum of the counts
       *     of the groups returned in the response. This number can be smaller than the
       *     total number of workflows matching the query.
       */
      count?: string;
      /** @description `groups` contains the groups if the request is grouping by a field.
       *     The list might not be complete, and the counts of each group is approximate. */
      groups?: components['schemas']['CountWorkflowExecutionsResponseAggregationGroup'][];
    };
    v1CreateNexusEndpointRequest: {
      spec?: components['schemas']['v1EndpointSpec'];
    };
    v1CreateNexusEndpointResponse: {
      endpoint?: components['schemas']['v1Endpoint'];
    };
    v1CreateScheduleResponse: {
      /** Format: byte */
      conflictToken?: string;
    };
    v1CreateWorkflowRuleResponse: {
      rule?: components['schemas']['v1WorkflowRule'];
      /** @description Batch Job ID if force-scan flag was provided. Otherwise empty. */
      jobId?: string;
    };
    v1DataBlob: {
      encodingType?: components['schemas']['v1EncodingType'];
      /** Format: byte */
      data?: string;
    };
    v1DeleteNamespaceResponse: {
      /** @description Temporary namespace name that is used during reclaim resources step. */
      deletedNamespace?: string;
    };
    v1DeleteNexusEndpointResponse: Record<string, never>;
    v1DeleteScheduleResponse: Record<string, never>;
    v1DeleteWorkerDeploymentResponse: Record<string, never>;
    v1DeleteWorkerDeploymentVersionResponse: Record<string, never>;
    v1DeleteWorkflowExecutionResponse: Record<string, never>;
    v1DeleteWorkflowRuleResponse: Record<string, never>;
    /** @description `Deployment` identifies a deployment of Temporal workers. The combination of deployment series
     *     name + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker
     *     programs to specify these values.
     *     Deprecated. */
    v1Deployment: {
      /** @description Different versions of the same worker service/application are related together by having a
       *     shared series name.
       *     Out of all deployments of a series, one can be designated as the current deployment, which
       *     receives new workflow executions and new tasks of workflows with
       *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
      seriesName?: string;
      /** @description Build ID changes with each version of the worker when the worker program code and/or config
       *     changes. */
      buildId?: string;
    };
    /** @description `DeploymentInfo` holds information about a deployment. Deployment information is tracked
     *     automatically by server as soon as the first poll from that deployment reaches the server. There
     *     can be multiple task queue workers in a single deployment which are listed in this message.
     *     Deprecated. */
    v1DeploymentInfo: {
      deployment?: components['schemas']['v1Deployment'];
      /** Format: date-time */
      createTime?: string;
      taskQueueInfos?: components['schemas']['DeploymentInfoTaskQueueInfo'][];
      /** @description A user-defined set of key-values. Can be updated as part of write operations to the
       *     deployment, such as `SetCurrentDeployment`. */
      metadata?: {
        [key: string]: components['schemas']['v1Payload'];
      };
      /** @description If this deployment is the current deployment of its deployment series. */
      isCurrent?: boolean;
    };
    /** @description DeploymentListInfo is an abbreviated set of fields from DeploymentInfo that's returned in
     *     ListDeployments.
     *     Deprecated. */
    v1DeploymentListInfo: {
      deployment?: components['schemas']['v1Deployment'];
      /** Format: date-time */
      createTime?: string;
      /** @description If this deployment is the current deployment of its deployment series. */
      isCurrent?: boolean;
    };
    /**
     * @description Specify the reachability level for a deployment so users can decide if it is time to
     *     decommission the deployment.
     *
     *      - DEPLOYMENT_REACHABILITY_UNSPECIFIED: Reachability level is not specified.
     *      - DEPLOYMENT_REACHABILITY_REACHABLE: The deployment is reachable by new and/or open workflows. The deployment cannot be
     *     decommissioned safely.
     *      - DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY: The deployment is not reachable by new or open workflows, but might be still needed by
     *     Queries sent to closed workflows. The deployment can be decommissioned safely if user does
     *     not query closed workflows.
     *      - DEPLOYMENT_REACHABILITY_UNREACHABLE: The deployment is not reachable by any workflow because all the workflows who needed this
     *     deployment went out of retention period. The deployment can be decommissioned safely.
     * @default DEPLOYMENT_REACHABILITY_UNSPECIFIED
     * @enum {string}
     */
    v1DeploymentReachability:
      | 'DEPLOYMENT_REACHABILITY_UNSPECIFIED'
      | 'DEPLOYMENT_REACHABILITY_REACHABLE'
      | 'DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY'
      | 'DEPLOYMENT_REACHABILITY_UNREACHABLE';
    /** @description Holds information about ongoing transition of a workflow execution from one deployment to another.
     *     Deprecated. Use DeploymentVersionTransition. */
    v1DeploymentTransition: {
      deployment?: components['schemas']['v1Deployment'];
    };
    /** @description Holds information about ongoing transition of a workflow execution from one worker
     *     deployment version to another.
     *     Experimental. Might change in the future. */
    v1DeploymentVersionTransition: {
      /** @description Deprecated. Use `deployment_version`. */
      version?: string;
      deploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
    };
    /** @description Deprecated. */
    v1DeprecateNamespaceResponse: Record<string, never>;
    v1DescribeBatchOperationResponse: {
      operationType?: components['schemas']['v1BatchOperationType'];
      /** Batch job ID */
      jobId?: string;
      state?: components['schemas']['v1BatchOperationState'];
      /**
       * Batch operation start time
       * Format: date-time
       */
      startTime?: string;
      /**
       * Batch operation close time
       * Format: date-time
       */
      closeTime?: string;
      /**
       * Total operation count
       * Format: int64
       */
      totalOperationCount?: string;
      /**
       * Complete operation count
       * Format: int64
       */
      completeOperationCount?: string;
      /**
       * Failure operation count
       * Format: int64
       */
      failureOperationCount?: string;
      /** Identity indicates the operator identity */
      identity?: string;
      /** Reason indicates the reason to stop a operation */
      reason?: string;
    };
    /** [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    v1DescribeDeploymentResponse: {
      deploymentInfo?: components['schemas']['v1DeploymentInfo'];
    };
    v1DescribeNamespaceResponse: {
      namespaceInfo?: components['schemas']['v1NamespaceInfo'];
      config?: components['schemas']['v1NamespaceConfig'];
      replicationConfig?: components['schemas']['v1NamespaceReplicationConfig'];
      /** Format: int64 */
      failoverVersion?: string;
      isGlobalNamespace?: boolean;
      /** @description Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
       *     states to ensure that the list does not grow unbounded. */
      failoverHistory?: components['schemas']['v1FailoverStatus'][];
    };
    v1DescribeScheduleResponse: {
      schedule?: components['schemas']['v1Schedule'];
      info?: components['schemas']['v1ScheduleInfo'];
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      /**
       * Format: byte
       * @description This value can be passed back to UpdateSchedule to ensure that the
       *     schedule was not modified between a Describe and an Update, which could
       *     lead to lost updates and other confusion.
       */
      conflictToken?: string;
    };
    /**
     * @description  - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.
     *      - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.
     * @default DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED
     * @enum {string}
     */
    v1DescribeTaskQueueMode:
      | 'DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED'
      | 'DESCRIBE_TASK_QUEUE_MODE_ENHANCED';
    v1DescribeTaskQueueResponse: {
      pollers?: components['schemas']['v1PollerInfo'][];
      stats?: components['schemas']['v1TaskQueueStats'];
      /** @description Task queue stats breakdown by priority key. Only contains actively used priority keys.
       *     Only set if `report_stats` is set on the request. */
      statsByPriorityKey?: {
        [key: string]: components['schemas']['v1TaskQueueStats'];
      };
      versioningInfo?: components['schemas']['v1TaskQueueVersioningInfo'];
      config?: components['schemas']['v1TaskQueueConfig'];
      effectiveRateLimit?: components['schemas']['DescribeTaskQueueResponseEffectiveRateLimit'];
      taskQueueStatus?: components['schemas']['v1TaskQueueStatus'];
      /** @description Deprecated.
       *     Only returned in ENHANCED mode.
       *     This map contains Task Queue information for each Build ID. Empty string as key value means unversioned. */
      versionsInfo?: {
        [key: string]: components['schemas']['v1TaskQueueVersionInfo'];
      };
    };
    v1DescribeWorkerDeploymentResponse: {
      /**
       * Format: byte
       * @description This value is returned so that it can be optionally passed to APIs
       *     that write to the Worker Deployment state to ensure that the state
       *     did not change between this read and a future write.
       */
      conflictToken?: string;
      workerDeploymentInfo?: components['schemas']['v1WorkerDeploymentInfo'];
    };
    v1DescribeWorkerDeploymentVersionResponse: {
      workerDeploymentVersionInfo?: components['schemas']['v1WorkerDeploymentVersionInfo'];
      /** @description All the Task Queues that have ever polled from this Deployment version. */
      versionTaskQueues?: components['schemas']['DescribeWorkerDeploymentVersionResponseVersionTaskQueue'][];
    };
    v1DescribeWorkerResponse: {
      workerInfo?: components['schemas']['v1WorkerInfo'];
    };
    v1DescribeWorkflowExecutionResponse: {
      executionConfig?: components['schemas']['v1WorkflowExecutionConfig'];
      workflowExecutionInfo?: components['schemas']['v1WorkflowExecutionInfo'];
      pendingActivities?: components['schemas']['v1PendingActivityInfo'][];
      pendingChildren?: components['schemas']['v1PendingChildExecutionInfo'][];
      pendingWorkflowTask?: components['schemas']['v1PendingWorkflowTaskInfo'];
      callbacks?: components['schemas']['v1CallbackInfo'][];
      pendingNexusOperations?: components['schemas']['v1PendingNexusOperationInfo'][];
      workflowExtendedInfo?: components['schemas']['v1WorkflowExecutionExtendedInfo'];
    };
    v1DescribeWorkflowRuleResponse: {
      rule?: components['schemas']['v1WorkflowRule'];
    };
    /**
     * @default ENCODING_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1EncodingType:
      | 'ENCODING_TYPE_UNSPECIFIED'
      | 'ENCODING_TYPE_PROTO3'
      | 'ENCODING_TYPE_JSON';
    /** @description A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests. */
    v1Endpoint: {
      /**
       * Format: int64
       * @description Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API.
       */
      version?: string;
      /** @description Unique server-generated endpoint ID. */
      id?: string;
      spec?: components['schemas']['v1EndpointSpec'];
      /**
       * Format: date-time
       * @description The date and time when the endpoint was created.
       */
      createdTime?: string;
      /**
       * Format: date-time
       * @description The date and time when the endpoint was last modified.
       *     Will not be set if the endpoint has never been modified.
       */
      lastModifiedTime?: string;
      /** @description Server exposed URL prefix for invocation of operations on this endpoint.
       *     This doesn't include the protocol, hostname or port as the server does not know how it should be accessed
       *     publicly. The URL is stable in the face of endpoint renames. */
      urlPrefix?: string;
    };
    /** @description Contains mutable fields for an Endpoint. */
    v1EndpointSpec: {
      /** @description Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.
       *     Renaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail. */
      name?: string;
      description?: components['schemas']['v1Payload'];
      target?: components['schemas']['v1EndpointTarget'];
    };
    /** @description Target to route requests to. */
    v1EndpointTarget: {
      worker?: components['schemas']['EndpointTargetWorker'];
      external?: components['schemas']['EndpointTargetExternal'];
    };
    /**
     * Whenever this list of events is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering
     * @description - EVENT_TYPE_UNSPECIFIED: Place holder and should never appear in a Workflow execution history
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_STARTED: Workflow execution has been triggered/started
     *     It contains Workflow execution inputs, as well as Workflow timeout configurations
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED: Workflow execution has successfully completed and contains Workflow execution results
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_FAILED: Workflow execution has unsuccessfully completed and contains the Workflow execution error
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT: Workflow execution has timed out by the Temporal Server
     *     Usually due to the Workflow having not been completed within timeout settings
     *      - EVENT_TYPE_WORKFLOW_TASK_SCHEDULED: Workflow Task has been scheduled and the SDK client should now be able to process any new history events
     *      - EVENT_TYPE_WORKFLOW_TASK_STARTED: Workflow Task has started and the SDK client has picked up the Workflow Task and is processing new history events
     *      - EVENT_TYPE_WORKFLOW_TASK_COMPLETED: Workflow Task has completed
     *     The SDK client picked up the Workflow Task and processed new history events
     *     SDK client may or may not ask the Temporal Server to do additional work, such as:
     *     EVENT_TYPE_ACTIVITY_TASK_SCHEDULED
     *     EVENT_TYPE_TIMER_STARTED
     *     EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES
     *     EVENT_TYPE_MARKER_RECORDED
     *     EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED
     *     EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED
     *     EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED
     *     EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED
     *     EVENT_TYPE_WORKFLOW_EXECUTION_FAILED
     *     EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED
     *     EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW
     *      - EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT: Workflow Task encountered a timeout
     *     Either an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the task
     *      - EVENT_TYPE_WORKFLOW_TASK_FAILED: Workflow Task encountered a failure
     *     Usually this means that the Workflow was non-deterministic
     *     However, the Workflow reset functionality also uses this event
     *      - EVENT_TYPE_ACTIVITY_TASK_SCHEDULED: Activity Task was scheduled
     *     The SDK client should pick up this activity task and execute
     *     This event type contains activity inputs, as well as activity timeout configurations
     *      - EVENT_TYPE_ACTIVITY_TASK_STARTED: Activity Task has started executing
     *     The SDK client has picked up the Activity Task and is processing the Activity invocation
     *      - EVENT_TYPE_ACTIVITY_TASK_COMPLETED: Activity Task has finished successfully
     *     The SDK client has picked up and successfully completed the Activity Task
     *     This event type contains Activity execution results
     *      - EVENT_TYPE_ACTIVITY_TASK_FAILED: Activity Task has finished unsuccessfully
     *     The SDK picked up the Activity Task but unsuccessfully completed it
     *     This event type contains Activity execution errors
     *      - EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT: Activity has timed out according to the Temporal Server
     *     Activity did not complete within the timeout settings
     *      - EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED: A request to cancel the Activity has occurred
     *     The SDK client will be able to confirm cancellation of an Activity during an Activity heartbeat
     *      - EVENT_TYPE_ACTIVITY_TASK_CANCELED: Activity has been cancelled
     *      - EVENT_TYPE_TIMER_STARTED: A timer has started
     *      - EVENT_TYPE_TIMER_FIRED: A timer has fired
     *      - EVENT_TYPE_TIMER_CANCELED: A time has been cancelled
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED: A request has been made to cancel the Workflow execution
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED: SDK client has confirmed the cancellation request and the Workflow execution has been cancelled
     *      - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Workflow has requested that the Temporal Server try to cancel another Workflow
     *      - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server could not cancel the targeted Workflow
     *     This is usually because the target Workflow could not be found
     *      - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED: Temporal Server has successfully requested the cancellation of the target Workflow
     *      - EVENT_TYPE_MARKER_RECORDED: A marker has been recorded.
     *     This event type is transparent to the Temporal Server
     *     The Server will only store it and will not try to understand it.
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED: Workflow has received a Signal event
     *     The event type contains the Signal name, as well as a Signal payload
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED: Workflow execution has been forcefully terminated
     *     This is usually because the terminate Workflow API was called
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW: Workflow has successfully completed and a new Workflow has been started within the same transaction
     *     Contains last Workflow execution results as well as new Workflow execution inputs
     *      - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to start a child Workflow
     *      - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution cannot be started/triggered
     *     Usually due to a child Workflow ID collision
     *      - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED: Child Workflow execution has successfully started/triggered
     *      - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED: Child Workflow execution has successfully completed
     *      - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution has unsuccessfully completed
     *      - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED: Child Workflow execution has been cancelled
     *      - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT: Child Workflow execution has timed out by the Temporal Server
     *      - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED: Child Workflow execution has been terminated
     *      - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to Signal the targeted Workflow
     *     Contains the Signal name, as well as a Signal payload
     *      - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server cannot Signal the targeted Workflow
     *     Usually because the Workflow could not be found
     *      - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED: Temporal Server has successfully Signaled the targeted Workflow
     *      - EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES: Workflow search attributes should be updated and synchronized with the visibility store
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED: An update was admitted. Note that not all admitted updates result in this
     *     event. See UpdateAdmittedEventOrigin for situations in which this event
     *     is created.
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED: An update was accepted (i.e. passed validation, perhaps because no validator was defined)
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED: This event is never written to history.
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED: An update completed
     *      - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of the workflow as a whole have changed by non-workflow code.
     *     The distinction of external vs. command-based modification is important so the SDK can
     *     maintain determinism when using the command-based approach.
     *      - EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of an already-scheduled activity have changed by non-workflow code.
     *     The distinction of external vs. command-based modification is important so the SDK can
     *     maintain determinism when using the command-based approach.
     *      - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED: Workflow properties modified by user workflow code
     *      - EVENT_TYPE_NEXUS_OPERATION_SCHEDULED: A Nexus operation was scheduled using a ScheduleNexusOperation command.
     *      - EVENT_TYPE_NEXUS_OPERATION_STARTED: An asynchronous Nexus operation was started by a Nexus handler.
     *      - EVENT_TYPE_NEXUS_OPERATION_COMPLETED: A Nexus operation completed successfully.
     *      - EVENT_TYPE_NEXUS_OPERATION_FAILED: A Nexus operation failed.
     *      - EVENT_TYPE_NEXUS_OPERATION_CANCELED: A Nexus operation completed as canceled.
     *      - EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT: A Nexus operation timed out.
     *      - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED: A Nexus operation was requested to be canceled using a RequestCancelNexusOperation command.
     *      - EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED: Workflow execution options updated by user.
     *      - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED: A cancellation request for a Nexus operation was successfully delivered to the Nexus handler.
     *      - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED: A cancellation request for a Nexus operation resulted in an error.
     * @default EVENT_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1EventType:
      | 'EVENT_TYPE_UNSPECIFIED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_STARTED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_FAILED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT'
      | 'EVENT_TYPE_WORKFLOW_TASK_SCHEDULED'
      | 'EVENT_TYPE_WORKFLOW_TASK_STARTED'
      | 'EVENT_TYPE_WORKFLOW_TASK_COMPLETED'
      | 'EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT'
      | 'EVENT_TYPE_WORKFLOW_TASK_FAILED'
      | 'EVENT_TYPE_ACTIVITY_TASK_SCHEDULED'
      | 'EVENT_TYPE_ACTIVITY_TASK_STARTED'
      | 'EVENT_TYPE_ACTIVITY_TASK_COMPLETED'
      | 'EVENT_TYPE_ACTIVITY_TASK_FAILED'
      | 'EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT'
      | 'EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED'
      | 'EVENT_TYPE_ACTIVITY_TASK_CANCELED'
      | 'EVENT_TYPE_TIMER_STARTED'
      | 'EVENT_TYPE_TIMER_FIRED'
      | 'EVENT_TYPE_TIMER_CANCELED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED'
      | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
      | 'EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
      | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED'
      | 'EVENT_TYPE_MARKER_RECORDED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW'
      | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED'
      | 'EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED'
      | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED'
      | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED'
      | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED'
      | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED'
      | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT'
      | 'EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED'
      | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED'
      | 'EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED'
      | 'EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED'
      | 'EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED'
      | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY'
      | 'EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY'
      | 'EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED'
      | 'EVENT_TYPE_NEXUS_OPERATION_SCHEDULED'
      | 'EVENT_TYPE_NEXUS_OPERATION_STARTED'
      | 'EVENT_TYPE_NEXUS_OPERATION_COMPLETED'
      | 'EVENT_TYPE_NEXUS_OPERATION_FAILED'
      | 'EVENT_TYPE_NEXUS_OPERATION_CANCELED'
      | 'EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT'
      | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED'
      | 'EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED'
      | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED'
      | 'EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED';
    /** @description IMPORTANT: For [StartWorkflow, UpdateWorkflow] combination ("Update-with-Start") when both
     *       1. the workflow update for the requested update ID has already completed, and
     *       2. the workflow for the requested workflow ID has already been closed,
     *     then you'll receive
     *       - an update response containing the update's outcome, and
     *       - a start response with a `status` field that reflects the workflow's current state. */
    v1ExecuteMultiOperationResponse: {
      responses?: components['schemas']['v1ExecuteMultiOperationResponseResponse'][];
    };
    v1ExecuteMultiOperationResponseResponse: {
      startWorkflow?: components['schemas']['v1StartWorkflowExecutionResponse'];
      updateWorkflow?: components['schemas']['v1UpdateWorkflowExecutionResponse'];
    };
    v1ExternalWorkflowExecutionCancelRequestedEventAttributes: {
      /**
       * id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds
       *     to
       * Format: int64
       */
      initiatedEventId?: string;
      /** @description Namespace of the to-be-cancelled workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
    };
    v1ExternalWorkflowExecutionSignaledEventAttributes: {
      /**
       * id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /** @description Namespace of the workflow which was signaled.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** @description Deprecated. */
      control?: string;
    };
    v1FailWorkflowExecutionCommandAttributes: {
      failure?: components['schemas']['apifailurev1Failure'];
    };
    /** Represents a historical replication status of a Namespace */
    v1FailoverStatus: {
      /**
       * Timestamp when the Cluster switched to the following failover_version
       * Format: date-time
       */
      failoverTime?: string;
      /** Format: int64 */
      failoverVersion?: string;
    };
    v1FetchWorkerConfigResponse: {
      workerConfig?: components['schemas']['v1WorkerConfig'];
    };
    /** @description GetClusterInfoResponse contains information about Temporal cluster. */
    v1GetClusterInfoResponse: {
      /** @description Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
       *     Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0". */
      supportedClients?: {
        [key: string]: string;
      };
      serverVersion?: string;
      clusterId?: string;
      versionInfo?: components['schemas']['v1VersionInfo'];
      clusterName?: string;
      /** Format: int32 */
      historyShardCount?: number;
      persistenceStore?: string;
      visibilityStore?: string;
      /** Format: int64 */
      initialFailoverVersion?: string;
      /** Format: int64 */
      failoverVersionIncrement?: string;
    };
    /** [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    v1GetCurrentDeploymentResponse: {
      currentDeploymentInfo?: components['schemas']['v1DeploymentInfo'];
    };
    /** [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    v1GetDeploymentReachabilityResponse: {
      deploymentInfo?: components['schemas']['v1DeploymentInfo'];
      reachability?: components['schemas']['v1DeploymentReachability'];
      /**
       * Format: date-time
       * @description Reachability level might come from server cache. This timestamp specifies when the value
       *     was actually calculated.
       */
      lastUpdateTime?: string;
    };
    v1GetNexusEndpointResponse: {
      endpoint?: components['schemas']['v1Endpoint'];
    };
    v1GetSearchAttributesResponse: {
      keys?: {
        [key: string]: components['schemas']['v1IndexedValueType'];
      };
    };
    v1GetSystemInfoResponse: {
      /** @description Version of the server. */
      serverVersion?: string;
      capabilities?: components['schemas']['v1GetSystemInfoResponseCapabilities'];
    };
    /** @description System capability details. */
    v1GetSystemInfoResponseCapabilities: {
      /** @description True if signal and query headers are supported. */
      signalAndQueryHeader?: boolean;
      /** @description True if internal errors are differentiated from other types of errors for purposes of
       *     retrying non-internal errors.
       *
       *     When unset/false, clients retry all failures. When true, clients should only retry
       *     non-internal errors. */
      internalErrorDifferentiation?: boolean;
      /** True if RespondActivityTaskFailed API supports including heartbeat details */
      activityFailureIncludeHeartbeat?: boolean;
      /** @description Supports scheduled workflow features. */
      supportsSchedules?: boolean;
      /** True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes */
      encodedFailureAttributes?: boolean;
      /** True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
       *     (see:
       *     https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md) */
      buildIdBasedVersioning?: boolean;
      /** True if server supports upserting workflow memo */
      upsertMemo?: boolean;
      /** True if server supports eager workflow task dispatching for the StartWorkflowExecution API */
      eagerWorkflowStart?: boolean;
      /** True if the server knows about the sdk metadata field on WFT completions and will record
       *     it in history */
      sdkMetadata?: boolean;
      /** True if the server supports count group by execution status */
      countGroupByExecutionStatus?: boolean;
      /** @description True if the server supports Nexus operations.
       *     This flag is dependent both on server version and for Nexus to be enabled via server configuration. */
      nexus?: boolean;
    };
    /** [cleanup-wv-pre-release] */
    v1GetWorkerBuildIdCompatibilityResponse: {
      /** @description Major version sets, in order from oldest to newest. The last element of the list will always
       *     be the current default major version. IE: New workflows will target the most recent version
       *     in that version set.
       *
       *     There may be fewer sets returned than exist, if the request chose to limit this response. */
      majorVersionSets?: components['schemas']['v1CompatibleVersionSet'][];
    };
    /** @description [cleanup-wv-pre-release]
     *     Deprecated. Use `DescribeTaskQueue`. */
    v1GetWorkerTaskReachabilityResponse: {
      /** @description Task reachability, broken down by build id and then task queue.
       *     When requesting a large number of task queues or all task queues associated with the given build ids in a
       *     namespace, all task queues will be listed in the response but some of them may not contain reachability
       *     information due to a server enforced limit. When reaching the limit, task queues that reachability information
       *     could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
       *     another call to get the reachability for those task queues.
       *
       *     Open source users can adjust this limit by setting the server's dynamic config value for
       *     `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store. */
      buildIdReachability?: components['schemas']['v1BuildIdReachability'][];
    };
    /** [cleanup-wv-pre-release] */
    v1GetWorkerVersioningRulesResponse: {
      assignmentRules?: components['schemas']['v1TimestampedBuildIdAssignmentRule'][];
      compatibleRedirectRules?: components['schemas']['v1TimestampedCompatibleBuildIdRedirectRule'][];
      /**
       * Format: byte
       * @description This value can be passed back to UpdateWorkerVersioningRulesRequest to
       *     ensure that the rules were not modified between this List and the Update,
       *     which could lead to lost updates and other confusion.
       */
      conflictToken?: string;
    };
    v1GetWorkflowExecutionHistoryResponse: {
      history?: components['schemas']['v1History'];
      /** @description Raw history is an alternate representation of history that may be returned if configured on
       *     the frontend. This is not supported by all SDKs. Either this or `history` will be set. */
      rawHistory?: components['schemas']['v1DataBlob'][];
      /**
       * Will be set if there are more history events than were included in this response
       * Format: byte
       */
      nextPageToken?: string;
      archived?: boolean;
    };
    v1GetWorkflowExecutionHistoryReverseResponse: {
      history?: components['schemas']['v1History'];
      /**
       * Will be set if there are more history events than were included in this response
       * Format: byte
       */
      nextPageToken?: string;
    };
    v1HandlerError: {
      /** @description See https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors. */
      errorType?: string;
      failure?: components['schemas']['apinexusv1Failure'];
      retryBehavior?: components['schemas']['v1NexusHandlerErrorRetryBehavior'];
    };
    /** @description Contains metadata that can be attached to a variety of requests, like starting a workflow, and
     *     can be propagated between, for example, workflows and activities. */
    v1Header: {
      fields?: {
        [key: string]: components['schemas']['v1Payload'];
      };
    };
    v1History: {
      events?: components['schemas']['v1HistoryEvent'][];
    };
    /** @description History events are the method by which Temporal SDKs advance (or recreate) workflow state.
     *     See the `EventType` enum for more info about what each event is for. */
    v1HistoryEvent: {
      /**
       * Format: int64
       * @description Monotonically increasing event number, starts at 1.
       */
      eventId?: string;
      /** Format: date-time */
      eventTime?: string;
      eventType?: components['schemas']['v1EventType'];
      /**
       * TODO: What is this? Appears unused by SDKs
       * Format: int64
       */
      version?: string;
      /**
       * TODO: What is this? Appears unused by SDKs
       * Format: int64
       */
      taskId?: string;
      /** @description Set to true when the SDK may ignore the event as it does not impact workflow state or
       *     information in any way that the SDK need be concerned with. If an SDK encounters an event
       *     type which it does not understand, it must error unless this is true. If it is true, it's
       *     acceptable for the event type and/or attributes to be uninterpretable. */
      workerMayIgnore?: boolean;
      userMetadata?: components['schemas']['v1UserMetadata'];
      /** @description Links associated with the event. */
      links?: components['schemas']['apicommonv1Link'][];
      workflowExecutionStartedEventAttributes?: components['schemas']['v1WorkflowExecutionStartedEventAttributes'];
      workflowExecutionCompletedEventAttributes?: components['schemas']['v1WorkflowExecutionCompletedEventAttributes'];
      workflowExecutionFailedEventAttributes?: components['schemas']['v1WorkflowExecutionFailedEventAttributes'];
      workflowExecutionTimedOutEventAttributes?: components['schemas']['v1WorkflowExecutionTimedOutEventAttributes'];
      workflowTaskScheduledEventAttributes?: components['schemas']['v1WorkflowTaskScheduledEventAttributes'];
      workflowTaskStartedEventAttributes?: components['schemas']['v1WorkflowTaskStartedEventAttributes'];
      workflowTaskCompletedEventAttributes?: components['schemas']['v1WorkflowTaskCompletedEventAttributes'];
      workflowTaskTimedOutEventAttributes?: components['schemas']['v1WorkflowTaskTimedOutEventAttributes'];
      workflowTaskFailedEventAttributes?: components['schemas']['v1WorkflowTaskFailedEventAttributes'];
      activityTaskScheduledEventAttributes?: components['schemas']['v1ActivityTaskScheduledEventAttributes'];
      activityTaskStartedEventAttributes?: components['schemas']['v1ActivityTaskStartedEventAttributes'];
      activityTaskCompletedEventAttributes?: components['schemas']['v1ActivityTaskCompletedEventAttributes'];
      activityTaskFailedEventAttributes?: components['schemas']['v1ActivityTaskFailedEventAttributes'];
      activityTaskTimedOutEventAttributes?: components['schemas']['v1ActivityTaskTimedOutEventAttributes'];
      timerStartedEventAttributes?: components['schemas']['v1TimerStartedEventAttributes'];
      timerFiredEventAttributes?: components['schemas']['v1TimerFiredEventAttributes'];
      activityTaskCancelRequestedEventAttributes?: components['schemas']['v1ActivityTaskCancelRequestedEventAttributes'];
      activityTaskCanceledEventAttributes?: components['schemas']['v1ActivityTaskCanceledEventAttributes'];
      timerCanceledEventAttributes?: components['schemas']['v1TimerCanceledEventAttributes'];
      markerRecordedEventAttributes?: components['schemas']['v1MarkerRecordedEventAttributes'];
      workflowExecutionSignaledEventAttributes?: components['schemas']['v1WorkflowExecutionSignaledEventAttributes'];
      workflowExecutionTerminatedEventAttributes?: components['schemas']['v1WorkflowExecutionTerminatedEventAttributes'];
      workflowExecutionCancelRequestedEventAttributes?: components['schemas']['v1WorkflowExecutionCancelRequestedEventAttributes'];
      workflowExecutionCanceledEventAttributes?: components['schemas']['v1WorkflowExecutionCanceledEventAttributes'];
      requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: components['schemas']['v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes'];
      requestCancelExternalWorkflowExecutionFailedEventAttributes?: components['schemas']['v1RequestCancelExternalWorkflowExecutionFailedEventAttributes'];
      externalWorkflowExecutionCancelRequestedEventAttributes?: components['schemas']['v1ExternalWorkflowExecutionCancelRequestedEventAttributes'];
      workflowExecutionContinuedAsNewEventAttributes?: components['schemas']['v1WorkflowExecutionContinuedAsNewEventAttributes'];
      startChildWorkflowExecutionInitiatedEventAttributes?: components['schemas']['v1StartChildWorkflowExecutionInitiatedEventAttributes'];
      startChildWorkflowExecutionFailedEventAttributes?: components['schemas']['v1StartChildWorkflowExecutionFailedEventAttributes'];
      childWorkflowExecutionStartedEventAttributes?: components['schemas']['v1ChildWorkflowExecutionStartedEventAttributes'];
      childWorkflowExecutionCompletedEventAttributes?: components['schemas']['v1ChildWorkflowExecutionCompletedEventAttributes'];
      childWorkflowExecutionFailedEventAttributes?: components['schemas']['v1ChildWorkflowExecutionFailedEventAttributes'];
      childWorkflowExecutionCanceledEventAttributes?: components['schemas']['v1ChildWorkflowExecutionCanceledEventAttributes'];
      childWorkflowExecutionTimedOutEventAttributes?: components['schemas']['v1ChildWorkflowExecutionTimedOutEventAttributes'];
      childWorkflowExecutionTerminatedEventAttributes?: components['schemas']['v1ChildWorkflowExecutionTerminatedEventAttributes'];
      signalExternalWorkflowExecutionInitiatedEventAttributes?: components['schemas']['v1SignalExternalWorkflowExecutionInitiatedEventAttributes'];
      signalExternalWorkflowExecutionFailedEventAttributes?: components['schemas']['v1SignalExternalWorkflowExecutionFailedEventAttributes'];
      externalWorkflowExecutionSignaledEventAttributes?: components['schemas']['v1ExternalWorkflowExecutionSignaledEventAttributes'];
      upsertWorkflowSearchAttributesEventAttributes?: components['schemas']['v1UpsertWorkflowSearchAttributesEventAttributes'];
      workflowExecutionUpdateAcceptedEventAttributes?: components['schemas']['v1WorkflowExecutionUpdateAcceptedEventAttributes'];
      workflowExecutionUpdateRejectedEventAttributes?: components['schemas']['v1WorkflowExecutionUpdateRejectedEventAttributes'];
      workflowExecutionUpdateCompletedEventAttributes?: components['schemas']['v1WorkflowExecutionUpdateCompletedEventAttributes'];
      workflowPropertiesModifiedExternallyEventAttributes?: components['schemas']['v1WorkflowPropertiesModifiedExternallyEventAttributes'];
      activityPropertiesModifiedExternallyEventAttributes?: components['schemas']['v1ActivityPropertiesModifiedExternallyEventAttributes'];
      workflowPropertiesModifiedEventAttributes?: components['schemas']['v1WorkflowPropertiesModifiedEventAttributes'];
      workflowExecutionUpdateAdmittedEventAttributes?: components['schemas']['v1WorkflowExecutionUpdateAdmittedEventAttributes'];
      nexusOperationScheduledEventAttributes?: components['schemas']['v1NexusOperationScheduledEventAttributes'];
      nexusOperationStartedEventAttributes?: components['schemas']['v1NexusOperationStartedEventAttributes'];
      nexusOperationCompletedEventAttributes?: components['schemas']['v1NexusOperationCompletedEventAttributes'];
      nexusOperationFailedEventAttributes?: components['schemas']['v1NexusOperationFailedEventAttributes'];
      nexusOperationCanceledEventAttributes?: components['schemas']['v1NexusOperationCanceledEventAttributes'];
      nexusOperationTimedOutEventAttributes?: components['schemas']['v1NexusOperationTimedOutEventAttributes'];
      nexusOperationCancelRequestedEventAttributes?: components['schemas']['v1NexusOperationCancelRequestedEventAttributes'];
      workflowExecutionOptionsUpdatedEventAttributes?: components['schemas']['v1WorkflowExecutionOptionsUpdatedEventAttributes'];
      nexusOperationCancelRequestCompletedEventAttributes?: components['schemas']['v1NexusOperationCancelRequestCompletedEventAttributes'];
      nexusOperationCancelRequestFailedEventAttributes?: components['schemas']['v1NexusOperationCancelRequestFailedEventAttributes'];
    };
    /**
     * @default HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1HistoryEventFilterType:
      | 'HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED'
      | 'HISTORY_EVENT_FILTER_TYPE_ALL_EVENT'
      | 'HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT';
    /**
     * @default INDEXED_VALUE_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1IndexedValueType:
      | 'INDEXED_VALUE_TYPE_UNSPECIFIED'
      | 'INDEXED_VALUE_TYPE_TEXT'
      | 'INDEXED_VALUE_TYPE_KEYWORD'
      | 'INDEXED_VALUE_TYPE_INT'
      | 'INDEXED_VALUE_TYPE_DOUBLE'
      | 'INDEXED_VALUE_TYPE_BOOL'
      | 'INDEXED_VALUE_TYPE_DATETIME'
      | 'INDEXED_VALUE_TYPE_KEYWORD_LIST';
    v1Input: {
      header?: components['schemas']['v1Header'];
      /** @description The name of the Update handler to invoke on the target Workflow. */
      name?: string;
      args?: components['schemas']['v1Payloads'];
    };
    /** @description IntervalSpec matches times that can be expressed as:
     *     epoch + n * interval + phase
     *     where n is an integer.
     *     phase defaults to zero if missing. interval is required.
     *     Both interval and phase must be non-negative and are truncated to the nearest
     *     second before any calculations.
     *     For example, an interval of 1 hour with phase of zero would match every hour,
     *     on the hour. The same interval but a phase of 19 minutes would match every
     *     xx:19:00. An interval of 28 days with phase zero would match
     *     2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
     *     days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead. */
    v1IntervalSpec: {
      interval?: string;
      phase?: string;
    };
    v1ListArchivedWorkflowExecutionsResponse: {
      executions?: components['schemas']['v1WorkflowExecutionInfo'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListBatchOperationsResponse: {
      /** BatchOperationInfo contains the basic info about batch operation */
      operationInfo?: components['schemas']['v1BatchOperationInfo'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListClosedWorkflowExecutionsResponse: {
      executions?: components['schemas']['v1WorkflowExecutionInfo'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListClustersResponse: {
      /** List of all cluster information */
      clusters?: components['schemas']['v1ClusterMetadata'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    /** [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    v1ListDeploymentsResponse: {
      /** Format: byte */
      nextPageToken?: string;
      deployments?: components['schemas']['v1DeploymentListInfo'][];
    };
    v1ListNamespacesResponse: {
      namespaces?: components['schemas']['v1DescribeNamespaceResponse'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListNexusEndpointsResponse: {
      /**
       * Format: byte
       * @description Token for getting the next page.
       */
      nextPageToken?: string;
      endpoints?: components['schemas']['v1Endpoint'][];
    };
    v1ListOpenWorkflowExecutionsResponse: {
      executions?: components['schemas']['v1WorkflowExecutionInfo'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListScheduleMatchingTimesResponse: {
      startTime?: string[];
    };
    v1ListSchedulesResponse: {
      schedules?: components['schemas']['v1ScheduleListEntry'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListSearchAttributesResponse: {
      /** @description Mapping between custom (user-registered) search attribute name to its IndexedValueType. */
      customAttributes?: {
        [key: string]: components['schemas']['v1IndexedValueType'];
      };
      /** @description Mapping between system (predefined) search attribute name to its IndexedValueType. */
      systemAttributes?: {
        [key: string]: components['schemas']['v1IndexedValueType'];
      };
      /** @description Mapping from the attribute name to the visibility storage native type. */
      storageSchema?: {
        [key: string]: string;
      };
    };
    v1ListTaskQueuePartitionsResponse: {
      activityTaskQueuePartitions?: components['schemas']['v1TaskQueuePartitionMetadata'][];
      workflowTaskQueuePartitions?: components['schemas']['v1TaskQueuePartitionMetadata'][];
    };
    v1ListWorkerDeploymentsResponse: {
      /** Format: byte */
      nextPageToken?: string;
      /** @description The list of worker deployments. */
      workerDeployments?: components['schemas']['ListWorkerDeploymentsResponseWorkerDeploymentSummary'][];
    };
    v1ListWorkersResponse: {
      workersInfo?: components['schemas']['v1WorkerInfo'][];
      /**
       * Next page token
       * Format: byte
       */
      nextPageToken?: string;
    };
    v1ListWorkflowExecutionsResponse: {
      executions?: components['schemas']['v1WorkflowExecutionInfo'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1ListWorkflowRulesResponse: {
      rules?: components['schemas']['v1WorkflowRule'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1MarkerRecordedEventAttributes: {
      /** @description Workers use this to identify the "types" of various markers. Ex: Local activity, side effect. */
      markerName?: string;
      /** Serialized information recorded in the marker */
      details?: {
        [key: string]: components['schemas']['v1Payloads'];
      };
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      header?: components['schemas']['v1Header'];
      failure?: components['schemas']['apifailurev1Failure'];
    };
    /** A user-defined set of *unindexed* fields that are exposed when listing/searching workflows */
    v1Memo: {
      fields?: {
        [key: string]: components['schemas']['v1Payload'];
      };
    };
    v1Message: {
      /** @description An ID for this specific message. */
      id?: string;
      /** @description Identifies the specific instance of a protocol to which this message
       *     belongs. */
      protocolInstanceId?: string;
      /** Format: int64 */
      eventId?: string;
      /** Format: int64 */
      commandIndex?: string;
      body?: components['schemas']['protobufAny'];
    };
    /** @description Metadata about a Workflow Update. */
    v1Meta: {
      /** @description An ID with workflow-scoped uniqueness for this Update. */
      updateId?: string;
      /** @description A string identifying the agent that requested this Update. */
      identity?: string;
    };
    /** Metadata relevant for metering purposes */
    v1MeteringMetadata: {
      /**
       * Format: int64
       * @description Count of local activities which have begun an execution attempt during this workflow task,
       *     and whose first attempt occurred in some previous task. This is used for metering
       *     purposes, and does not affect workflow state.
       *
       */
      nonfirstLocalActivityExecutionAttempts?: number;
    };
    v1ModifyWorkflowPropertiesCommandAttributes: {
      upsertedMemo?: components['schemas']['v1Memo'];
    };
    v1NamespaceConfig: {
      workflowExecutionRetentionTtl?: string;
      badBinaries?: components['schemas']['v1BadBinaries'];
      historyArchivalState?: components['schemas']['v1ArchivalState'];
      historyArchivalUri?: string;
      visibilityArchivalState?: components['schemas']['v1ArchivalState'];
      visibilityArchivalUri?: string;
      /** @description Map from field name to alias. */
      customSearchAttributeAliases?: {
        [key: string]: string;
      };
    };
    v1NamespaceFilter: {
      /** @description By default namespaces in NAMESPACE_STATE_DELETED state are not included.
       *     Setting include_deleted to true will include deleted namespaces.
       *     Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet. */
      includeDeleted?: boolean;
    };
    v1NamespaceInfo: {
      name?: string;
      state?: components['schemas']['v1NamespaceState'];
      description?: string;
      ownerEmail?: string;
      /** @description A key-value map for any customized purpose. */
      data?: {
        [key: string]: string;
      };
      id?: string;
      capabilities?: components['schemas']['v1NamespaceInfoCapabilities'];
      /** @description Whether scheduled workflows are supported on this namespace. This is only needed
       *     temporarily while the feature is experimental, so we can give it a high tag. */
      supportsSchedules?: boolean;
    };
    /** @description Namespace capability details. Should contain what features are enabled in a namespace. */
    v1NamespaceInfoCapabilities: {
      /** @description True if the namespace supports eager workflow start. */
      eagerWorkflowStart?: boolean;
      /** True if the namespace supports sync update */
      syncUpdate?: boolean;
      /** True if the namespace supports async update */
      asyncUpdate?: boolean;
      /** True if the namespace supports worker heartbeats */
      workerHeartbeats?: boolean;
    };
    v1NamespaceReplicationConfig: {
      activeClusterName?: string;
      clusters?: components['schemas']['v1ClusterReplicationConfig'][];
      state?: components['schemas']['v1ReplicationState'];
    };
    /**
     * @default NAMESPACE_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1NamespaceState:
      | 'NAMESPACE_STATE_UNSPECIFIED'
      | 'NAMESPACE_STATE_REGISTERED'
      | 'NAMESPACE_STATE_DEPRECATED'
      | 'NAMESPACE_STATE_DELETED';
    /** @description NewWorkflowExecutionInfo is a shared message that encapsulates all the
     *     required arguments to starting a workflow in different contexts. */
    v1NewWorkflowExecutionInfo: {
      workflowId?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      workflowIdReusePolicy?: components['schemas']['v1WorkflowIdReusePolicy'];
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      header?: components['schemas']['v1Header'];
      userMetadata?: components['schemas']['v1UserMetadata'];
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      priority?: components['schemas']['v1Priority'];
    };
    /**
     * @description NexusHandlerErrorRetryBehavior allows nexus handlers to explicity set the retry behavior of a HandlerError. If not
     *     specified, retry behavior is determined from the error type. For example internal errors are not retryable by default
     *     unless specified otherwise.
     *
     *      - NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE: A handler error is explicitly marked as retryable.
     *      - NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE: A handler error is explicitly marked as non-retryable.
     * @default NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED
     * @enum {string}
     */
    v1NexusHandlerErrorRetryBehavior:
      | 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED'
      | 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE'
      | 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE';
    v1NexusHandlerFailureInfo: {
      /** @description The Nexus error type as defined in the spec:
       *     https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors. */
      type?: string;
      retryBehavior?: components['schemas']['v1NexusHandlerErrorRetryBehavior'];
    };
    v1NexusOperationCancelRequestCompletedEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event.
       */
      requestedEventId?: string;
      /**
       * Format: int64
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *     with.
       */
      workflowTaskCompletedEventId?: string;
      /**
       * Format: int64
       * @description The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
       */
      scheduledEventId?: string;
    };
    v1NexusOperationCancelRequestFailedEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event.
       */
      requestedEventId?: string;
      /**
       * Format: int64
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *     with.
       */
      workflowTaskCompletedEventId?: string;
      failure?: components['schemas']['apifailurev1Failure'];
      /**
       * Format: int64
       * @description The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
       */
      scheduledEventId?: string;
    };
    v1NexusOperationCancelRequestedEventAttributes: {
      /**
       * Format: int64
       * @description The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
       */
      scheduledEventId?: string;
      /**
       * Format: int64
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
       *     with.
       */
      workflowTaskCompletedEventId?: string;
    };
    /** @description Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow. */
    v1NexusOperationCanceledEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
       */
      scheduledEventId?: string;
      failure?: components['schemas']['apifailurev1Failure'];
      /** @description The request ID allocated at schedule time. */
      requestId?: string;
    };
    /** @description NexusOperationCancellationInfo contains the state of a nexus operation cancellation. */
    v1NexusOperationCancellationInfo: {
      /**
       * Format: date-time
       * @description The time when cancellation was requested.
       */
      requestedTime?: string;
      state?: components['schemas']['v1NexusOperationCancellationState'];
      /**
       * Format: int32
       * @description The number of attempts made to deliver the cancel operation request.
       *     This number represents a minimum bound since the attempt is incremented after the request completes.
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      lastAttemptCompleteTime?: string;
      lastAttemptFailure?: components['schemas']['apifailurev1Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      nextAttemptScheduleTime?: string;
      /** @description If the state is BLOCKED, blocked reason provides additional information. */
      blockedReason?: string;
    };
    /**
     * @description State of a Nexus operation cancellation.
     *
     *      - NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED: Default value, unspecified state.
     *      - NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED: Cancellation request is in the queue waiting to be executed or is currently executing.
     *      - NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF: Cancellation request has failed with a retryable error and is backing off before the next attempt.
     *      - NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED: Cancellation request succeeded.
     *      - NEXUS_OPERATION_CANCELLATION_STATE_FAILED: Cancellation request failed with a non-retryable error.
     *      - NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT: The associated operation timed out - exceeded the user supplied schedule-to-close timeout.
     *      - NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED: Cancellation request is blocked (eg: by circuit breaker).
     * @default NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1NexusOperationCancellationState:
      | 'NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED'
      | 'NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED'
      | 'NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF'
      | 'NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED'
      | 'NEXUS_OPERATION_CANCELLATION_STATE_FAILED'
      | 'NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT'
      | 'NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED';
    /** @description Nexus operation completed successfully. */
    v1NexusOperationCompletedEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
       */
      scheduledEventId?: string;
      result?: components['schemas']['v1Payload'];
      /** @description The request ID allocated at schedule time. */
      requestId?: string;
    };
    /** @description Nexus operation failed. */
    v1NexusOperationFailedEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
       */
      scheduledEventId?: string;
      failure?: components['schemas']['apifailurev1Failure'];
      /** @description The request ID allocated at schedule time. */
      requestId?: string;
    };
    v1NexusOperationFailureInfo: {
      /**
       * Format: int64
       * @description The NexusOperationScheduled event ID.
       */
      scheduledEventId?: string;
      /** @description Endpoint name. */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      /** @description Operation ID - may be empty if the operation completed synchronously.
       *
       *     Deprecated. Renamed to operation_token. */
      operationId?: string;
      /** @description Operation token - may be empty if the operation completed synchronously. */
      operationToken?: string;
    };
    /** @description Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command. */
    v1NexusOperationScheduledEventAttributes: {
      /** @description Endpoint name, must exist in the endpoint registry. */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      input?: components['schemas']['v1Payload'];
      /** @description Schedule-to-close timeout for this operation.
       *     Indicates how long the caller is willing to wait for operation completion.
       *     Calls are retried internally by the server. */
      scheduleToCloseTimeout?: string;
      /** @description Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal
       *     activities and child workflows, these are transmitted to Nexus operations that may be external and are not
       *     traditional payloads. */
      nexusHeader?: {
        [key: string]: string;
      };
      /**
       * Format: int64
       * @description The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with.
       */
      workflowTaskCompletedEventId?: string;
      /** @description A unique ID generated by the history service upon creation of this event.
       *     The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key. */
      requestId?: string;
      /** @description Endpoint ID as resolved in the endpoint registry at the time this event was generated.
       *     This is stored on the event and used internally by the server in case the endpoint is renamed from the time the
       *     event was originally scheduled. */
      endpointId?: string;
    };
    /** @description Event marking an asynchronous operation was started by the responding Nexus handler.
     *     If the operation completes synchronously, this event is not generated.
     *     In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate
     *     this event upon receiving the operation completion via callback. */
    v1NexusOperationStartedEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to.
       */
      scheduledEventId?: string;
      /** @description The operation ID returned by the Nexus handler in the response to the StartOperation request.
       *     This ID is used when canceling the operation.
       *
       *     Deprecated: Renamed to operation_token. */
      operationId?: string;
      /** @description The request ID allocated at schedule time. */
      requestId?: string;
      /** @description The operation token returned by the Nexus handler in the response to the StartOperation request.
       *     This token is used when canceling the operation. */
      operationToken?: string;
    };
    /** @description Nexus operation timed out. */
    v1NexusOperationTimedOutEventAttributes: {
      /**
       * Format: int64
       * @description The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
       */
      scheduledEventId?: string;
      failure?: components['schemas']['apifailurev1Failure'];
      /** @description The request ID allocated at schedule time. */
      requestId?: string;
    };
    /** @description When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
     *     there is already an existing running workflow, OnConflictOptions defines actions to be taken on
     *     the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
     *     history event in the running workflow with the changes requested in this object. */
    v1OnConflictOptions: {
      /** @description Attaches the request ID to the running workflow. */
      attachRequestId?: boolean;
      /** @description Attaches the completion callbacks to the running workflow. */
      attachCompletionCallbacks?: boolean;
      /** @description Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event. */
      attachLinks?: boolean;
    };
    /** @description The outcome of a Workflow Update: success or failure. */
    v1Outcome: {
      success?: components['schemas']['v1Payloads'];
      failure?: components['schemas']['apifailurev1Failure'];
    };
    /**
     * Defines how child workflows will react to their parent completing
     * @description - PARENT_CLOSE_POLICY_TERMINATE: The child workflow will also terminate
     *      - PARENT_CLOSE_POLICY_ABANDON: The child workflow will do nothing
     *      - PARENT_CLOSE_POLICY_REQUEST_CANCEL: Cancellation will be requested of the child workflow
     * @default PARENT_CLOSE_POLICY_UNSPECIFIED
     * @enum {string}
     */
    v1ParentClosePolicy:
      | 'PARENT_CLOSE_POLICY_UNSPECIFIED'
      | 'PARENT_CLOSE_POLICY_TERMINATE'
      | 'PARENT_CLOSE_POLICY_ABANDON'
      | 'PARENT_CLOSE_POLICY_REQUEST_CANCEL';
    v1PatchScheduleResponse: Record<string, never>;
    v1PauseActivityResponse: Record<string, never>;
    /** @description Arbitrary payload data in an unconstrained format.
     *     This may be activity input parameters, a workflow result, a memo, etc.
     *      */
    v1Payload: unknown;
    /** See `Payload` */
    v1Payloads: {
      payloads?: components['schemas']['v1Payload'][];
    };
    v1PendingActivityInfo: {
      activityId?: string;
      activityType?: components['schemas']['v1ActivityType'];
      state?: components['schemas']['v1PendingActivityState'];
      heartbeatDetails?: components['schemas']['v1Payloads'];
      /** Format: date-time */
      lastHeartbeatTime?: string;
      /** Format: date-time */
      lastStartedTime?: string;
      /** Format: int32 */
      attempt?: number;
      /** Format: int32 */
      maximumAttempts?: number;
      /** Format: date-time */
      scheduledTime?: string;
      /** Format: date-time */
      expirationTime?: string;
      lastFailure?: components['schemas']['apifailurev1Failure'];
      lastWorkerIdentity?: string;
      /** @description Deprecated. When present, it means this activity is assigned to the build ID of its workflow. */
      useWorkflowBuildId?: Record<string, never>;
      /** @description Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
       *     The activity will use the build id in this field instead.
       *     If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
       *     rules. */
      lastIndependentlyAssignedBuildId?: string;
      lastWorkerVersionStamp?: components['schemas']['v1WorkerVersionStamp'];
      /** @description The time activity will wait until the next retry.
       *     If activity is currently running it will be next retry interval if activity failed.
       *     If activity is currently waiting it will be current retry interval.
       *     If there will be no retry it will be null. */
      currentRetryInterval?: string;
      /**
       * Format: date-time
       * @description The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
       */
      lastAttemptCompleteTime?: string;
      /**
       * Format: date-time
       * @description Next time when activity will be scheduled.
       *     If activity is currently scheduled or started it will be null.
       */
      nextAttemptScheduleTime?: string;
      /** @description Indicates if activity is paused. */
      paused?: boolean;
      lastDeployment?: components['schemas']['v1Deployment'];
      /** @description The Worker Deployment Version this activity was dispatched to most recently.
       *     Deprecated. Use `last_deployment_version`. */
      lastWorkerDeploymentVersion?: string;
      lastDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      priority?: components['schemas']['v1Priority'];
      pauseInfo?: components['schemas']['PendingActivityInfoPauseInfo'];
      activityOptions?: components['schemas']['v1ActivityOptions'];
    };
    /**
     * - PENDING_ACTIVITY_STATE_PAUSED: PAUSED means activity is paused on the server, and is not running in the worker
     *      - PENDING_ACTIVITY_STATE_PAUSE_REQUESTED: PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
     * @default PENDING_ACTIVITY_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1PendingActivityState:
      | 'PENDING_ACTIVITY_STATE_UNSPECIFIED'
      | 'PENDING_ACTIVITY_STATE_SCHEDULED'
      | 'PENDING_ACTIVITY_STATE_STARTED'
      | 'PENDING_ACTIVITY_STATE_CANCEL_REQUESTED'
      | 'PENDING_ACTIVITY_STATE_PAUSED'
      | 'PENDING_ACTIVITY_STATE_PAUSE_REQUESTED';
    v1PendingChildExecutionInfo: {
      workflowId?: string;
      runId?: string;
      workflowTypeName?: string;
      /** Format: int64 */
      initiatedId?: string;
      parentClosePolicy?: components['schemas']['v1ParentClosePolicy'];
    };
    /** @description PendingNexusOperationInfo contains the state of a pending Nexus operation. */
    v1PendingNexusOperationInfo: {
      /** @description Endpoint name.
       *     Resolved to a URL via the cluster's endpoint registry. */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      /** @description Operation ID. Only set for asynchronous operations after a successful StartOperation call.
       *
       *     Deprecated. Renamed to operation_token. */
      operationId?: string;
      /** @description Schedule-to-close timeout for this operation.
       *     This is the only timeout settable by a workflow. */
      scheduleToCloseTimeout?: string;
      /**
       * Format: date-time
       * @description The time when the operation was scheduled.
       */
      scheduledTime?: string;
      state?: components['schemas']['v1PendingNexusOperationState'];
      /**
       * Format: int32
       * @description The number of attempts made to deliver the start operation request.
       *     This number represents a minimum bound since the attempt is incremented after the request completes.
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The time when the last attempt completed.
       */
      lastAttemptCompleteTime?: string;
      lastAttemptFailure?: components['schemas']['apifailurev1Failure'];
      /**
       * Format: date-time
       * @description The time when the next attempt is scheduled.
       */
      nextAttemptScheduleTime?: string;
      cancellationInfo?: components['schemas']['v1NexusOperationCancellationInfo'];
      /**
       * Format: int64
       * @description The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
       *     DescribeWorkflowExecution response with workflow history.
       */
      scheduledEventId?: string;
      /** @description If the state is BLOCKED, blocked reason provides additional information. */
      blockedReason?: string;
      /** @description Operation token. Only set for asynchronous operations after a successful StartOperation call. */
      operationToken?: string;
    };
    /**
     * @description State of a pending Nexus operation.
     *
     *      - PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED: Default value, unspecified state.
     *      - PENDING_NEXUS_OPERATION_STATE_SCHEDULED: Operation is in the queue waiting to be executed or is currently executing.
     *      - PENDING_NEXUS_OPERATION_STATE_BACKING_OFF: Operation has failed with a retryable error and is backing off before the next attempt.
     *      - PENDING_NEXUS_OPERATION_STATE_STARTED: Operation was started and will complete asynchronously.
     *      - PENDING_NEXUS_OPERATION_STATE_BLOCKED: Operation is blocked (eg: by circuit breaker).
     * @default PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1PendingNexusOperationState:
      | 'PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED'
      | 'PENDING_NEXUS_OPERATION_STATE_SCHEDULED'
      | 'PENDING_NEXUS_OPERATION_STATE_BACKING_OFF'
      | 'PENDING_NEXUS_OPERATION_STATE_STARTED'
      | 'PENDING_NEXUS_OPERATION_STATE_BLOCKED';
    v1PendingWorkflowTaskInfo: {
      state?: components['schemas']['v1PendingWorkflowTaskState'];
      /** Format: date-time */
      scheduledTime?: string;
      /**
       * Format: date-time
       * @description original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
       *     Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
       *     In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
       *     some threshold, the workflow task will be forced timeout.
       */
      originalScheduledTime?: string;
      /** Format: date-time */
      startedTime?: string;
      /** Format: int32 */
      attempt?: number;
    };
    /**
     * @default PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1PendingWorkflowTaskState:
      | 'PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED'
      | 'PENDING_WORKFLOW_TASK_STATE_SCHEDULED'
      | 'PENDING_WORKFLOW_TASK_STATE_STARTED';
    v1PluginInfo: {
      /** @description The name of the plugin, required. */
      name?: string;
      /** @description The version of the plugin, may be empty. */
      version?: string;
    };
    v1PollActivityTaskQueueResponse: {
      /**
       * A unique identifier for this task
       * Format: byte
       */
      taskToken?: string;
      /** The namespace the workflow which requested this activity lives in */
      workflowNamespace?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      activityType?: components['schemas']['v1ActivityType'];
      /** @description The autogenerated or user specified identifier of this activity. Can be used to complete the
       *     activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
       *     has resolved, but unique IDs for every activity invocation is a good idea. */
      activityId?: string;
      header?: components['schemas']['v1Header'];
      input?: components['schemas']['v1Payloads'];
      heartbeatDetails?: components['schemas']['v1Payloads'];
      /**
       * When was this task first scheduled
       * Format: date-time
       */
      scheduledTime?: string;
      /**
       * When was this task attempt scheduled
       * Format: date-time
       */
      currentAttemptScheduledTime?: string;
      /**
       * When was this task started (this attempt)
       * Format: date-time
       */
      startedTime?: string;
      /**
       * Starting at 1, the number of attempts to perform this activity
       * Format: int32
       */
      attempt?: number;
      /** First scheduled -> final result reported timeout */
      scheduleToCloseTimeout?: string;
      /** Current attempt start -> final result reported timeout */
      startToCloseTimeout?: string;
      /** @description Window within which the activity must report a heartbeat, or be timed out. */
      heartbeatTimeout?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      pollerScalingDecision?: components['schemas']['v1PollerScalingDecision'];
      priority?: components['schemas']['v1Priority'];
    };
    v1PollNexusTaskQueueResponse: {
      /**
       * Format: byte
       * @description An opaque unique identifier for this task for correlating a completion request the embedded request.
       */
      taskToken?: string;
      request?: components['schemas']['apinexusv1Request'];
      pollerScalingDecision?: components['schemas']['v1PollerScalingDecision'];
    };
    v1PollWorkflowExecutionUpdateResponse: {
      outcome?: components['schemas']['v1Outcome'];
      stage?: components['schemas']['v1UpdateWorkflowExecutionLifecycleStage'];
      updateRef?: components['schemas']['v1UpdateRef'];
    };
    v1PollWorkflowTaskQueueResponse: {
      /**
       * A unique identifier for this task
       * Format: byte
       */
      taskToken?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /**
       * Format: int64
       * @description The last workflow task started event which was processed by some worker for this execution.
       *     Will be zero if no task has ever started.
       */
      previousStartedEventId?: string;
      /**
       * Format: int64
       * @description The id of the most recent workflow task started event, which will have been generated as a
       *     result of this poll request being served. Will be zero if the task
       *     does not contain any events which would advance history (no new WFT started).
       *     Currently this can happen for queries.
       */
      startedEventId?: string;
      /**
       * Format: int32
       * @description Starting at 1, the number of attempts to complete this task by any worker.
       */
      attempt?: number;
      /**
       * Format: int64
       * @description A hint that there are more tasks already present in this task queue
       *     partition. Can be used to prioritize draining a sticky queue.
       *
       *     Specifically, the returned number is the number of tasks remaining in
       *     the in-memory buffer for this partition, which is currently capped at
       *     1000. Because sticky queues only have one partition, this number is
       *     more useful when draining them. Normal queues, typically having more than one
       *     partition, will return a number representing only some portion of the
       *     overall backlog. Subsequent RPCs may not hit the same partition as
       *     this call.
       */
      backlogCountHint?: string;
      history?: components['schemas']['v1History'];
      /**
       * Format: byte
       * @description Will be set if there are more history events than were included in this response. Such events
       *     should be fetched via `GetWorkflowExecutionHistory`.
       */
      nextPageToken?: string;
      query?: components['schemas']['v1WorkflowQuery'];
      workflowExecutionTaskQueue?: components['schemas']['v1TaskQueue'];
      /**
       * When this task was scheduled by the server
       * Format: date-time
       */
      scheduledTime?: string;
      /**
       * Format: date-time
       * @description When the current workflow task started event was generated, meaning the current attempt.
       */
      startedTime?: string;
      /** Queries that should be executed after applying the history in this task. Responses should be
       *     attached to `RespondWorkflowTaskCompletedRequest::query_results` */
      queries?: {
        [key: string]: components['schemas']['v1WorkflowQuery'];
      };
      /** Protocol messages piggybacking on a WFT as a transport */
      messages?: components['schemas']['v1Message'][];
      pollerScalingDecision?: components['schemas']['v1PollerScalingDecision'];
    };
    v1PollerInfo: {
      /** Format: date-time */
      lastAccessTime?: string;
      identity?: string;
      /** Format: double */
      ratePerSecond?: number;
      workerVersionCapabilities?: components['schemas']['v1WorkerVersionCapabilities'];
      deploymentOptions?: components['schemas']['v1WorkerDeploymentOptions'];
    };
    /** @description Attached to task responses to give hints to the SDK about how it may adjust its number of
     *     pollers. */
    v1PollerScalingDecision: {
      /**
       * Format: int32
       * @description How many poll requests to suggest should be added or removed, if any. As of now, server only
       *     scales up or down by 1. However, SDKs should allow for other values (while staying within
       *     defined min/max).
       *
       *     The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
       *     all slots are already occupied.
       */
      pollRequestDeltaSuggestion?: number;
    };
    /** @description PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset. */
    v1PostResetOperation: {
      signalWorkflow?: components['schemas']['PostResetOperationSignalWorkflow'];
      updateWorkflowOptions?: components['schemas']['PostResetOperationUpdateWorkflowOptions'];
    };
    /** @description Priority contains metadata that controls relative ordering of task processing
     *     when tasks are backed up in a queue. Initially, Priority will be used in
     *     matching (workflow and activity) task queues. Later it may be used in history
     *     task queues and in rate limiting decisions.
     *
     *     Priority is attached to workflows and activities. By default, activities
     *     inherit Priority from the workflow that created them, but may override fields
     *     when an activity is started or modified.
     *
     *     Despite being named "Priority", this message also contains fields that
     *     control "fairness" mechanisms.
     *
     *     For all fields, the field not present or equal to zero/empty string means to
     *     inherit the value from the calling workflow, or if there is no calling
     *     workflow, then use the default value.
     *
     *     For all fields other than fairness_key, the zero value isn't meaningful so
     *     there's no confusion between inherit/default and a meaningful value. For
     *     fairness_key, the empty string will be interpreted as "inherit". This means
     *     that if a workflow has a non-empty fairness key, you can't override the
     *     fairness key of its activity to the empty string.
     *
     *     The overall semantics of Priority are:
     *     1. First, consider "priority": higher priority (lower number) goes first.
     *     2. Then, consider fairness: try to dispatch tasks for different fairness keys
     *        in proportion to their weight.
     *
     *     Applications may use any subset of mechanisms that are useful to them and
     *     leave the other fields to use default values.
     *
     *     Not all queues in the system may support the "full" semantics of all priority
     *     fields. (Currently only support in matching task queues is planned.) */
    v1Priority: {
      /**
       * Format: int32
       * @description Priority key is a positive integer from 1 to n, where smaller integers
       *     correspond to higher priorities (tasks run sooner). In general, tasks in
       *     a queue should be processed in close to priority order, although small
       *     deviations are possible.
       *
       *     The maximum priority value (minimum priority) is determined by server
       *     configuration, and defaults to 5.
       *
       *     If priority is not present (or zero), then the effective priority will be
       *     the default priority, which is calculated by (min+max)/2. With the
       *     default max of 5, and min of 1, that comes out to 3.
       */
      priorityKey?: number;
      /** @description Fairness key is a short string that's used as a key for a fairness
       *     balancing mechanism. It may correspond to a tenant id, or to a fixed
       *     string like "high" or "low". The default is the empty string.
       *
       *     The fairness mechanism attempts to dispatch tasks for a given key in
       *     proportion to its weight. For example, using a thousand distinct tenant
       *     ids, each with a weight of 1.0 (the default) will result in each tenant
       *     getting a roughly equal share of task dispatch throughput.
       *
       *     (Note: this does not imply equal share of worker capacity! Fairness
       *     decisions are made based on queue statistics, not
       *     current worker load.)
       *
       *     As another example, using keys "high" and "low" with weight 9.0 and 1.0
       *     respectively will prefer dispatching "high" tasks over "low" tasks at a
       *     9:1 ratio, while allowing either key to use all worker capacity if the
       *     other is not present.
       *
       *     All fairness mechanisms, including rate limits, are best-effort and
       *     probabilistic. The results may not match what a "perfect" algorithm with
       *     infinite resources would produce. The more unique keys are used, the less
       *     accurate the results will be.
       *
       *     Fairness keys are limited to 64 bytes. */
      fairnessKey?: string;
      /**
       * Format: float
       * @description Fairness weight for a task can come from multiple sources for
       *     flexibility. From highest to lowest precedence:
       *     1. Weights for a small set of keys can be overridden in task queue
       *        configuration with an API.
       *     2. It can be attached to the workflow/activity in this field.
       *     3. The default weight of 1.0 will be used.
       *
       *     Weight values are clamped to the range [0.001, 1000].
       */
      fairnessWeight?: number;
    };
    v1ProtocolMessageCommandAttributes: {
      /** @description The message ID of the message to which this command is a pointer. */
      messageId?: string;
    };
    /**
     * @description  - QUERY_REJECT_CONDITION_NONE: None indicates that query should not be rejected.
     *      - QUERY_REJECT_CONDITION_NOT_OPEN: NotOpen indicates that query should be rejected if workflow is not open.
     *      - QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY: NotCompletedCleanly indicates that query should be rejected if workflow did not complete cleanly.
     * @default QUERY_REJECT_CONDITION_UNSPECIFIED
     * @enum {string}
     */
    v1QueryRejectCondition:
      | 'QUERY_REJECT_CONDITION_UNSPECIFIED'
      | 'QUERY_REJECT_CONDITION_NONE'
      | 'QUERY_REJECT_CONDITION_NOT_OPEN'
      | 'QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY';
    v1QueryRejected: {
      status?: components['schemas']['v1WorkflowExecutionStatus'];
    };
    /**
     * @default QUERY_RESULT_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1QueryResultType:
      | 'QUERY_RESULT_TYPE_UNSPECIFIED'
      | 'QUERY_RESULT_TYPE_ANSWERED'
      | 'QUERY_RESULT_TYPE_FAILED';
    v1QueryWorkflowResponse: {
      queryResult?: components['schemas']['v1Payloads'];
      queryRejected?: components['schemas']['v1QueryRejected'];
    };
    v1RampByPercentage: {
      /**
       * Format: float
       * @description Acceptable range is [0,100).
       */
      rampPercentage?: number;
    };
    /** @description Range represents a set of integer values, used to match fields of a calendar
     *     time in StructuredCalendarSpec. If end < start, then end is interpreted as
     *     equal to start. This means you can use a Range with start set to a value, and
     *     end and step unset (defaulting to 0) to represent a single value. */
    v1Range: {
      /**
       * Format: int32
       * @description Start of range (inclusive).
       */
      start?: number;
      /**
       * Format: int32
       * @description End of range (inclusive).
       */
      end?: number;
      /**
       * Format: int32
       * @description Step (optional, default 1).
       */
      step?: number;
    };
    v1RateLimit: {
      /**
       * Format: float
       * @description Zero is a valid rate limit.
       */
      requestsPerSecond?: number;
    };
    v1RateLimitConfig: {
      rateLimit?: components['schemas']['v1RateLimit'];
      metadata?: components['schemas']['v1ConfigMetadata'];
    };
    /**
     * @description Source for the effective rate limit.
     *
     *      - RATE_LIMIT_SOURCE_API: The value was set by the API.
     *      - RATE_LIMIT_SOURCE_WORKER: The value was set by a worker.
     *      - RATE_LIMIT_SOURCE_SYSTEM: The value was set as the system default.
     * @default RATE_LIMIT_SOURCE_UNSPECIFIED
     * @enum {string}
     */
    v1RateLimitSource:
      | 'RATE_LIMIT_SOURCE_UNSPECIFIED'
      | 'RATE_LIMIT_SOURCE_API'
      | 'RATE_LIMIT_SOURCE_WORKER'
      | 'RATE_LIMIT_SOURCE_SYSTEM';
    v1RecordActivityTaskHeartbeatByIdResponse: {
      /** @description Will be set to true if the activity has been asked to cancel itself. The SDK should then
       *     notify the activity of cancellation if it is still running. */
      cancelRequested?: boolean;
      /** @description Will be set to true if the activity is paused. */
      activityPaused?: boolean;
      /** @description Will be set to true if the activity was reset.
       *     Applies only to the current run. */
      activityReset?: boolean;
    };
    v1RecordActivityTaskHeartbeatResponse: {
      /** @description Will be set to true if the activity has been asked to cancel itself. The SDK should then
       *     notify the activity of cancellation if it is still running. */
      cancelRequested?: boolean;
      /** @description Will be set to true if the activity is paused. */
      activityPaused?: boolean;
      /** @description Will be set to true if the activity was reset.
       *     Applies only to the current run. */
      activityReset?: boolean;
    };
    v1RecordMarkerCommandAttributes: {
      markerName?: string;
      details?: {
        [key: string]: components['schemas']['v1Payloads'];
      };
      header?: components['schemas']['v1Header'];
      failure?: components['schemas']['apifailurev1Failure'];
    };
    v1RecordWorkerHeartbeatResponse: Record<string, never>;
    v1RegisterNamespaceRequest: {
      namespace?: string;
      description?: string;
      ownerEmail?: string;
      workflowExecutionRetentionPeriod?: string;
      clusters?: components['schemas']['v1ClusterReplicationConfig'][];
      activeClusterName?: string;
      /** @description A key-value map for any customized purpose. */
      data?: {
        [key: string]: string;
      };
      securityToken?: string;
      isGlobalNamespace?: boolean;
      historyArchivalState?: components['schemas']['v1ArchivalState'];
      historyArchivalUri?: string;
      visibilityArchivalState?: components['schemas']['v1ArchivalState'];
      visibilityArchivalUri?: string;
    };
    v1RegisterNamespaceResponse: Record<string, never>;
    /** @description ReleaseInfo contains information about specific version of temporal. */
    v1ReleaseInfo: {
      version?: string;
      /** Format: date-time */
      releaseTime?: string;
      notes?: string;
    };
    v1RemoveRemoteClusterResponse: Record<string, never>;
    v1RemoveSearchAttributesResponse: Record<string, never>;
    /**
     * @default REPLICATION_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1ReplicationState:
      | 'REPLICATION_STATE_UNSPECIFIED'
      | 'REPLICATION_STATE_NORMAL'
      | 'REPLICATION_STATE_HANDOVER';
    v1RequestCancelActivityTaskCommandAttributes: {
      /**
       * Format: int64
       * @description The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled.
       */
      scheduledEventId?: string;
    };
    v1RequestCancelExternalWorkflowExecutionCommandAttributes: {
      namespace?: string;
      workflowId?: string;
      runId?: string;
      /** @description Deprecated. */
      control?: string;
      /** @description Set this to true if the workflow being cancelled is a child of the workflow originating this
       *     command. The request will be rejected if it is set to true and the target workflow is *not*
       *     a child of the requesting workflow. */
      childWorkflowOnly?: boolean;
      /** Reason for requesting the cancellation */
      reason?: string;
    };
    v1RequestCancelExternalWorkflowExecutionFailedEventAttributes: {
      cause?: components['schemas']['v1CancelExternalWorkflowExecutionFailedCause'];
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** @description Namespace of the workflow which failed to cancel.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      /**
       * id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure
       *     corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /** @description Deprecated. */
      control?: string;
    };
    v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes: {
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** @description The namespace the workflow to be cancelled lives in.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** @description Deprecated. */
      control?: string;
      /** Workers are expected to set this to true if the workflow they are requesting to cancel is
       *     a child of the workflow which issued the request */
      childWorkflowOnly?: boolean;
      /** Reason for requesting the cancellation */
      reason?: string;
    };
    v1RequestCancelNexusOperationCommandAttributes: {
      /**
       * Format: int64
       * @description The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.
       *     The operation may ignore cancellation and end up with any completion state.
       */
      scheduledEventId?: string;
    };
    v1RequestCancelWorkflowExecutionResponse: Record<string, never>;
    /** @description RequestIdInfo contains details of a request ID. */
    v1RequestIdInfo: {
      eventType?: components['schemas']['v1EventType'];
      /**
       * Format: int64
       * @description The event id of the history event generated by the request. It's possible the event ID is not
       *     known (unflushed buffered event). In this case, the value will be zero or a negative value,
       *     representing an invalid ID.
       */
      eventId?: string;
      /** @description Indicate if the request is still buffered. If so, the event ID is not known and its value
       *     will be an invalid event ID. */
      buffered?: boolean;
    };
    v1ResetActivityResponse: Record<string, never>;
    /** @description Describes where and how to reset a workflow, used for batch reset currently
     *     and may be used for single-workflow reset later. */
    v1ResetOptions: {
      /** @description Resets to the first workflow task completed or started event. */
      firstWorkflowTask?: Record<string, never>;
      /** @description Resets to the last workflow task completed or started event. */
      lastWorkflowTask?: Record<string, never>;
      /**
       * Format: int64
       * @description The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
       *     `WORKFLOW_TASK_STARTED` event to reset to.
       *     Note that this option doesn't make sense when used as part of a batch request.
       */
      workflowTaskId?: string;
      /** @description Resets to the first workflow task processed by this build id.
       *     If the workflow was not processed by the build id, or the workflow task can't be
       *     determined, no reset will be performed.
       *     Note that by default, this reset is allowed to be to a prior run in a chain of
       *     continue-as-new. */
      buildId?: string;
      resetReapplyType?: components['schemas']['v1ResetReapplyType'];
      /** If true, limit the reset to only within the current run. (Applies to build_id targets and
       *     possibly others in the future.) */
      currentRunOnly?: boolean;
      /** Event types not to be reapplied */
      resetReapplyExcludeTypes?: components['schemas']['v1ResetReapplyExcludeType'][];
    };
    /** @description ResetPointInfo records the workflow event id that is the first one processed by a given
     *     build id or binary checksum. A new reset point will be created if either build id or binary
     *     checksum changes (although in general only one or the other will be used at a time). */
    v1ResetPointInfo: {
      /** @description Worker build id. */
      buildId?: string;
      /** @description Deprecated. A worker binary version identifier. */
      binaryChecksum?: string;
      /** @description The first run ID in the execution chain that was touched by this worker build. */
      runId?: string;
      /**
       * Format: int64
       * @description Event ID of the first WorkflowTaskCompleted event processed by this worker build.
       */
      firstWorkflowTaskCompletedId?: string;
      /** Format: date-time */
      createTime?: string;
      /**
       * Format: date-time
       * @description
       *     The time that the run is deleted due to retention.
       */
      expireTime?: string;
      /** @description false if the reset point has pending childWFs/reqCancels/signalExternals. */
      resettable?: boolean;
    };
    v1ResetPoints: {
      points?: components['schemas']['v1ResetPointInfo'][];
    };
    /**
     * @description Event types to exclude when reapplying events beyond the reset point.
     *
     *      - RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL: Exclude signals when reapplying events beyond the reset point.
     *      - RESET_REAPPLY_EXCLUDE_TYPE_UPDATE: Exclude updates when reapplying events beyond the reset point.
     *      - RESET_REAPPLY_EXCLUDE_TYPE_NEXUS: Exclude nexus events when reapplying events beyond the reset point.
     *      - RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST: Deprecated, unimplemented option.
     * @default RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1ResetReapplyExcludeType:
      | 'RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED'
      | 'RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL'
      | 'RESET_REAPPLY_EXCLUDE_TYPE_UPDATE'
      | 'RESET_REAPPLY_EXCLUDE_TYPE_NEXUS'
      | 'RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST';
    /**
     * @description Deprecated: applications should use ResetReapplyExcludeType to specify
     *     exclusions from this set, and new event types should be added to ResetReapplyExcludeType
     *     instead of here.
     *
     *      - RESET_REAPPLY_TYPE_SIGNAL: Signals are reapplied when workflow is reset.
     *      - RESET_REAPPLY_TYPE_NONE: No events are reapplied when workflow is reset.
     *      - RESET_REAPPLY_TYPE_ALL_ELIGIBLE: All eligible events are reapplied when workflow is reset.
     * @default RESET_REAPPLY_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1ResetReapplyType:
      | 'RESET_REAPPLY_TYPE_UNSPECIFIED'
      | 'RESET_REAPPLY_TYPE_SIGNAL'
      | 'RESET_REAPPLY_TYPE_NONE'
      | 'RESET_REAPPLY_TYPE_ALL_ELIGIBLE';
    v1ResetStickyTaskQueueResponse: Record<string, never>;
    /**
     * @description Deprecated, see temporal.api.common.v1.ResetOptions.
     *
     *      - RESET_TYPE_FIRST_WORKFLOW_TASK: Resets to event of the first workflow task completed, or if it does not exist, the event after task scheduled.
     *      - RESET_TYPE_LAST_WORKFLOW_TASK: Resets to event of the last workflow task completed, or if it does not exist, the event after task scheduled.
     * @default RESET_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1ResetType:
      | 'RESET_TYPE_UNSPECIFIED'
      | 'RESET_TYPE_FIRST_WORKFLOW_TASK'
      | 'RESET_TYPE_LAST_WORKFLOW_TASK';
    v1ResetWorkflowExecutionResponse: {
      runId?: string;
    };
    v1ResetWorkflowFailureInfo: {
      lastHeartbeatDetails?: components['schemas']['v1Payloads'];
    };
    v1RespondActivityTaskCanceledByIdResponse: Record<string, never>;
    v1RespondActivityTaskCanceledResponse: Record<string, never>;
    v1RespondActivityTaskCompletedByIdResponse: Record<string, never>;
    v1RespondActivityTaskCompletedResponse: Record<string, never>;
    v1RespondActivityTaskFailedByIdResponse: {
      /** Server validation failures could include
       *     last_heartbeat_details payload is too large, request failure is too large */
      failures?: components['schemas']['apifailurev1Failure'][];
    };
    v1RespondActivityTaskFailedResponse: {
      /** Server validation failures could include
       *     last_heartbeat_details payload is too large, request failure is too large */
      failures?: components['schemas']['apifailurev1Failure'][];
    };
    v1RespondNexusTaskCompletedResponse: Record<string, never>;
    v1RespondNexusTaskFailedResponse: Record<string, never>;
    v1RespondQueryTaskCompletedResponse: Record<string, never>;
    /** @description SDK capability details. */
    v1RespondWorkflowTaskCompletedRequestCapabilities: {
      /** @description True if the SDK can handle speculative workflow task with command events. If true, the
       *     server may choose, at its discretion, to discard a speculative workflow task even if that
       *     speculative task included command events the SDK had not previously processed.
       *      */
      discardSpeculativeWorkflowTaskWithEvents?: boolean;
    };
    v1RespondWorkflowTaskCompletedResponse: {
      workflowTask?: components['schemas']['v1PollWorkflowTaskQueueResponse'];
      /** See `ScheduleActivityTaskCommandAttributes::request_eager_execution` */
      activityTasks?: components['schemas']['v1PollActivityTaskQueueResponse'][];
      /**
       * Format: int64
       * @description If non zero, indicates the server has discarded the workflow task that was being responded to.
       *     Will be the event ID of the last workflow task started event in the history before the new workflow task.
       *     Server is only expected to discard a workflow task if it could not have modified the workflow state.
       */
      resetHistoryEventId?: string;
    };
    v1RespondWorkflowTaskFailedResponse: Record<string, never>;
    /** How retries ought to be handled, usable by both workflows and activities */
    v1RetryPolicy: {
      /** @description Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries. */
      initialInterval?: string;
      /**
       * Format: double
       * @description Coefficient used to calculate the next retry interval.
       *     The next retry interval is previous interval multiplied by the coefficient.
       *     Must be 1 or larger.
       */
      backoffCoefficient?: number;
      /** @description Maximum interval between retries. Exponential backoff leads to interval increase.
       *     This value is the cap of the increase. Default is 100x of the initial interval. */
      maximumInterval?: string;
      /**
       * Maximum number of attempts. When exceeded the retries stop even if not expired yet.
       *     1 disables retries. 0 means unlimited (up to the timeouts)
       * Format: int32
       */
      maximumAttempts?: number;
      /** @description Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
       *     this is not a substring match, the error *type* (not message) must match exactly. */
      nonRetryableErrorTypes?: string[];
    };
    /**
     * @default RETRY_STATE_UNSPECIFIED
     * @enum {string}
     */
    v1RetryState:
      | 'RETRY_STATE_UNSPECIFIED'
      | 'RETRY_STATE_IN_PROGRESS'
      | 'RETRY_STATE_NON_RETRYABLE_FAILURE'
      | 'RETRY_STATE_TIMEOUT'
      | 'RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED'
      | 'RETRY_STATE_RETRY_POLICY_NOT_SET'
      | 'RETRY_STATE_INTERNAL_SERVER_ERROR'
      | 'RETRY_STATE_CANCEL_REQUESTED';
    v1RoutingConfig: {
      currentDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /** @description Deprecated. Use `current_deployment_version`. */
      currentVersion?: string;
      rampingDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /** @description Deprecated. Use `ramping_deployment_version`. */
      rampingVersion?: string;
      /**
       * Format: float
       * @description Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
       *     Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
       *     not yet "promoted" to be the Current Version, likely due to pending validations.
       *     A 0% value means the Ramping Version is receiving no traffic.
       */
      rampingVersionPercentage?: number;
      /**
       * Format: date-time
       * @description Last time current version was changed.
       */
      currentVersionChangedTime?: string;
      /**
       * Format: date-time
       * @description Last time ramping version was changed. Not updated if only the ramp percentage changes.
       */
      rampingVersionChangedTime?: string;
      /**
       * Format: date-time
       * @description Last time ramping version percentage was changed.
       *     If ramping version is changed, this is also updated, even if the percentage stays the same.
       */
      rampingVersionPercentageChangedTime?: string;
    };
    /** @description Deprecated: Use with `ListWorkflowExecutions`. */
    v1ScanWorkflowExecutionsResponse: {
      executions?: components['schemas']['v1WorkflowExecutionInfo'][];
      /** Format: byte */
      nextPageToken?: string;
    };
    v1Schedule: {
      spec?: components['schemas']['v1ScheduleSpec'];
      action?: components['schemas']['v1ScheduleAction'];
      policies?: components['schemas']['v1SchedulePolicies'];
      state?: components['schemas']['v1ScheduleState'];
    };
    v1ScheduleAction: {
      startWorkflow?: components['schemas']['v1NewWorkflowExecutionInfo'];
    };
    v1ScheduleActionResult: {
      /**
       * Format: date-time
       * @description Time that the action was taken (according to the schedule, including jitter).
       */
      scheduleTime?: string;
      /**
       * Format: date-time
       * @description Time that the action was taken (real time).
       */
      actualTime?: string;
      startWorkflowResult?: components['schemas']['v1WorkflowExecution'];
      startWorkflowStatus?: components['schemas']['v1WorkflowExecutionStatus'];
    };
    v1ScheduleActivityTaskCommandAttributes: {
      activityId?: string;
      activityType?: components['schemas']['v1ActivityType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      header?: components['schemas']['v1Header'];
      input?: components['schemas']['v1Payloads'];
      /** @description Indicates how long the caller is willing to wait for activity completion. The "schedule" time
       *     is when the activity is initially scheduled, not when the most recent retry is scheduled.
       *     Limits how long retries will be attempted. Either this or `start_to_close_timeout` must be
       *     specified. When not specified, defaults to the workflow execution timeout.
       *      */
      scheduleToCloseTimeout?: string;
      /** Limits the time an activity task can stay in a task queue before a worker picks it up. The
       *     "schedule" time is when the most recent retry is scheduled. This timeout should usually not
       *     be set: it's useful in specific scenarios like worker-specific task queues. This timeout is
       *     always non retryable, as all a retry would achieve is to put it back into the same queue.
       *     Defaults to `schedule_to_close_timeout` or workflow execution timeout if that is not
       *     specified. More info:
       *     https://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/ */
      scheduleToStartTimeout?: string;
      /** @description Maximum time an activity is allowed to execute after being picked up by a worker. This
       *     timeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.
       *      */
      startToCloseTimeout?: string;
      /** @description Maximum permitted time between successful worker heartbeats. */
      heartbeatTimeout?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** @description Request to start the activity directly bypassing matching service and worker polling
       *     The slot for executing the activity should be reserved when setting this field to true. */
      requestEagerExecution?: boolean;
      /** @description If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
       *     Assignment rules of the activity's Task Queue will be used to determine the Build ID. */
      useWorkflowBuildId?: boolean;
      priority?: components['schemas']['v1Priority'];
    };
    v1ScheduleInfo: {
      /**
       * Format: int64
       * @description Number of actions taken so far.
       */
      actionCount?: string;
      /**
       * Format: int64
       * @description Number of times a scheduled action was skipped due to missing the catchup window.
       */
      missedCatchupWindow?: string;
      /**
       * Format: int64
       * @description Number of skipped actions due to overlap.
       */
      overlapSkipped?: string;
      /**
       * Format: int64
       * @description Number of dropped actions due to buffer limit.
       */
      bufferDropped?: string;
      /**
       * Format: int64
       * @description Number of actions in the buffer. The buffer holds the actions that cannot
       *     be immediately triggered (due to the overlap policy). These actions can be a result of
       *     the normal schedule or a backfill.
       */
      bufferSize?: string;
      /** @description Currently-running workflows started by this schedule. (There might be
       *     more than one if the overlap policy allows overlaps.)
       *     Note that the run_ids in here are the original execution run ids as
       *     started by the schedule. If the workflows retried, did continue-as-new,
       *     or were reset, they might still be running but with a different run_id. */
      runningWorkflows?: components['schemas']['v1WorkflowExecution'][];
      /** @description Most recent ten actual action times (including manual triggers). */
      recentActions?: components['schemas']['v1ScheduleActionResult'][];
      /** @description Next ten scheduled action times. */
      futureActionTimes?: string[];
      /**
       * Format: date-time
       * @description Timestamps of schedule creation and last update.
       */
      createTime?: string;
      /** Format: date-time */
      updateTime?: string;
      /** @description Deprecated. */
      invalidScheduleError?: string;
    };
    /** @description ScheduleListEntry is returned by ListSchedules. */
    v1ScheduleListEntry: {
      scheduleId?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      info?: components['schemas']['v1ScheduleListInfo'];
    };
    /** @description ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
     *     that's returned in ListSchedules. */
    v1ScheduleListInfo: {
      spec?: components['schemas']['v1ScheduleSpec'];
      workflowType?: components['schemas']['v1WorkflowType'];
      /** From state: */
      notes?: string;
      paused?: boolean;
      /** From info (maybe fewer entries): */
      recentActions?: components['schemas']['v1ScheduleActionResult'][];
      futureActionTimes?: string[];
    };
    v1ScheduleNexusOperationCommandAttributes: {
      /** @description Endpoint name, must exist in the endpoint registry or this command will fail. */
      endpoint?: string;
      /** @description Service name. */
      service?: string;
      /** @description Operation name. */
      operation?: string;
      input?: components['schemas']['v1Payload'];
      /** @description Schedule-to-close timeout for this operation.
       *     Indicates how long the caller is willing to wait for operation completion.
       *     Calls are retried internally by the server. */
      scheduleToCloseTimeout?: string;
      /** @description Header to attach to the Nexus request.
       *     Users are responsible for encrypting sensitive data in this header as it is stored in workflow history and
       *     transmitted to external services as-is.
       *     This is useful for propagating tracing information.
       *     Note these headers are not the same as Temporal headers on internal activities and child workflows, these are
       *     transmitted to Nexus operations that may be external and are not traditional payloads. */
      nexusHeader?: {
        [key: string]: string;
      };
    };
    /**
     * @description ScheduleOverlapPolicy controls what happens when a workflow would be started
     *     by a schedule, and is already running.
     *
     *      - SCHEDULE_OVERLAP_POLICY_SKIP: SCHEDULE_OVERLAP_POLICY_SKIP (default) means don't start anything. When the
     *     workflow completes, the next scheduled event after that time will be considered.
     *      - SCHEDULE_OVERLAP_POLICY_BUFFER_ONE: SCHEDULE_OVERLAP_POLICY_BUFFER_ONE means start the workflow again soon as the
     *     current one completes, but only buffer one start in this way. If another start is
     *     supposed to happen when the workflow is running, and one is already buffered, then
     *     only the first one will be started after the running workflow finishes.
     *      - SCHEDULE_OVERLAP_POLICY_BUFFER_ALL: SCHEDULE_OVERLAP_POLICY_BUFFER_ALL means buffer up any number of starts to all
     *     happen sequentially, immediately after the running workflow completes.
     *      - SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER: SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER means that if there is another workflow
     *     running, cancel it, and start the new one after the old one completes cancellation.
     *      - SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER: SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER means that if there is another workflow
     *     running, terminate it and start the new one immediately.
     *      - SCHEDULE_OVERLAP_POLICY_ALLOW_ALL: SCHEDULE_OVERLAP_POLICY_ALLOW_ALL means start any number of concurrent workflows.
     *     Note that with this policy, last completion result and last failure will not be
     *     available since workflows are not sequential.
     * @default SCHEDULE_OVERLAP_POLICY_UNSPECIFIED
     * @enum {string}
     */
    v1ScheduleOverlapPolicy:
      | 'SCHEDULE_OVERLAP_POLICY_UNSPECIFIED'
      | 'SCHEDULE_OVERLAP_POLICY_SKIP'
      | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ONE'
      | 'SCHEDULE_OVERLAP_POLICY_BUFFER_ALL'
      | 'SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER'
      | 'SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER'
      | 'SCHEDULE_OVERLAP_POLICY_ALLOW_ALL';
    v1SchedulePatch: {
      triggerImmediately?: components['schemas']['v1TriggerImmediatelyRequest'];
      /** @description If set, runs though the specified time period(s) and takes actions as if that time
       *     passed by right now, all at once. The overlap policy can be overridden for the
       *     scope of the backfill. */
      backfillRequest?: components['schemas']['v1BackfillRequest'][];
      /** @description If set, change the state to paused or unpaused (respectively) and set the
       *     notes field to the value of the string. */
      pause?: string;
      unpause?: string;
    };
    v1SchedulePolicies: {
      overlapPolicy?: components['schemas']['v1ScheduleOverlapPolicy'];
      /** @description Policy for catchups:
       *     If the Temporal server misses an action due to one or more components
       *     being down, and comes back up, the action will be run if the scheduled
       *     time is within this window from the current time.
       *     This value defaults to one year, and can't be less than 10 seconds. */
      catchupWindow?: string;
      /** @description If true, and a workflow run fails or times out, turn on "paused".
       *     This applies after retry policies: the full chain of retries must fail to
       *     trigger a pause here. */
      pauseOnFailure?: boolean;
      /** @description If true, and the action would start a workflow, a timestamp will not be
       *     appended to the scheduled workflow id. */
      keepOriginalWorkflowId?: boolean;
    };
    /** @description ScheduleSpec is a complete description of a set of absolute timestamps
     *     (possibly infinite) that an action should occur at. The meaning of a
     *     ScheduleSpec depends only on its contents and never changes, except that the
     *     definition of a time zone can change over time (most commonly, when daylight
     *     saving time policy changes for an area). To create a totally self-contained
     *     ScheduleSpec, use UTC or include timezone_data.
     *
     *     For input, you can provide zero or more of: structured_calendar, calendar,
     *     cron_string, interval, and exclude_structured_calendar, and all of them will
     *     be used (the schedule will take action at the union of all of their times,
     *     minus the ones that match exclude_structured_calendar).
     *
     *     On input, calendar and cron_string fields will be compiled into
     *     structured_calendar (and maybe interval and timezone_name), so if you
     *     Describe a schedule, you'll see only structured_calendar, interval, etc.
     *
     *     If a spec has no matching times after the current time, then the schedule
     *     will be subject to automatic deletion (after several days). */
    v1ScheduleSpec: {
      /** @description Calendar-based specifications of times. */
      structuredCalendar?: components['schemas']['v1StructuredCalendarSpec'][];
      /** @description cron_string holds a traditional cron specification as a string. It
       *     accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
       *     same way as CalendarSpec.
       *     5 fields:         minute, hour, day_of_month, month, day_of_week
       *     6 fields:         minute, hour, day_of_month, month, day_of_week, year
       *     7 fields: second, minute, hour, day_of_month, month, day_of_week, year
       *     If year is not given, it defaults to *. If second is not given, it
       *     defaults to 0.
       *     Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
       *     accepted instead of the 5-7 time fields.
       *     Optionally, the string can be preceded by CRON_TZ=<timezone name> or
       *     TZ=<timezone name>, which will get copied to timezone_name. (There must
       *     not also be a timezone_name present.)
       *     Optionally "#" followed by a comment can appear at the end of the string.
       *     Note that the special case that some cron implementations have for
       *     treating day_of_month and day_of_week as "or" instead of "and" when both
       *     are set is not implemented.
       *     @every <interval>[/<phase>] is accepted and gets compiled into an
       *     IntervalSpec instead. <interval> and <phase> should be a decimal integer
       *     with a unit suffix s, m, h, or d. */
      cronString?: string[];
      /** @description Calendar-based specifications of times. */
      calendar?: components['schemas']['v1CalendarSpec'][];
      /** @description Interval-based specifications of times. */
      interval?: components['schemas']['v1IntervalSpec'][];
      /** @description Any timestamps matching any of exclude_* will be skipped.
       *     Deprecated. Use exclude_structured_calendar. */
      excludeCalendar?: components['schemas']['v1CalendarSpec'][];
      excludeStructuredCalendar?: components['schemas']['v1StructuredCalendarSpec'][];
      /**
       * If start_time is set, any timestamps before start_time will be skipped.
       *     (Together, start_time and end_time make an inclusive interval.)
       * Format: date-time
       */
      startTime?: string;
      /**
       * Format: date-time
       * @description If end_time is set, any timestamps after end_time will be skipped.
       */
      endTime?: string;
      /** All timestamps will be incremented by a random value from 0 to this
       *     amount of jitter. Default: 0 */
      jitter?: string;
      /** @description Time zone to interpret all calendar-based specs in.
       *
       *     If unset, defaults to UTC. We recommend using UTC for your application if
       *     at all possible, to avoid various surprising properties of time zones.
       *
       *     Time zones may be provided by name, corresponding to names in the IANA
       *     time zone database (see https://www.iana.org/time-zones). The definition
       *     will be loaded by the Temporal server from the environment it runs in.
       *
       *     If your application requires more control over the time zone definition
       *     used, it may pass in a complete definition in the form of a TZif file
       *     from the time zone database. If present, this will be used instead of
       *     loading anything from the environment. You are then responsible for
       *     updating timezone_data when the definition changes.
       *
       *     Calendar spec matching is based on literal matching of the clock time
       *     with no special handling of DST: if you write a calendar spec that fires
       *     at 2:30am and specify a time zone that follows DST, that action will not
       *     be triggered on the day that has no 2:30am. Similarly, an action that
       *     fires at 1:30am will be triggered twice on the day that has two 1:30s.
       *
       *     Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC). */
      timezoneName?: string;
      /** Format: byte */
      timezoneData?: string;
    };
    v1ScheduleState: {
      /** @description Informative human-readable message with contextual notes, e.g. the reason
       *     a schedule is paused. The system may overwrite this message on certain
       *     conditions, e.g. when pause-on-failure happens. */
      notes?: string;
      /** @description If true, do not take any actions based on the schedule spec. */
      paused?: boolean;
      /** @description If limited_actions is true, decrement remaining_actions after each
       *     action, and do not take any more scheduled actions if remaining_actions
       *     is zero. Actions may still be taken by explicit request (i.e. trigger
       *     immediately or backfill). Skipped actions (due to overlap policy) do not
       *     count against remaining actions.
       *     If a schedule has no more remaining actions, then the schedule will be
       *     subject to automatic deletion (after several days). */
      limitedActions?: boolean;
      /** Format: int64 */
      remainingActions?: string;
    };
    /** @description A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
     *     The payload is not serialized in a user-defined way. */
    v1SearchAttributes: {
      indexedFields?: {
        [key: string]: components['schemas']['v1Payload'];
      };
    };
    v1ServerFailureInfo: {
      nonRetryable?: boolean;
    };
    /** [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later */
    v1SetCurrentDeploymentResponse: {
      currentDeploymentInfo?: components['schemas']['v1DeploymentInfo'];
      previousDeploymentInfo?: components['schemas']['v1DeploymentInfo'];
    };
    v1SetWorkerDeploymentCurrentVersionResponse: {
      /**
       * Format: byte
       * @description This value is returned so that it can be optionally passed to APIs
       *     that write to the Worker Deployment state to ensure that the state
       *     did not change between this API call and a future write.
       */
      conflictToken?: string;
      /** @description Deprecated. Use `previous_deployment_version`. */
      previousVersion?: string;
      previousDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
    };
    v1SetWorkerDeploymentRampingVersionResponse: {
      /**
       * Format: byte
       * @description This value is returned so that it can be optionally passed to APIs
       *     that write to the Worker Deployment state to ensure that the state
       *     did not change between this API call and a future write.
       */
      conflictToken?: string;
      /** @description Deprecated. Use `previous_deployment_version`. */
      previousVersion?: string;
      previousDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /**
       * Format: float
       * @description The ramping version percentage before executing this operation.
       */
      previousPercentage?: number;
    };
    /**
     * @default SEVERITY_UNSPECIFIED
     * @enum {string}
     */
    v1Severity:
      | 'SEVERITY_UNSPECIFIED'
      | 'SEVERITY_HIGH'
      | 'SEVERITY_MEDIUM'
      | 'SEVERITY_LOW';
    v1ShutdownWorkerResponse: Record<string, never>;
    v1SignalExternalWorkflowExecutionCommandAttributes: {
      namespace?: string;
      execution?: components['schemas']['v1WorkflowExecution'];
      /** @description The workflow author-defined name of the signal to send to the workflow. */
      signalName?: string;
      input?: components['schemas']['v1Payloads'];
      /** Deprecated */
      control?: string;
      /** @description Set this to true if the workflow being cancelled is a child of the workflow originating this
       *     command. The request will be rejected if it is set to true and the target workflow is *not*
       *     a child of the requesting workflow. */
      childWorkflowOnly?: boolean;
      header?: components['schemas']['v1Header'];
    };
    /**
     * - SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED: Signal count limit is per workflow and controlled by server dynamic config "history.maximumSignalsPerExecution"
     * @default SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED
     * @enum {string}
     */
    v1SignalExternalWorkflowExecutionFailedCause:
      | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
      | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND'
      | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND'
      | 'SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED';
    v1SignalExternalWorkflowExecutionFailedEventAttributes: {
      cause?: components['schemas']['v1SignalExternalWorkflowExecutionFailedCause'];
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** @description Namespace of the workflow which failed the signal.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** Format: int64 */
      initiatedEventId?: string;
      /** @description Deprecated. */
      control?: string;
    };
    v1SignalExternalWorkflowExecutionInitiatedEventAttributes: {
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** @description Namespace of the to-be-signalled workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** name/type of the signal to fire in the external workflow */
      signalName?: string;
      input?: components['schemas']['v1Payloads'];
      /** @description Deprecated. */
      control?: string;
      /** Workers are expected to set this to true if the workflow they are requesting to cancel is
       *     a child of the workflow which issued the request */
      childWorkflowOnly?: boolean;
      header?: components['schemas']['v1Header'];
    };
    v1SignalWithStartWorkflowExecutionResponse: {
      /** @description The run id of the workflow that was started - or just signaled, if it was already running. */
      runId?: string;
      /** @description If true, a new workflow was started. */
      started?: boolean;
    };
    v1SignalWorkflowExecutionResponse: Record<string, never>;
    v1StartBatchOperationResponse: Record<string, never>;
    v1StartChildWorkflowExecutionCommandAttributes: {
      namespace?: string;
      workflowId?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      parentClosePolicy?: components['schemas']['v1ParentClosePolicy'];
      control?: string;
      workflowIdReusePolicy?: components['schemas']['v1WorkflowIdReusePolicy'];
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** @description Establish a cron schedule for the child workflow. */
      cronSchedule?: string;
      header?: components['schemas']['v1Header'];
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      /** @description If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
       *     rules of the child's Task Queue will be used to independently assign a Build ID to it.
       *     Deprecated. Only considered for versioning v0.2. */
      inheritBuildId?: boolean;
      priority?: components['schemas']['v1Priority'];
    };
    /**
     * @default START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED
     * @enum {string}
     */
    v1StartChildWorkflowExecutionFailedCause:
      | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED'
      | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS'
      | 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND';
    v1StartChildWorkflowExecutionFailedEventAttributes: {
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowId?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      cause?: components['schemas']['v1StartChildWorkflowExecutionFailedCause'];
      /** @description Deprecated. */
      control?: string;
      /**
       * Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
       * Format: int64
       */
      initiatedEventId?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
    };
    v1StartChildWorkflowExecutionInitiatedEventAttributes: {
      /** @description Namespace of the child workflow.
       *     SDKs and UI tools should use `namespace` field but server must use `namespace_id` only. */
      namespace?: string;
      namespaceId?: string;
      workflowId?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      parentClosePolicy?: components['schemas']['v1ParentClosePolicy'];
      /** @description Deprecated. */
      control?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      workflowIdReusePolicy?: components['schemas']['v1WorkflowIdReusePolicy'];
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** If this child runs on a cron schedule, it will appear here */
      cronSchedule?: string;
      header?: components['schemas']['v1Header'];
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      /** @description If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
       *     rules of the child's Task Queue will be used to independently assign a Build ID to it.
       *     Deprecated. Only considered for versioning v0.2. */
      inheritBuildId?: boolean;
      priority?: components['schemas']['v1Priority'];
    };
    /** @description A request to start an operation. */
    v1StartOperationRequest: {
      /** @description Name of service to start the operation in. */
      service?: string;
      /** @description Type of operation to start. */
      operation?: string;
      /** @description A request ID that can be used as an idempotentency key. */
      requestId?: string;
      /** @description Callback URL to call upon completion if the started operation is async. */
      callback?: string;
      payload?: components['schemas']['v1Payload'];
      /** @description Header that is expected to be attached to the callback request when the operation completes. */
      callbackHeader?: {
        [key: string]: string;
      };
      /** @description Links contain caller information and can be attached to the operations started by the handler. */
      links?: components['schemas']['apinexusv1Link'][];
    };
    /** @description Response variant for StartOperationRequest. */
    v1StartOperationResponse: {
      syncSuccess?: components['schemas']['StartOperationResponseSync'];
      asyncSuccess?: components['schemas']['StartOperationResponseAsync'];
      operationError?: components['schemas']['v1UnsuccessfulOperationError'];
    };
    v1StartTimeFilter: {
      /** Format: date-time */
      earliestTime?: string;
      /** Format: date-time */
      latestTime?: string;
    };
    v1StartTimerCommandAttributes: {
      /** @description An id for the timer, currently live timers must have different ids. Typically autogenerated
       *     by the SDK. */
      timerId?: string;
      /** @description How long until the timer fires, producing a `TIMER_FIRED` event.
       *      */
      startToFireTimeout?: string;
    };
    v1StartWorkflowExecutionRequest: {
      namespace?: string;
      workflowId?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /** The identity of the client who initiated this request */
      identity?: string;
      /** @description A unique identifier for this start request. Typically UUIDv4. */
      requestId?: string;
      workflowIdReusePolicy?: components['schemas']['v1WorkflowIdReusePolicy'];
      workflowIdConflictPolicy?: components['schemas']['v1WorkflowIdConflictPolicy'];
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /** See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/ */
      cronSchedule?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      header?: components['schemas']['v1Header'];
      /** @description Request to get the first workflow task inline in the response bypassing matching service and worker polling.
       *     If set to `true` the caller is expected to have a worker available and capable of processing the task.
       *     The returned task will be marked as started and is expected to be completed by the specified
       *     `workflow_task_timeout`. */
      requestEagerExecution?: boolean;
      continuedFailure?: components['schemas']['apifailurev1Failure'];
      lastCompletionResult?: components['schemas']['v1Payloads'];
      /** @description Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
       *     If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
       *     of the delay will be ignored. */
      workflowStartDelay?: string;
      /** @description Callbacks to be called by the server when this workflow reaches a terminal state.
       *     If the workflow continues-as-new, these callbacks will be carried over to the new execution.
       *     Callback addresses must be whitelisted in the server's dynamic configuration. */
      completionCallbacks?: components['schemas']['v1Callback'][];
      userMetadata?: components['schemas']['v1UserMetadata'];
      /** @description Links to be associated with the workflow. */
      links?: components['schemas']['apicommonv1Link'][];
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      onConflictOptions?: components['schemas']['v1OnConflictOptions'];
      priority?: components['schemas']['v1Priority'];
    };
    v1StartWorkflowExecutionResponse: {
      /** @description The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING). */
      runId?: string;
      /** @description If true, a new workflow was started. */
      started?: boolean;
      status?: components['schemas']['v1WorkflowExecutionStatus'];
      eagerWorkflowTask?: components['schemas']['v1PollWorkflowTaskQueueResponse'];
      link?: components['schemas']['apicommonv1Link'];
    };
    v1StatusFilter: {
      status?: components['schemas']['v1WorkflowExecutionStatus'];
    };
    v1StickyExecutionAttributes: {
      workerTaskQueue?: components['schemas']['v1TaskQueue'];
      scheduleToStartTimeout?: string;
    };
    v1StopBatchOperationResponse: Record<string, never>;
    /** StructuredCalendarSpec describes an event specification relative to the
     *     calendar, in a form that's easy to work with programmatically. Each field can
     *     be one or more ranges.
     *     A timestamp matches if at least one range of each field matches the
     *     corresponding fields of the timestamp, except for year: if year is missing,
     *     that means all years match. For all fields besides year, at least one Range
     *     must be present to match anything.
     *     TODO: add relative-to-end-of-month
     *     TODO: add nth day-of-week in month */
    v1StructuredCalendarSpec: {
      /** Match seconds (0-59) */
      second?: components['schemas']['v1Range'][];
      /** Match minutes (0-59) */
      minute?: components['schemas']['v1Range'][];
      /** Match hours (0-23) */
      hour?: components['schemas']['v1Range'][];
      /** Match days of the month (1-31) */
      dayOfMonth?: components['schemas']['v1Range'][];
      /** Match months (1-12) */
      month?: components['schemas']['v1Range'][];
      /** @description Match years. */
      year?: components['schemas']['v1Range'][];
      /** @description Match days of the week (0-6; 0 is Sunday). */
      dayOfWeek?: components['schemas']['v1Range'][];
      /** @description Free-form comment describing the intention of this spec. */
      comment?: string;
    };
    v1TaskIdBlock: {
      /** Format: int64 */
      startId?: string;
      /** Format: int64 */
      endId?: string;
    };
    /** See https://docs.temporal.io/docs/concepts/task-queues/ */
    v1TaskQueue: {
      name?: string;
      kind?: components['schemas']['v1TaskQueueKind'];
      /** @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
       *     the normal task queue that the sticky worker is running on. */
      normalName?: string;
    };
    v1TaskQueueConfig: {
      queueRateLimit?: components['schemas']['v1RateLimitConfig'];
      fairnessKeysRateLimitDefault?: components['schemas']['v1RateLimitConfig'];
    };
    /**
     * - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history
     * @description The task queue specified by the user is always a normal task queue. There can be as many
     *     workers as desired for a single normal task queue. All those workers may pick up tasks from
     *     that queue.
     *      - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are
     *     per-worker.
     *
     *     Sticky queues are created dynamically by each worker during their start up. They only exist
     *     for the lifetime of the worker process. Tasks in a sticky task queue are only available to
     *     the worker that created the sticky queue.
     *
     *     Sticky queues are only for workflow tasks. There are no sticky task queues for activities.
     * @default TASK_QUEUE_KIND_UNSPECIFIED
     * @enum {string}
     */
    v1TaskQueueKind:
      | 'TASK_QUEUE_KIND_UNSPECIFIED'
      | 'TASK_QUEUE_KIND_NORMAL'
      | 'TASK_QUEUE_KIND_STICKY';
    /** Only applies to activity task queues */
    v1TaskQueueMetadata: {
      /**
       * Allows throttling dispatch of tasks from this queue
       * Format: double
       */
      maxTasksPerSecond?: number;
    };
    v1TaskQueuePartitionMetadata: {
      key?: string;
      ownerHostName?: string;
    };
    /** @description Reachability of tasks for a worker on a single task queue. */
    v1TaskQueueReachability: {
      taskQueue?: string;
      /** @description Task reachability for a worker in a single task queue.
       *     See the TaskReachability docstring for information about each enum variant.
       *     If reachability is empty, this worker is considered unreachable in this task queue. */
      reachability?: components['schemas']['v1TaskReachability'][];
    };
    /** @description TaskQueueStats contains statistics about task queue backlog and activity.
     *
     *     For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
     *     comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy. */
    v1TaskQueueStats: {
      /**
       * Format: int64
       * @description The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
       *     converges to the right value. Can be relied upon for scaling decisions.
       *
       *     Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
       *     those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
       *     grows.
       */
      approximateBacklogCount?: string;
      /** @description Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
       *     the queue. Can be relied upon for scaling decisions.
       *
       *     Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
       *     those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
       *     few seconds. */
      approximateBacklogAge?: string;
      /**
       * Format: float
       * @description The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
       *     whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
       *     to the backlog (sync-matched).
       *
       *     The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
       *     backlog grows/shrinks.
       *
       *     Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
       *     tasks_add_rate, because:
       *     - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
       *       enable for activities by default in the latest SDKs.
       *     - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
       *       workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
       *       worker instance.
       */
      tasksAddRate?: number;
      /**
       * Format: float
       * @description The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
       *     tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
       *     going to the backlog (sync-matched).
       *
       *     The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
       *     backlog grows/shrinks.
       *
       *     Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
       *     tasks_dispatch_rate, because:
       *     - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
       *       enable for activities by default in the latest SDKs.
       *     - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
       *       workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
       *       worker instance.
       */
      tasksDispatchRate?: number;
    };
    /** @description Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior. */
    v1TaskQueueStatus: {
      /** Format: int64 */
      backlogCountHint?: string;
      /** Format: int64 */
      readLevel?: string;
      /** Format: int64 */
      ackLevel?: string;
      /** Format: double */
      ratePerSecond?: number;
      taskIdBlock?: components['schemas']['v1TaskIdBlock'];
    };
    /**
     * @description  - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.
     *      - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.
     *      - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.
     * @default TASK_QUEUE_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1TaskQueueType:
      | 'TASK_QUEUE_TYPE_UNSPECIFIED'
      | 'TASK_QUEUE_TYPE_WORKFLOW'
      | 'TASK_QUEUE_TYPE_ACTIVITY'
      | 'TASK_QUEUE_TYPE_NEXUS';
    v1TaskQueueTypeInfo: {
      /** @description Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID. */
      pollers?: components['schemas']['v1PollerInfo'][];
      stats?: components['schemas']['v1TaskQueueStats'];
    };
    v1TaskQueueVersionInfo: {
      /** @description Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum. */
      typesInfo?: {
        [key: string]: components['schemas']['v1TaskQueueTypeInfo'];
      };
      taskReachability?: components['schemas']['v1BuildIdTaskReachability'];
    };
    /** @description Used for specifying versions the caller is interested in. */
    v1TaskQueueVersionSelection: {
      /** @description Include specific Build IDs. */
      buildIds?: string[];
      /** @description Include the unversioned queue. */
      unversioned?: boolean;
      /** @description Include all active versions. A version is considered active if, in the last few minutes,
       *     it has had new tasks or polls, or it has been the subject of certain task queue API calls. */
      allActive?: boolean;
    };
    /** @description Experimental. Worker Deployments are experimental and might significantly change in the future. */
    v1TaskQueueVersioningInfo: {
      currentDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /** @description Deprecated. Use `current_deployment_version`. */
      currentVersion?: string;
      rampingDeploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /** @description Deprecated. Use `ramping_deployment_version`. */
      rampingVersion?: string;
      /**
       * Format: float
       * @description Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
       *     Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
       *     not yet "promoted" to be the Current Version, likely due to pending validations.
       *     A 0% value means the Ramping Version is receiving no traffic.
       */
      rampingVersionPercentage?: number;
      /**
       * Format: date-time
       * @description Last time versioning information of this Task Queue changed.
       */
      updateTime?: string;
    };
    /**
     * @description Specifies which category of tasks may reach a worker on a versioned task queue.
     *     Used both in a reachability query and its response.
     *     Deprecated.
     *
     *      - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
     *      - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
     *     should *not* be retired.
     *     This enum value does not distinguish between open and closed workflows.
     *      - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
     *     should *not* be retired.
     *      - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
     *     retired dependending on application requirements. For example, if there's no need to query closed workflows.
     * @default TASK_REACHABILITY_UNSPECIFIED
     * @enum {string}
     */
    v1TaskReachability:
      | 'TASK_REACHABILITY_UNSPECIFIED'
      | 'TASK_REACHABILITY_NEW_WORKFLOWS'
      | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
      | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
      | 'TASK_REACHABILITY_CLOSED_WORKFLOWS';
    v1TerminateWorkflowExecutionResponse: Record<string, never>;
    v1TerminatedFailureInfo: Record<string, never>;
    v1TimeoutFailureInfo: {
      timeoutType?: components['schemas']['v1TimeoutType'];
      lastHeartbeatDetails?: components['schemas']['v1Payloads'];
    };
    /**
     * @default TIMEOUT_TYPE_UNSPECIFIED
     * @enum {string}
     */
    v1TimeoutType:
      | 'TIMEOUT_TYPE_UNSPECIFIED'
      | 'TIMEOUT_TYPE_START_TO_CLOSE'
      | 'TIMEOUT_TYPE_SCHEDULE_TO_START'
      | 'TIMEOUT_TYPE_SCHEDULE_TO_CLOSE'
      | 'TIMEOUT_TYPE_HEARTBEAT';
    v1TimerCanceledEventAttributes: {
      /** Will match the `timer_id` from `TIMER_STARTED` event for this timer */
      timerId?: string;
      /**
       * The id of the `TIMER_STARTED` event itself
       * Format: int64
       */
      startedEventId?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** The id of the worker who requested this cancel */
      identity?: string;
    };
    v1TimerFiredEventAttributes: {
      /** Will match the `timer_id` from `TIMER_STARTED` event for this timer */
      timerId?: string;
      /**
       * The id of the `TIMER_STARTED` event itself
       * Format: int64
       */
      startedEventId?: string;
    };
    v1TimerStartedEventAttributes: {
      /** The worker/user assigned id for this timer */
      timerId?: string;
      /** How long until this timer fires */
      startToFireTimeout?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
    };
    v1TimestampedBuildIdAssignmentRule: {
      rule?: components['schemas']['v1BuildIdAssignmentRule'];
      /** Format: date-time */
      createTime?: string;
    };
    v1TimestampedCompatibleBuildIdRedirectRule: {
      rule?: components['schemas']['v1CompatibleBuildIdRedirectRule'];
      /** Format: date-time */
      createTime?: string;
    };
    v1TriggerImmediatelyRequest: {
      overlapPolicy?: components['schemas']['v1ScheduleOverlapPolicy'];
      /**
       * Format: date-time
       * @description Timestamp used for the identity of the target workflow.
       *     If not set the default value is the current time.
       */
      scheduledTime?: string;
    };
    v1TriggerWorkflowRuleResponse: {
      /** @description True is the rule was applied, based on the rule conditions (predicate/visibility_query). */
      applied?: boolean;
    };
    v1UnpauseActivityResponse: Record<string, never>;
    v1UnsuccessfulOperationError: {
      /** @description See https://github.com/nexus-rpc/api/blob/main/SPEC.md#operationinfo. */
      operationState?: string;
      failure?: components['schemas']['apinexusv1Failure'];
    };
    v1UpdateActivityOptionsResponse: {
      activityOptions?: components['schemas']['v1ActivityOptions'];
    };
    /**
     * @description Records why a WorkflowExecutionUpdateAdmittedEvent was written to history.
     *     Note that not all admitted Updates result in this event.
     *
     *      - UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY: The UpdateAdmitted event was created when reapplying events during reset
     *     or replication. I.e. an accepted Update on one branch of Workflow history
     *     was converted into an admitted Update on a different branch.
     * @default UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED
     * @enum {string}
     */
    v1UpdateAdmittedEventOrigin:
      | 'UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED'
      | 'UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY';
    /** @description Used as part of Deployment write APIs to update metadata attached to a deployment.
     *     Deprecated. */
    v1UpdateDeploymentMetadata: {
      upsertEntries?: {
        [key: string]: components['schemas']['v1Payload'];
      };
      /** @description List of keys to remove from the metadata. */
      removeEntries?: string[];
    };
    v1UpdateNamespaceInfo: {
      description?: string;
      ownerEmail?: string;
      /** @description A key-value map for any customized purpose.
       *     If data already exists on the namespace,
       *     this will merge with the existing key values. */
      data?: {
        [key: string]: string;
      };
      state?: components['schemas']['v1NamespaceState'];
    };
    v1UpdateNamespaceResponse: {
      namespaceInfo?: components['schemas']['v1NamespaceInfo'];
      config?: components['schemas']['v1NamespaceConfig'];
      replicationConfig?: components['schemas']['v1NamespaceReplicationConfig'];
      /** Format: int64 */
      failoverVersion?: string;
      isGlobalNamespace?: boolean;
    };
    v1UpdateNexusEndpointResponse: {
      endpoint?: components['schemas']['v1Endpoint'];
    };
    /** @description The data needed by a client to refer to a previously invoked Workflow Update. */
    v1UpdateRef: {
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      updateId?: string;
    };
    v1UpdateScheduleResponse: Record<string, never>;
    v1UpdateTaskQueueConfigResponse: {
      config?: components['schemas']['v1TaskQueueConfig'];
    };
    /** [cleanup-wv-pre-release] */
    v1UpdateWorkerBuildIdCompatibilityResponse: Record<string, never>;
    v1UpdateWorkerConfigResponse: {
      workerConfig?: components['schemas']['v1WorkerConfig'];
    };
    v1UpdateWorkerDeploymentVersionMetadataResponse: {
      metadata?: components['schemas']['v1VersionMetadata'];
    };
    /** [cleanup-wv-pre-release] */
    v1UpdateWorkerVersioningRulesResponse: {
      assignmentRules?: components['schemas']['v1TimestampedBuildIdAssignmentRule'][];
      compatibleRedirectRules?: components['schemas']['v1TimestampedCompatibleBuildIdRedirectRule'][];
      /**
       * Format: byte
       * @description This value can be passed back to UpdateWorkerVersioningRulesRequest to
       *     ensure that the rules were not modified between the two updates, which
       *     could lead to lost updates and other confusion.
       */
      conflictToken?: string;
    };
    /**
     * @description UpdateWorkflowExecutionLifecycleStage is specified by clients invoking
     *     Workflow Updates and used to indicate to the server how long the
     *     client wishes to wait for a return value from the API. If any value other
     *     than UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED is sent by the
     *     client then the API will complete before the Update is finished and will
     *     return a handle to the running Update so that it can later be polled for
     *     completion.
     *     If specified stage wasn't reached before server timeout, server returns
     *     actual stage reached.
     *
     *      - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED: An unspecified value for this enum.
     *      - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED: The API call will not return until the Update request has been admitted
     *     by the server - it may be the case that due to a considerations like load
     *     or resource limits that an Update is made to wait before the server will
     *     indicate that it has been received and will be processed. This value
     *     does not wait for any sort of acknowledgement from a worker.
     *      - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED: The API call will not return until the Update has passed validation on a worker.
     *      - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED: The API call will not return until the Update has executed to completion
     *     on a worker and has either been rejected or returned a value or an error.
     * @default UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED
     * @enum {string}
     */
    v1UpdateWorkflowExecutionLifecycleStage:
      | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED'
      | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED'
      | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED'
      | 'UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED';
    v1UpdateWorkflowExecutionOptionsResponse: {
      workflowExecutionOptions?: components['schemas']['v1WorkflowExecutionOptions'];
    };
    v1UpdateWorkflowExecutionRequest: {
      /** @description The namespace name of the target Workflow. */
      namespace?: string;
      workflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** @description If set, this call will error if the most recent (if no Run Id is set on
       *     `workflow_execution`), or specified (if it is) Workflow Execution is not
       *     part of the same execution chain as this Id. */
      firstExecutionRunId?: string;
      waitPolicy?: components['schemas']['v1WaitPolicy'];
      request?: components['schemas']['apiupdatev1Request'];
    };
    v1UpdateWorkflowExecutionResponse: {
      updateRef?: components['schemas']['v1UpdateRef'];
      outcome?: components['schemas']['v1Outcome'];
      stage?: components['schemas']['v1UpdateWorkflowExecutionLifecycleStage'];
    };
    v1UpsertWorkflowSearchAttributesCommandAttributes: {
      searchAttributes?: components['schemas']['v1SearchAttributes'];
    };
    v1UpsertWorkflowSearchAttributesEventAttributes: {
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      searchAttributes?: components['schemas']['v1SearchAttributes'];
    };
    /** @description Information a user can set, often for use by user interfaces. */
    v1UserMetadata: {
      summary?: components['schemas']['v1Payload'];
      details?: components['schemas']['v1Payload'];
    };
    /** @description Information about workflow drainage to help the user determine when it is safe
     *     to decommission a Version. Not present while version is current or ramping.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future. */
    v1VersionDrainageInfo: {
      status?: components['schemas']['v1VersionDrainageStatus'];
      /**
       * Format: date-time
       * @description Last time the drainage status changed.
       */
      lastChangedTime?: string;
      /**
       * Format: date-time
       * @description Last time the system checked for drainage of this version.
       */
      lastCheckedTime?: string;
    };
    /**
     * @description Specify the drainage status for a Worker Deployment Version so users can decide whether they
     *     can safely decommission the version.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future.
     *
     *      - VERSION_DRAINAGE_STATUS_UNSPECIFIED: Drainage Status is not specified.
     *      - VERSION_DRAINAGE_STATUS_DRAINING: The Worker Deployment Version is not used by new workflows but is still used by
     *     open pinned workflows. The version cannot be decommissioned safely.
     *      - VERSION_DRAINAGE_STATUS_DRAINED: The Worker Deployment Version is not used by new or open workflows, but might be still needed by
     *     Queries sent to closed workflows. The version can be decommissioned safely if user does
     *     not query closed workflows. If the user does query closed workflows for some time x after
     *     workflows are closed, they should decommission the version after it has been drained for that duration.
     * @default VERSION_DRAINAGE_STATUS_UNSPECIFIED
     * @enum {string}
     */
    v1VersionDrainageStatus:
      | 'VERSION_DRAINAGE_STATUS_UNSPECIFIED'
      | 'VERSION_DRAINAGE_STATUS_DRAINING'
      | 'VERSION_DRAINAGE_STATUS_DRAINED';
    /** @description VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions. */
    v1VersionInfo: {
      current?: components['schemas']['v1ReleaseInfo'];
      recommended?: components['schemas']['v1ReleaseInfo'];
      instructions?: string;
      alerts?: components['schemas']['v1Alert'][];
      /** Format: date-time */
      lastUpdateTime?: string;
    };
    v1VersionMetadata: {
      /** @description Arbitrary key-values. */
      entries?: {
        [key: string]: components['schemas']['v1Payload'];
      };
    };
    /**
     * @description Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
     *     Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
     *     who completes the first task of the execution, but is also overridable manually for new and
     *     existing workflows (see VersioningOverride).
     *     Experimental. Worker Deployments are experimental and might significantly change in the future.
     *
     *      - VERSIONING_BEHAVIOR_UNSPECIFIED: Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
     *     legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
     *     `WorkerVersioningMode`.)
     *     User needs to use Patching to keep the new code compatible with prior versions when dealing
     *     with Unversioned workflows.
     *      - VERSIONING_BEHAVIOR_PINNED: Workflow will start on the Current Deployment Version of its Task Queue, and then
     *     will be pinned to that same Deployment Version until completion (the Version that
     *     this Workflow is pinned to is specified in `versioning_info.version`).
     *     This behavior eliminates most of compatibility concerns users face when changing their code.
     *     Patching is not needed when pinned workflows code change.
     *     Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
     *     execution to another Deployment Version.
     *     Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
     *     would be when the activity Task Queue workers are not present in the workflow's Deployment
     *     Version, in which case the activity will be sent to the Current Deployment Version of its own
     *     task queue.
     *      - VERSIONING_BEHAVIOR_AUTO_UPGRADE: Workflow will automatically move to the Current Deployment Version of its Task Queue when the
     *     next workflow task is dispatched.
     *     AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
     *     latest Deployment Version, but the user still needs to use Patching to keep the new code
     *     compatible with prior versions for changed workflow types.
     *     Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
     *     execution (as specified in versioning_info.version based on the last completed
     *     workflow task). Exception to this would be when the activity Task Queue workers are not
     *     present in the workflow's Deployment Version, in which case, the activity will be sent to a
     *     different Deployment Version according to the Current Deployment Version of its own task
     *     queue.
     *     Workflows stuck on a backlogged activity will still auto-upgrade if the Current Deployment
     *     Version of their Task Queue changes, without having to wait for the backlogged activity to
     *     complete on the old Version.
     * @default VERSIONING_BEHAVIOR_UNSPECIFIED
     * @enum {string}
     */
    v1VersioningBehavior:
      | 'VERSIONING_BEHAVIOR_UNSPECIFIED'
      | 'VERSIONING_BEHAVIOR_PINNED'
      | 'VERSIONING_BEHAVIOR_AUTO_UPGRADE';
    /** @description Used to override the versioning behavior (and pinned deployment version, if applicable) of a
     *     specific workflow execution. If set, takes precedence over the worker-sent values. See
     *     `WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call
     *     `UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`
     *     to indicate that it should be mutated.
     *     Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
     *     workflow retries, and cron workflows. */
    v1VersioningOverride: {
      pinned?: components['schemas']['VersioningOverridePinnedOverride'];
      /** @description Send the next workflow task to the Current Deployment Version
       *     of its Task Queue when the next workflow task is dispatched. */
      autoUpgrade?: boolean;
      behavior?: components['schemas']['v1VersioningBehavior'];
      deployment?: components['schemas']['v1Deployment'];
      /** @description Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
       *     Identifies the worker deployment version to pin the workflow to, in the format
       *     "<deployment_name>.<build_id>".
       *     Deprecated. Use `override.pinned.version`. */
      pinnedVersion?: string;
    };
    /** @description Specifies client's intent to wait for Update results. */
    v1WaitPolicy: {
      lifecycleStage?: components['schemas']['v1UpdateWorkflowExecutionLifecycleStage'];
    };
    v1WorkerConfig: {
      /** Format: int32 */
      workflowCacheSize?: number;
      simplePollerBehavior?: components['schemas']['WorkerConfigSimplePollerBehavior'];
      autoscalingPollerBehavior?: components['schemas']['WorkerConfigAutoscalingPollerBehavior'];
    };
    /** @description A Worker Deployment (Deployment, for short) represents all workers serving
     *     a shared set of Task Queues. Typically, a Deployment represents one service or
     *     application.
     *     A Deployment contains multiple Deployment Versions, each representing a different
     *     version of workers. (see documentation of WorkerDeploymentVersionInfo)
     *     Deployment records are created in Temporal server automatically when their
     *     first poller arrives to the server.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future. */
    v1WorkerDeploymentInfo: {
      /** @description Identifies a Worker Deployment. Must be unique within the namespace. */
      name?: string;
      /** Deployment Versions that are currently tracked in this Deployment. A DeploymentVersion will be
       *     cleaned up automatically if all the following conditions meet:
       *     - It does not receive new executions (is not current or ramping)
       *     - It has no active pollers (see WorkerDeploymentVersionInfo.pollers_status)
       *     - It is drained (see WorkerDeploymentVersionInfo.drainage_status) */
      versionSummaries?: components['schemas']['WorkerDeploymentInfoWorkerDeploymentVersionSummary'][];
      /** Format: date-time */
      createTime?: string;
      routingConfig?: components['schemas']['v1RoutingConfig'];
      /** @description Identity of the last client who modified the configuration of this Deployment. Set to the
       *     `identity` value sent by APIs such as `SetWorkerDeploymentCurrentVersion` and
       *     `SetWorkerDeploymentRampingVersion`. */
      lastModifierIdentity?: string;
    };
    /** @description Worker Deployment options set in SDK that need to be sent to server in every poll.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future. */
    v1WorkerDeploymentOptions: {
      /** @description Required. Worker Deployment name. */
      deploymentName?: string;
      /** @description The Build ID of the worker. Required when `worker_versioning_mode==VERSIONED`, in which case,
       *     the worker will be part of a Deployment Version. */
      buildId?: string;
      workerVersioningMode?: components['schemas']['v1WorkerVersioningMode'];
    };
    /** @description A Worker Deployment Version (Version, for short) represents a
     *     version of workers within a Worker Deployment. (see documentation of WorkerDeploymentVersionInfo)
     *     Version records are created in Temporal server automatically when their
     *     first poller arrives to the server.
     *     Experimental. Worker Deployment Versions are experimental and might significantly change in the future. */
    v1WorkerDeploymentVersion: {
      /** @description A unique identifier for this Version within the Deployment it is a part of.
       *     Not necessarily unique within the namespace.
       *     The combination of `deployment_name` and `build_id` uniquely identifies this
       *     Version within the namespace, because Deployment names are unique within a namespace. */
      buildId?: string;
      /** @description Identifies the Worker Deployment this Version is part of. */
      deploymentName?: string;
    };
    /** @description A Worker Deployment Version (Version, for short) represents all workers of the same
     *     code and config within a Deployment. Workers of the same Version are expected to
     *     behave exactly the same so when executions move between them there are no
     *     non-determinism issues.
     *     Worker Deployment Versions are created in Temporal server automatically when
     *     their first poller arrives to the server.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future. */
    v1WorkerDeploymentVersionInfo: {
      /** @description Deprecated. Use `deployment_version`. */
      version?: string;
      status?: components['schemas']['v1WorkerDeploymentVersionStatus'];
      deploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      deploymentName?: string;
      /** Format: date-time */
      createTime?: string;
      /**
       * Format: date-time
       * @description Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
       */
      routingChangedTime?: string;
      /**
       * Format: date-time
       * @description
       *     Unset if not current.
       */
      currentSinceTime?: string;
      /**
       * Format: date-time
       * @description
       *     Unset if not ramping. Updated when the version first starts ramping, not on each ramp change.
       */
      rampingSinceTime?: string;
      /**
       * Format: date-time
       * @description Timestamp when this version first became current or ramping.
       */
      firstActivationTime?: string;
      /**
       * Format: date-time
       * @description Timestamp when this version last stopped being current or ramping.
       */
      lastDeactivationTime?: string;
      /**
       * Format: float
       * @description Range: [0, 100]. Must be zero if the version is not ramping (i.e. `ramping_since_time` is nil).
       *     Can be in the range [0, 100] if the version is ramping.
       */
      rampPercentage?: number;
      /** @description All the Task Queues that have ever polled from this Deployment version.
       *     Deprecated. Use `version_task_queues` in DescribeWorkerDeploymentVersionResponse instead. */
      taskQueueInfos?: components['schemas']['WorkerDeploymentVersionInfoVersionTaskQueueInfo'][];
      drainageInfo?: components['schemas']['v1VersionDrainageInfo'];
      metadata?: components['schemas']['v1VersionMetadata'];
    };
    /**
     * @description Specify the status of a Worker Deployment Version.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future.
     *
     *      - WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE: The Worker Deployment Version has been created inside the Worker Deployment but is not used by any
     *     workflow executions. These Versions can still have workflows if they have an explicit Versioning Override targeting
     *     this Version. Such Versioning Override could be set at workflow start time, or at a later time via `UpdateWorkflowExecutionOptions`.
     *      - WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT: The Worker Deployment Version is the current version of the Worker Deployment. All new workflow executions
     *     and tasks of existing unversioned or AutoUpgrade workflows are routed to this version.
     *      - WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING: The Worker Deployment Version is the ramping version of the Worker Deployment. A subset of new Pinned workflow executions are
     *     routed to this version. Moreover, a portion of existing unversioned or AutoUpgrade workflow executions are also routed to this version.
     *      - WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING: The Worker Deployment Version is not used by new workflows but is still used by
     *     open pinned workflows. The version cannot be decommissioned safely.
     *      - WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED: The Worker Deployment Version is not used by new or open workflows, but might be still needed by
     *     Queries sent to closed workflows. The version can be decommissioned safely if user does
     *     not query closed workflows. If the user does query closed workflows for some time x after
     *     workflows are closed, they should decommission the version after it has been drained for that duration.
     * @default WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED
     * @enum {string}
     */
    v1WorkerDeploymentVersionStatus:
      | 'WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED'
      | 'WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE'
      | 'WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT'
      | 'WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING'
      | 'WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING'
      | 'WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED';
    /** @description Worker info message, contains information about the worker and its current state.
     *     All information is provided by the worker itself. */
    v1WorkerHeartbeat: {
      /** @description Worker identifier, should be unique for the namespace.
       *     It is distinct from worker identity, which is not necessarily namespace-unique. */
      workerInstanceKey?: string;
      /** @description Worker identity, set by the client, may not be unique.
       *     Usually host_name+(user group name)+process_id, but can be overwritten by the user. */
      workerIdentity?: string;
      hostInfo?: components['schemas']['v1WorkerHostInfo'];
      /** @description Task queue this worker is polling for tasks. */
      taskQueue?: string;
      deploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      sdkName?: string;
      sdkVersion?: string;
      status?: components['schemas']['v1WorkerStatus'];
      /**
       * Worker start time.
       *     It can be used to determine worker uptime. (current time - start time)
       * Format: date-time
       */
      startTime?: string;
      /**
       * Format: date-time
       * @description Timestamp of this heartbeat, coming from the worker. Worker should set it to "now".
       *     Note that this timestamp comes directly from the worker and is subject to workers' clock skew.
       */
      heartbeatTime?: string;
      /** @description Elapsed time since the last heartbeat from the worker. */
      elapsedSinceLastHeartbeat?: string;
      workflowTaskSlotsInfo?: components['schemas']['v1WorkerSlotsInfo'];
      activityTaskSlotsInfo?: components['schemas']['v1WorkerSlotsInfo'];
      nexusTaskSlotsInfo?: components['schemas']['v1WorkerSlotsInfo'];
      localActivitySlotsInfo?: components['schemas']['v1WorkerSlotsInfo'];
      workflowPollerInfo?: components['schemas']['v1WorkerPollerInfo'];
      workflowStickyPollerInfo?: components['schemas']['v1WorkerPollerInfo'];
      activityPollerInfo?: components['schemas']['v1WorkerPollerInfo'];
      nexusPollerInfo?: components['schemas']['v1WorkerPollerInfo'];
      /**
       * Format: int32
       * @description A Workflow Task found a cached Workflow Execution to run against.
       */
      totalStickyCacheHit?: number;
      /**
       * Format: int32
       * @description A Workflow Task did not find a cached Workflow execution to run against.
       */
      totalStickyCacheMiss?: number;
      /**
       * Format: int32
       * @description Current cache size, expressed in number of Workflow Executions.
       */
      currentStickyCacheSize?: number;
      /** @description Plugins currently in use by this SDK. */
      plugins?: components['schemas']['v1PluginInfo'][];
    };
    /** Holds everything needed to identify the worker host/process context */
    v1WorkerHostInfo: {
      /** @description Worker host identifier. */
      hostName?: string;
      /** Worker process identifier. This id should be unique for all _processes_
       *     running workers in the namespace, and should be shared by all workers
       *     in the same process.
       *     This will be used to build the worker command nexus task queue name:
       *     "temporal-sys/worker-commands/{process_key}" */
      processKey?: string;
      /** @description Worker process identifier. Unlike process_key, this id only needs to be unique
       *     within one host (so using e.g. a unix pid would be appropriate). */
      processId?: string;
      /**
       * Format: float
       * @description System used CPU as a float in the range [0.0, 1.0] where 1.0 is defined as all
       *     cores on the host pegged.
       */
      currentHostCpuUsage?: number;
      /**
       * Format: float
       * @description System used memory as a float in the range [0.0, 1.0] where 1.0 is defined as
       *     all available memory on the host is used.
       */
      currentHostMemUsage?: number;
    };
    v1WorkerInfo: {
      workerHeartbeat?: components['schemas']['v1WorkerHeartbeat'];
    };
    v1WorkerPollerInfo: {
      /**
       * Format: int32
       * @description Number of polling RPCs that are currently in flight.
       */
      currentPollers?: number;
      /** Format: date-time */
      lastSuccessfulPollTime?: string;
      /** Set true if the number of concurrent pollers is auto-scaled */
      isAutoscaling?: boolean;
    };
    /** @description This is used to send commands to a specific worker or a group of workers.
     *     Right now, it is used to send commands to a specific worker instance.
     *     Will be extended to be able to send command to multiple workers. */
    v1WorkerSelector: {
      /** @description Worker instance key to which the command should be sent. */
      workerInstanceKey?: string;
    };
    v1WorkerSlotsInfo: {
      /**
       * Format: int32
       * @description Number of slots available for the worker to specific tasks.
       *     May be -1 if the upper bound is not known.
       */
      currentAvailableSlots?: number;
      /**
       * Format: int32
       * @description Number of slots used by the worker for specific tasks.
       */
      currentUsedSlots?: number;
      /** Kind of the slot supplier, which is used to determine how the slots are allocated.
       *     Possible values: "Fixed | ResourceBased | Custom String" */
      slotSupplierKind?: string;
      /**
       * Format: int32
       * @description Total number of tasks processed (completed both successfully and unsuccesfully, or any other way)
       *     by the worker since the worker started. This is a cumulative counter.
       */
      totalProcessedTasks?: number;
      /**
       * Format: int32
       * @description Total number of failed tasks processed by the worker so far.
       */
      totalFailedTasks?: number;
      /**
       * Format: int32
       * @description Number of tasks processed in since the last heartbeat from the worker.
       *     This is a cumulative counter, and it is reset to 0 each time the worker sends a heartbeat.
       *     Contains both successful and failed tasks.
       */
      lastIntervalProcessedTasks?: number;
      /**
       * Format: int32
       * @description Number of failed tasks processed since the last heartbeat from the worker.
       */
      lastIntervalFailureTasks?: number;
    };
    /**
     * @default WORKER_STATUS_UNSPECIFIED
     * @enum {string}
     */
    v1WorkerStatus:
      | 'WORKER_STATUS_UNSPECIFIED'
      | 'WORKER_STATUS_RUNNING'
      | 'WORKER_STATUS_SHUTTING_DOWN'
      | 'WORKER_STATUS_SHUTDOWN';
    /** @description Identifies the version that a worker is compatible with when polling or identifying itself,
     *     and whether or not this worker is opting into the build-id based versioning feature. This is
     *     used by matching to determine which workers ought to receive what tasks.
     *     Deprecated. Use WorkerDeploymentOptions instead. */
    v1WorkerVersionCapabilities: {
      /** An opaque whole-worker identifier */
      buildId?: string;
      /** @description If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
       *     tasks. */
      useVersioning?: boolean;
      /** @description Must be sent if user has set a deployment series name (versioning-3). */
      deploymentSeriesName?: string;
    };
    /** Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.
     *     Identifies the version(s) of a worker that processed a task */
    v1WorkerVersionStamp: {
      /** @description An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
       *     message is included in requests which previously used that. */
      buildId?: string;
      /** @description If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
       *     marker for workflow reset points and the BuildIDs search attribute. */
      useVersioning?: boolean;
    };
    /**
     * @description Versioning Mode of a worker is set by the app developer in the worker code, and specifies the
     *     behavior of the system in the following related aspects:
     *     - Whether or not Temporal Server considers this worker's version (Build ID) when dispatching
     *       tasks to it.
     *     - Whether or not the workflows processed by this worker are versioned using the worker's version.
     *     Experimental. Worker Deployments are experimental and might significantly change in the future.
     *
     *      - WORKER_VERSIONING_MODE_UNVERSIONED: Workers with this mode are not distinguished from each other for task routing, even if they
     *     have different Build IDs.
     *     Workflows processed by this worker will be unversioned and user needs to use Patching to keep
     *     the new code compatible with prior versions.
     *     This mode is recommended to be used along with Rolling Upgrade deployment strategies.
     *     Workers with this mode are represented by the special string `__unversioned__` in the APIs.
     *      - WORKER_VERSIONING_MODE_VERSIONED: Workers with this mode are part of a Worker Deployment Version which is identified as
     *     "<deployment_name>.<build_id>". Such workers are called "versioned" as opposed to
     *     "unversioned".
     *     Each Deployment Version is distinguished from other Versions for task routing and users can
     *     configure Temporal Server to send tasks to a particular Version (see
     *     `WorkerDeploymentInfo.routing_config`). This mode is the best option for Blue/Green and
     *     Rainbow strategies (but typically not suitable for Rolling upgrades.)
     *     Workflow Versioning Behaviors are enabled in this mode: each workflow type must choose
     *     between the Pinned and AutoUpgrade behaviors. Depending on the chosen behavior, the user may
     *     or may not need to use Patching to keep the new code compatible with prior versions. (see
     *     VersioningBehavior enum.)
     * @default WORKER_VERSIONING_MODE_UNSPECIFIED
     * @enum {string}
     */
    v1WorkerVersioningMode:
      | 'WORKER_VERSIONING_MODE_UNSPECIFIED'
      | 'WORKER_VERSIONING_MODE_UNVERSIONED'
      | 'WORKER_VERSIONING_MODE_VERSIONED';
    /** @description Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
     *     uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
     *     run id as a way of saying "target the latest run of the workflow". */
    v1WorkflowExecution: {
      workflowId?: string;
      runId?: string;
    };
    v1WorkflowExecutionCancelRequestedEventAttributes: {
      /** User provided reason for requesting cancellation
       *     TODO: shall we create a new field with name "reason" and deprecate this one? */
      cause?: string;
      /**
       * TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?
       * Format: int64
       */
      externalInitiatedEventId?: string;
      externalWorkflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** id of the worker or client who requested this cancel */
      identity?: string;
    };
    v1WorkflowExecutionCanceledEventAttributes: {
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      details?: components['schemas']['v1Payloads'];
    };
    v1WorkflowExecutionCompletedEventAttributes: {
      result?: components['schemas']['v1Payloads'];
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** @description If another run is started by cron, this contains the new run id. */
      newExecutionRunId?: string;
    };
    v1WorkflowExecutionConfig: {
      taskQueue?: components['schemas']['v1TaskQueue'];
      workflowExecutionTimeout?: string;
      workflowRunTimeout?: string;
      defaultWorkflowTaskTimeout?: string;
      userMetadata?: components['schemas']['v1UserMetadata'];
    };
    v1WorkflowExecutionContinuedAsNewEventAttributes: {
      /** The run ID of the new workflow started by this continue-as-new */
      newExecutionRunId?: string;
      workflowType?: components['schemas']['v1WorkflowType'];
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** TODO: How and is this used? */
      backoffStartInterval?: string;
      initiator?: components['schemas']['v1ContinueAsNewInitiator'];
      failure?: components['schemas']['apifailurev1Failure'];
      lastCompletionResult?: components['schemas']['v1Payloads'];
      header?: components['schemas']['v1Header'];
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      /** @description If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
       *     the assignment rules will be used to independently assign a Build ID to the new execution.
       *     Deprecated. Only considered for versioning v0.2. */
      inheritBuildId?: boolean;
    };
    /** @description Holds all the extra information about workflow execution that is not part of Visibility. */
    v1WorkflowExecutionExtendedInfo: {
      /**
       * Format: date-time
       * @description Workflow execution expiration time is defined as workflow start time plus expiration timeout.
       *     Workflow start time may change after workflow reset.
       */
      executionExpirationTime?: string;
      /**
       * Format: date-time
       * @description Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
       */
      runExpirationTime?: string;
      /** indicates if the workflow received a cancel request */
      cancelRequested?: boolean;
      /**
       * Format: date-time
       * @description Last workflow reset time. Nil if the workflow was never reset.
       */
      lastResetTime?: string;
      /**
       * Format: date-time
       * @description Original workflow start time.
       */
      originalStartTime?: string;
      /** @description Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run. */
      resetRunId?: string;
      /** @description Request ID information (eg: history event information associated with the request ID).
       *     Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
       *     calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
       *     used in the StartWorkflowExecution request). */
      requestIdInfos?: {
        [key: string]: components['schemas']['v1RequestIdInfo'];
      };
    };
    v1WorkflowExecutionFailedEventAttributes: {
      failure?: components['schemas']['apifailurev1Failure'];
      retryState?: components['schemas']['v1RetryState'];
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      /** @description If another run is started by cron or retry, this contains the new run id. */
      newExecutionRunId?: string;
    };
    v1WorkflowExecutionFilter: {
      workflowId?: string;
      runId?: string;
    };
    /** @description Hold basic information about a workflow execution.
     *     This structure is a part of visibility, and thus contain a limited subset of information. */
    v1WorkflowExecutionInfo: {
      execution?: components['schemas']['v1WorkflowExecution'];
      type?: components['schemas']['v1WorkflowType'];
      /** Format: date-time */
      startTime?: string;
      /** Format: date-time */
      closeTime?: string;
      status?: components['schemas']['v1WorkflowExecutionStatus'];
      /** Format: int64 */
      historyLength?: string;
      parentNamespaceId?: string;
      parentExecution?: components['schemas']['v1WorkflowExecution'];
      /** Format: date-time */
      executionTime?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      autoResetPoints?: components['schemas']['v1ResetPoints'];
      taskQueue?: string;
      /** Format: int64 */
      stateTransitionCount?: string;
      /** Format: int64 */
      historySizeBytes?: string;
      mostRecentWorkerVersionStamp?: components['schemas']['v1WorkerVersionStamp'];
      /** @description Workflow execution duration is defined as difference between close time and execution time.
       *     This field is only populated if the workflow is closed. */
      executionDuration?: string;
      rootExecution?: components['schemas']['v1WorkflowExecution'];
      /** The currently assigned build ID for this execution. Presence of this value means worker versioning is used
       *     for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
       *     when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
       *     again, the assigned build ID may change according to the latest versioning rules.
       *     Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
       *     this execution.
       *     Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv] */
      assignedBuildId?: string;
      /** Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
       *     of using the assignment rules.
       *     Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv] */
      inheritedBuildId?: string;
      /** The first run ID in the execution chain.
       *     Executions created via the following operations are considered to be in the same chain
       *     - ContinueAsNew
       *     - Workflow Retry
       *     - Workflow Reset
       *     - Cron Schedule */
      firstRunId?: string;
      versioningInfo?: components['schemas']['v1WorkflowExecutionVersioningInfo'];
      /** @description The name of Worker Deployment that completed the most recent workflow task.
       *     Experimental. Worker Deployments are experimental and might change in the future. */
      workerDeploymentName?: string;
      priority?: components['schemas']['v1Priority'];
    };
    v1WorkflowExecutionOptions: {
      versioningOverride?: components['schemas']['v1VersioningOverride'];
    };
    v1WorkflowExecutionOptionsUpdatedEventAttributes: {
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      /** @description Versioning override removed in this event. */
      unsetVersioningOverride?: boolean;
      /** @description Request ID attachedto the running workflow execution so that subsequent requests with same
       *     request ID will be deduped. */
      attachedRequestId?: string;
      /** @description Completion callbacks attached to the running workflow execution. */
      attachedCompletionCallbacks?: components['schemas']['v1Callback'][];
    };
    v1WorkflowExecutionSignaledEventAttributes: {
      /** The name/type of the signal to fire */
      signalName?: string;
      input?: components['schemas']['v1Payloads'];
      /** id of the worker/client who sent this signal */
      identity?: string;
      header?: components['schemas']['v1Header'];
      /** @description Deprecated. This field is never respected and should always be set to false. */
      skipGenerateWorkflowTask?: boolean;
      externalWorkflowExecution?: components['schemas']['v1WorkflowExecution'];
    };
    /** Always the first event in workflow history */
    v1WorkflowExecutionStartedEventAttributes: {
      workflowType?: components['schemas']['v1WorkflowType'];
      /** @description If this workflow is a child, the namespace our parent lives in.
       *     SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only. */
      parentWorkflowNamespace?: string;
      parentWorkflowNamespaceId?: string;
      parentWorkflowExecution?: components['schemas']['v1WorkflowExecution'];
      /**
       * EventID of the child execution initiated event in parent workflow
       * Format: int64
       */
      parentInitiatedEventId?: string;
      taskQueue?: components['schemas']['v1TaskQueue'];
      input?: components['schemas']['v1Payloads'];
      /** @description Total workflow execution timeout including retries and continue as new. */
      workflowExecutionTimeout?: string;
      /** @description Timeout of a single workflow run. */
      workflowRunTimeout?: string;
      /** @description Timeout of a single workflow task. */
      workflowTaskTimeout?: string;
      /** @description Run id of the previous workflow which continued-as-new or retried or cron executed into this
       *     workflow. */
      continuedExecutionRunId?: string;
      initiator?: components['schemas']['v1ContinueAsNewInitiator'];
      continuedFailure?: components['schemas']['apifailurev1Failure'];
      lastCompletionResult?: components['schemas']['v1Payloads'];
      /** @description This is the run id when the WorkflowExecutionStarted event was written.
       *     A workflow reset changes the execution run_id, but preserves this field. */
      originalExecutionRunId?: string;
      /** Identity of the client who requested this execution */
      identity?: string;
      /** @description This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.
       *     Used to identify a chain. */
      firstExecutionRunId?: string;
      retryPolicy?: components['schemas']['v1RetryPolicy'];
      /**
       * Starting at 1, the number of times we have tried to execute this workflow
       * Format: int32
       */
      attempt?: number;
      /**
       * Format: date-time
       * @description The absolute time at which the workflow will be timed out.
       *     This is passed without change to the next run/retry of a workflow.
       */
      workflowExecutionExpirationTime?: string;
      /** If this workflow runs on a cron schedule, it will appear here */
      cronSchedule?: string;
      /** @description For a cron workflow, this contains the amount of time between when this iteration of
       *     the cron workflow was scheduled and when it should run next per its cron_schedule. */
      firstWorkflowTaskBackoff?: string;
      memo?: components['schemas']['v1Memo'];
      searchAttributes?: components['schemas']['v1SearchAttributes'];
      prevAutoResetPoints?: components['schemas']['v1ResetPoints'];
      header?: components['schemas']['v1Header'];
      /**
       * Version of the child execution initiated event in parent workflow
       *     It should be used together with parent_initiated_event_id to identify
       *     a child initiated event for global namespace
       * Format: int64
       */
      parentInitiatedEventVersion?: string;
      /** @description This field is new in 1.21. */
      workflowId?: string;
      sourceVersionStamp?: components['schemas']['v1WorkerVersionStamp'];
      /** @description Completion callbacks attached when this workflow was started. */
      completionCallbacks?: components['schemas']['v1Callback'][];
      rootWorkflowExecution?: components['schemas']['v1WorkflowExecution'];
      /** When present, this execution is assigned to the build ID of its parent or previous execution.
       *     Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv] */
      inheritedBuildId?: string;
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      /** @description When present, it means this is a child workflow of a parent that is Pinned to this Worker
       *     Deployment Version. In this case, child workflow will start as Pinned to this Version instead
       *     of starting on the Current Version of its Task Queue.
       *     This is set only if the child workflow is starting on a Task Queue belonging to the same
       *     Worker Deployment Version.
       *     Deprecated. Use `parent_versioning_info`. */
      parentPinnedWorkerDeploymentVersion?: string;
      priority?: components['schemas']['v1Priority'];
      inheritedPinnedVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      /** @description A boolean indicating whether the SDK has asked to eagerly execute the first workflow task for this workflow and
       *     eager execution was accepted by the server.
       *     Only populated by server with version >= 1.29.0. */
      eagerExecutionAccepted?: boolean;
    };
    /**
     * @description  - WORKFLOW_EXECUTION_STATUS_RUNNING: Value 1 is hardcoded in SQL persistence.
     * @default WORKFLOW_EXECUTION_STATUS_UNSPECIFIED
     * @enum {string}
     */
    v1WorkflowExecutionStatus:
      | 'WORKFLOW_EXECUTION_STATUS_UNSPECIFIED'
      | 'WORKFLOW_EXECUTION_STATUS_RUNNING'
      | 'WORKFLOW_EXECUTION_STATUS_COMPLETED'
      | 'WORKFLOW_EXECUTION_STATUS_FAILED'
      | 'WORKFLOW_EXECUTION_STATUS_CANCELED'
      | 'WORKFLOW_EXECUTION_STATUS_TERMINATED'
      | 'WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW'
      | 'WORKFLOW_EXECUTION_STATUS_TIMED_OUT';
    v1WorkflowExecutionTerminatedEventAttributes: {
      /** User/client provided reason for termination */
      reason?: string;
      details?: components['schemas']['v1Payloads'];
      /** id of the client who requested termination */
      identity?: string;
    };
    v1WorkflowExecutionTimedOutEventAttributes: {
      retryState?: components['schemas']['v1RetryState'];
      /** @description If another run is started by cron or retry, this contains the new run id. */
      newExecutionRunId?: string;
    };
    v1WorkflowExecutionUpdateAcceptedEventAttributes: {
      /** @description The instance ID of the update protocol that generated this event. */
      protocolInstanceId?: string;
      /** @description The message ID of the original request message that initiated this
       *     update. Needed so that the worker can recreate and deliver that same
       *     message as part of replay. */
      acceptedRequestMessageId?: string;
      /**
       * Format: int64
       * @description The event ID used to sequence the original request message.
       */
      acceptedRequestSequencingEventId?: string;
      acceptedRequest?: components['schemas']['apiupdatev1Request'];
    };
    v1WorkflowExecutionUpdateAdmittedEventAttributes: {
      request?: components['schemas']['apiupdatev1Request'];
      origin?: components['schemas']['v1UpdateAdmittedEventOrigin'];
    };
    v1WorkflowExecutionUpdateCompletedEventAttributes: {
      meta?: components['schemas']['v1Meta'];
      /**
       * Format: int64
       * @description The event ID indicating the acceptance of this update.
       */
      acceptedEventId?: string;
      outcome?: components['schemas']['v1Outcome'];
    };
    v1WorkflowExecutionUpdateRejectedEventAttributes: {
      /** @description The instance ID of the update protocol that generated this event. */
      protocolInstanceId?: string;
      /** @description The message ID of the original request message that initiated this
       *     update. Needed so that the worker can recreate and deliver that same
       *     message as part of replay. */
      rejectedRequestMessageId?: string;
      /**
       * Format: int64
       * @description The event ID used to sequence the original request message.
       */
      rejectedRequestSequencingEventId?: string;
      rejectedRequest?: components['schemas']['apiupdatev1Request'];
      failure?: components['schemas']['apifailurev1Failure'];
    };
    /** @description Holds all the information about worker versioning for a particular workflow execution.
     *     Experimental. Versioning info is experimental and might change in the future. */
    v1WorkflowExecutionVersioningInfo: {
      behavior?: components['schemas']['v1VersioningBehavior'];
      deployment?: components['schemas']['v1Deployment'];
      /** @description Deprecated. Use `deployment_version`. */
      version?: string;
      deploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
      versioningOverride?: components['schemas']['v1VersioningOverride'];
      deploymentTransition?: components['schemas']['v1DeploymentTransition'];
      versionTransition?: components['schemas']['v1DeploymentVersionTransition'];
    };
    /**
     * @description Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
     *     Note that it is *never* valid to have two actively running instances of the same workflow id.
     *
     *     See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
     *
     *      - WORKFLOW_ID_CONFLICT_POLICY_FAIL: Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
     *      - WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING: Don't start a new workflow; instead return a workflow handle for the running workflow.
     *      - WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING: Terminate the running workflow before starting a new one.
     * @default WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED
     * @enum {string}
     */
    v1WorkflowIdConflictPolicy:
      | 'WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED'
      | 'WORKFLOW_ID_CONFLICT_POLICY_FAIL'
      | 'WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING'
      | 'WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING';
    /**
     * @description Defines whether to allow re-using a workflow id from a previously *closed* workflow.
     *     If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
     *
     *     See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
     *
     *      - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: Allow starting a workflow execution using the same workflow id.
     *      - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: Allow starting a workflow execution using the same workflow id, only when the last
     *     execution's final state is one of [terminated, cancelled, timed out, failed].
     *      - WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: Do not permit re-use of the workflow id for this workflow. Future start workflow requests
     *     could potentially change the policy, allowing re-use of the workflow id.
     *      - WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING: This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.
     *     If specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on
     *     the request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.
     *     If no running workflow, then the behavior is the same as ALLOW_DUPLICATE.
     * @default WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED
     * @enum {string}
     */
    v1WorkflowIdReusePolicy:
      | 'WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED'
      | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE'
      | 'WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY'
      | 'WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE'
      | 'WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING';
    v1WorkflowPropertiesModifiedEventAttributes: {
      /**
       * The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
       * Format: int64
       */
      workflowTaskCompletedEventId?: string;
      upsertedMemo?: components['schemas']['v1Memo'];
    };
    /** Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes */
    v1WorkflowPropertiesModifiedExternallyEventAttributes: {
      /** @description Not used. */
      newTaskQueue?: string;
      /** @description Not used. */
      newWorkflowTaskTimeout?: string;
      /** @description Not used. */
      newWorkflowRunTimeout?: string;
      /** @description Not used. */
      newWorkflowExecutionTimeout?: string;
      upsertedMemo?: components['schemas']['v1Memo'];
    };
    /** See https://docs.temporal.io/docs/concepts/queries/ */
    v1WorkflowQuery: {
      /** @description The workflow-author-defined identifier of the query. Typically a function name. */
      queryType?: string;
      queryArgs?: components['schemas']['v1Payloads'];
      header?: components['schemas']['v1Header'];
    };
    /** Answer to a `WorkflowQuery` */
    v1WorkflowQueryResult: {
      resultType?: components['schemas']['v1QueryResultType'];
      answer?: components['schemas']['v1Payloads'];
      /** @description Mutually exclusive with `answer`. Set when the query fails.
       *     See also the newer `failure` field. */
      errorMessage?: string;
      failure?: components['schemas']['apifailurev1Failure'];
    };
    /** @description WorkflowRule describes a rule that can be applied to any workflow in this namespace. */
    v1WorkflowRule: {
      /**
       * Format: date-time
       * @description Rule creation time.
       */
      createTime?: string;
      spec?: components['schemas']['v1WorkflowRuleSpec'];
      /** Identity of the actor that created the rule */
      createdByIdentity?: string;
      /** @description Rule description. */
      description?: string;
    };
    v1WorkflowRuleAction: {
      activityPause?: components['schemas']['WorkflowRuleActionActionActivityPause'];
    };
    v1WorkflowRuleSpec: {
      /** @description The id of the new workflow rule. Must be unique within the namespace.
       *     Can be set by the user, and can have business meaning. */
      id?: string;
      activityStart?: components['schemas']['WorkflowRuleSpecActivityStartingTrigger'];
      /** Restricted Visibility query.
       *     This query is used to filter workflows in this namespace to which this rule should apply.
       *     It is applied to any running workflow each time a triggering event occurs, before the trigger predicate is evaluated.
       *     The following workflow attributes are supported:
       *     - WorkflowType
       *     - WorkflowId
       *     - StartTime
       *     - ExecutionStatus */
      visibilityQuery?: string;
      /** @description WorkflowRuleAction to be taken when the rule is triggered and predicate is matched. */
      actions?: components['schemas']['v1WorkflowRuleAction'][];
      /**
       * Format: date-time
       * @description Expiration time of the rule. After this time, the rule will be deleted.
       *     Can be empty if the rule should never expire.
       */
      expirationTime?: string;
    };
    v1WorkflowTaskCompletedEventAttributes: {
      /**
       * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
       * Format: int64
       */
      startedEventId?: string;
      /** Identity of the worker who completed this task */
      identity?: string;
      /** @description Binary ID of the worker who completed this task
       *     Deprecated. Replaced with `deployment_version`. */
      binaryChecksum?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
      sdkMetadata?: components['schemas']['v1WorkflowTaskCompletedMetadata'];
      meteringMetadata?: components['schemas']['v1MeteringMetadata'];
      deployment?: components['schemas']['v1Deployment'];
      versioningBehavior?: components['schemas']['v1VersioningBehavior'];
      /** @description The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
       *     is set. This value updates workflow execution's `versioning_info.version`.
       *     Experimental. Worker Deployments are experimental and might significantly change in the future.
       *     Deprecated. Replaced with `deployment_version`. */
      workerDeploymentVersion?: string;
      /** @description The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`
       *     is set. This value updates workflow execution's `worker_deployment_name`.
       *     Experimental. Worker Deployments are experimental and might significantly change in the future. */
      workerDeploymentName?: string;
      deploymentVersion?: components['schemas']['v1WorkerDeploymentVersion'];
    };
    v1WorkflowTaskCompletedMetadata: {
      /**
       * Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
       * @description During replay:
       *     * If a flag is not recognized (value is too high or not defined), it must fail the workflow
       *       task.
       *     * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
       *       that flag during and after this WFT are allowed to assume that the flag is present.
       *     * If a code check for a flag does not find the flag in the set of used flags, it must take
       *       the branch corresponding to the absence of that flag.
       *
       *     During non-replay execution of new WFTs:
       *     * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
       *       previously recorded) flags when completing the WFT.
       *
       *     SDKs which are too old to even know about this field at all are considered to produce
       *     undefined behavior if they replay workflows which used this mechanism.
       */
      coreUsedFlags?: number[];
      /** @description Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
       *     here as processing a workflow with a different language than the one which authored it is
       *     already undefined behavior. See `core_used_patches` for more.
       *      */
      langUsedFlags?: number[];
      /** @description Name of the SDK that processed the task. This is usually something like "temporal-go" and is
       *     usually the same as client-name gRPC header. This should only be set if its value changed
       *     since the last time recorded on the workflow (or be set on the first task).
       *      */
      sdkName?: string;
      /** @description Version of the SDK that processed the task. This is usually something like "1.20.0" and is
       *     usually the same as client-version gRPC header. This should only be set if its value changed
       *     since the last time recorded on the workflow (or be set on the first task). */
      sdkVersion?: string;
    };
    /**
     * @description Workflow tasks can fail for various reasons. Note that some of these reasons can only originate
     *     from the server, and some of them can only originate from the SDK/worker.
     *
     *      - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND: Between starting and completing the workflow task (with a workflow completion command), some
     *     new command (like a signal) was processed into workflow history. The outstanding task will be
     *     failed with this reason, and a worker must pick up a new task.
     *      - WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE: The worker wishes to fail the task and have the next one be generated on a normal, not sticky
     *     queue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.
     *      - WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR: The worker encountered a mismatch while replaying history between what was expected, and
     *     what the workflow code actually did.
     *      - WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED: We send the below error codes to users when their requests would violate a size constraint
     *     of their workflow. We do this to ensure that the state of their workflow does not become too
     *     large because that can cause severe performance degradation. You can modify the thresholds for
     *     each of these errors within your dynamic config.
     *
     *     Spawning a new child workflow would cause this workflow to exceed its limit of pending child
     *     workflows.
     *      - WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED: Starting a new activity would cause this workflow to exceed its limit of pending activities
     *     that we track.
     *      - WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED: A workflow has a buffer of signals that have not yet reached their destination. We return this
     *     error when sending a new signal would exceed the capacity of this buffer.
     *      - WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED: Similarly, we have a buffer of pending requests to cancel other workflows. We return this error
     *     when our capacity for pending cancel requests is already reached.
     *      - WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE: Workflow execution update message (update.Acceptance, update.Rejection, or update.Response)
     *     has wrong format, or missing required fields.
     *      - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE: Similar to WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND, but for updates.
     *      - WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES: A workflow task completed with an invalid ScheduleNexusOperation command.
     *      - WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED: A workflow task completed requesting to schedule a Nexus Operation exceeding the server configured limit.
     *      - WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES: A workflow task completed with an invalid RequestCancelNexusOperation command.
     *      - WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED: A workflow task completed requesting a feature that's disabled on the server (either system wide or - typically -
     *     for the workflow's namespace).
     *     Check the workflow task failure message for more information.
     *      - WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE: A workflow task failed because a grpc message was too large.
     * @default WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED
     * @enum {string}
     */
    v1WorkflowTaskFailedCause:
      | 'WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID'
      | 'WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE'
      | 'WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND'
      | 'WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE'
      | 'WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY'
      | 'WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE'
      | 'WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES'
      | 'WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED'
      | 'WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE';
    v1WorkflowTaskFailedEventAttributes: {
      /**
       * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
       * Format: int64
       */
      startedEventId?: string;
      cause?: components['schemas']['v1WorkflowTaskFailedCause'];
      failure?: components['schemas']['apifailurev1Failure'];
      /** If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task? */
      identity?: string;
      /** @description The original run id of the workflow. For reset workflow. */
      baseRunId?: string;
      /** @description If the workflow is being reset, the new run id. */
      newRunId?: string;
      /**
       * TODO: ?
       * Format: int64
       */
      forkEventVersion?: string;
      /** Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       *     If a worker explicitly failed this task, its binary id */
      binaryChecksum?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
    };
    v1WorkflowTaskScheduledEventAttributes: {
      taskQueue?: components['schemas']['v1TaskQueue'];
      /** How long the worker has to process this task once receiving it before it times out */
      startToCloseTimeout?: string;
      /**
       * Starting at 1, how many attempts there have been to complete this task
       * Format: int32
       */
      attempt?: number;
    };
    v1WorkflowTaskStartedEventAttributes: {
      /**
       * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /** Identity of the worker who picked up this task */
      identity?: string;
      /** TODO: ? Appears unused? */
      requestId?: string;
      /** @description True if this workflow should continue-as-new soon because its history size (in
       *     either event count or bytes) is getting large. */
      suggestContinueAsNew?: boolean;
      /**
       * Format: int64
       * @description Total history size in bytes, which the workflow might use to decide when to
       *     continue-as-new regardless of the suggestion. Note that history event count is
       *     just the event id of this event, so we don't include it explicitly here.
       */
      historySizeBytes?: string;
      workerVersion?: components['schemas']['v1WorkerVersionStamp'];
      /**
       * Used by server internally to properly reapply build ID redirects to an execution
       *     when rebuilding it from events.
       *     Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
       * Format: int64
       */
      buildIdRedirectCounter?: string;
    };
    v1WorkflowTaskTimedOutEventAttributes: {
      /**
       * The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
       * Format: int64
       */
      scheduledEventId?: string;
      /**
       * The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
       * Format: int64
       */
      startedEventId?: string;
      timeoutType?: components['schemas']['v1TimeoutType'];
    };
    /** Represents the identifier used by a workflow author to define the workflow. Typically, the
     *     name of a function. This is sometimes referred to as the workflow's "name" */
    v1WorkflowType: {
      name?: string;
    };
    v1WorkflowTypeFilter: {
      name?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: {
    WorkflowServiceStartWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceStartWorkflowExecutionBody'];
      };
    };
    WorkflowServiceSetWorkerDeploymentRampingVersionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceSetWorkerDeploymentRampingVersionBody'];
      };
    };
    WorkflowServiceFetchWorkerConfigBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceFetchWorkerConfigBody'];
      };
    };
    WorkflowServiceRequestCancelWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRequestCancelWorkflowExecutionBody'];
      };
    };
    WorkflowServiceRespondActivityTaskCompletedBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRespondActivityTaskCompletedBody'];
      };
    };
    WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody'];
      };
    };
    WorkflowServiceRecordWorkerHeartbeatBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRecordWorkerHeartbeatBody'];
      };
    };
    WorkflowServiceRespondActivityTaskFailedByIdBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRespondActivityTaskFailedByIdBody'];
      };
    };
    WorkflowServiceUpdateWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateWorkflowExecutionBody'];
      };
    };
    WorkflowServiceUpdateWorkerConfigBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateWorkerConfigBody'];
      };
    };
    WorkflowServicePauseActivityBody: {
      content: {
        'application/json': components['schemas']['WorkflowServicePauseActivityBody'];
      };
    };
    WorkflowServiceExecuteMultiOperationBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceExecuteMultiOperationBody'];
      };
    };
    v1CreateNexusEndpointRequest: {
      content: {
        'application/json': components['schemas']['v1CreateNexusEndpointRequest'];
      };
    };
    WorkflowServiceTerminateWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceTerminateWorkflowExecutionBody'];
      };
    };
    WorkflowServiceRecordActivityTaskHeartbeatBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRecordActivityTaskHeartbeatBody'];
      };
    };
    WorkflowServiceResetActivityBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceResetActivityBody'];
      };
    };
    WorkflowServiceSignalWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceSignalWorkflowExecutionBody'];
      };
    };
    WorkflowServicePatchScheduleBody: {
      content: {
        'application/json': components['schemas']['WorkflowServicePatchScheduleBody'];
      };
    };
    WorkflowServiceRespondActivityTaskCanceledBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRespondActivityTaskCanceledBody'];
      };
    };
    WorkflowServiceQueryWorkflowBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceQueryWorkflowBody'];
      };
    };
    v1RegisterNamespaceRequest: {
      content: {
        'application/json': components['schemas']['v1RegisterNamespaceRequest'];
      };
    };
    WorkflowServiceRespondActivityTaskCanceledByIdBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRespondActivityTaskCanceledByIdBody'];
      };
    };
    WorkflowServiceRespondActivityTaskCompletedByIdBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRespondActivityTaskCompletedByIdBody'];
      };
    };
    WorkflowServiceRespondActivityTaskFailedBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRespondActivityTaskFailedBody'];
      };
    };
    WorkflowServiceRecordActivityTaskHeartbeatByIdBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceRecordActivityTaskHeartbeatByIdBody'];
      };
    };
    WorkflowServiceUnpauseActivityBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUnpauseActivityBody'];
      };
    };
    WorkflowServiceUpdateActivityOptionsBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateActivityOptionsBody'];
      };
    };
    WorkflowServiceStartBatchOperationBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceStartBatchOperationBody'];
      };
    };
    WorkflowServiceStopBatchOperationBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceStopBatchOperationBody'];
      };
    };
    WorkflowServiceSetCurrentDeploymentBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceSetCurrentDeploymentBody'];
      };
    };
    WorkflowServiceCreateScheduleBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceCreateScheduleBody'];
      };
    };
    WorkflowServiceUpdateScheduleBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateScheduleBody'];
      };
    };
    WorkflowServiceUpdateTaskQueueConfigBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateTaskQueueConfigBody'];
      };
    };
    WorkflowServiceUpdateNamespaceBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateNamespaceBody'];
      };
    };
    WorkflowServiceSetWorkerDeploymentCurrentVersionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceSetWorkerDeploymentCurrentVersionBody'];
      };
    };
    WorkflowServiceCreateWorkflowRuleBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceCreateWorkflowRuleBody'];
      };
    };
    WorkflowServiceTriggerWorkflowRuleBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceTriggerWorkflowRuleBody'];
      };
    };
    WorkflowServiceResetWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceResetWorkflowExecutionBody'];
      };
    };
    WorkflowServiceUpdateWorkflowExecutionOptionsBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceUpdateWorkflowExecutionOptionsBody'];
      };
    };
    WorkflowServiceSignalWithStartWorkflowExecutionBody: {
      content: {
        'application/json': components['schemas']['WorkflowServiceSignalWithStartWorkflowExecutionBody'];
      };
    };
    OperatorServiceUpdateNexusEndpointBody: {
      content: {
        'application/json': components['schemas']['OperatorServiceUpdateNexusEndpointBody'];
      };
    };
  };
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  GetClusterInfo2: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetClusterInfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListNamespaces2: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description By default namespaces in NAMESPACE_STATE_DELETED state are not included.
         *     Setting include_deleted to true will include deleted namespaces.
         *     Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet. */
        'namespaceFilter.includeDeleted'?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListNamespacesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RegisterNamespace2: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['v1RegisterNamespaceRequest'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RegisterNamespaceResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeNamespace2: {
    parameters: {
      query?: {
        id?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeNamespaceResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCanceled2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCanceledBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCanceledResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCanceledById2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCanceledByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCanceledByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCompleted2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCompletedBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCompletedResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCompletedById2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCompletedByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCompletedByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskFailed2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskFailedBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskFailedResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskFailedById2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskFailedByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskFailedByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RecordActivityTaskHeartbeat2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRecordActivityTaskHeartbeatBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RecordActivityTaskHeartbeatResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RecordActivityTaskHeartbeatById2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRecordActivityTaskHeartbeatByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RecordActivityTaskHeartbeatByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  PauseActivity2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServicePauseActivityBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1PauseActivityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ResetActivity2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceResetActivityBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ResetActivityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UnpauseActivity2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUnpauseActivityBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UnpauseActivityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateActivityOptions2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateActivityOptionsBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateActivityOptionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListArchivedWorkflowExecutions2: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListArchivedWorkflowExecutionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListBatchOperations2: {
    parameters: {
      query?: {
        /** @description List page size */
        pageSize?: number;
        /** @description Next page token */
        nextPageToken?: string;
      };
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListBatchOperationsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeBatchOperation2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeBatchOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  StartBatchOperation2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Job ID defines the unique ID for the batch job */
        jobId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceStartBatchOperationBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1StartBatchOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  StopBatchOperation2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceStopBatchOperationBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1StopBatchOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SetCurrentDeployment2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Different versions of the same worker service/application are related together by having a
         *     shared series name.
         *     Out of all deployments of a series, one can be designated as the current deployment, which
         *     receives new workflow executions and new tasks of workflows with
         *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
        'deployment.seriesName': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSetCurrentDeploymentBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SetCurrentDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetCurrentDeployment2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        seriesName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetCurrentDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListDeployments2: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description Optional. Use to filter based on exact series name match. */
        seriesName?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListDeploymentsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeDeployment2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Different versions of the same worker service/application are related together by having a
         *     shared series name.
         *     Out of all deployments of a series, one can be designated as the current deployment, which
         *     receives new workflow executions and new tasks of workflows with
         *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
        'deployment.seriesName': string;
        /** @description Build ID changes with each version of the worker when the worker program code and/or config
         *     changes. */
        'deployment.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetDeploymentReachability2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Different versions of the same worker service/application are related together by having a
         *     shared series name.
         *     Out of all deployments of a series, one can be designated as the current deployment, which
         *     receives new workflow executions and new tasks of workflows with
         *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
        'deployment.seriesName': string;
        /** @description Build ID changes with each version of the worker when the worker program code and/or config
         *     changes. */
        'deployment.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetDeploymentReachabilityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListSchedules2: {
    parameters: {
      query?: {
        /** @description How many to return at once. */
        maximumPageSize?: number;
        /** @description Token to get the next page of results. */
        nextPageToken?: string;
        /** @description Query to filter schedules. */
        query?: string;
      };
      header?: never;
      path: {
        /** @description The namespace to list schedules in. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListSchedulesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeSchedule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace of the schedule to describe. */
        namespace: string;
        /** @description The id of the schedule to describe. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CreateSchedule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace the schedule should be created in. */
        namespace: string;
        /** @description The id of the new schedule. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceCreateScheduleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CreateScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteSchedule2: {
    parameters: {
      query?: {
        /** @description The identity of the client who initiated this request. */
        identity?: string;
      };
      header?: never;
      path: {
        /** @description The namespace of the schedule to delete. */
        namespace: string;
        /** @description The id of the schedule to delete. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListScheduleMatchingTimes2: {
    parameters: {
      query?: {
        /** @description Time range to query. */
        startTime?: string;
        endTime?: string;
      };
      header?: never;
      path: {
        /** @description The namespace of the schedule to query. */
        namespace: string;
        /** @description The id of the schedule to query. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListScheduleMatchingTimesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  PatchSchedule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace of the schedule to patch. */
        namespace: string;
        /** @description The id of the schedule to patch. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServicePatchScheduleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1PatchScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateSchedule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace of the schedule to update. */
        namespace: string;
        /** @description The id of the schedule to update. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateScheduleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListSearchAttributes2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListSearchAttributesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeTaskQueue2: {
    parameters: {
      query?: {
        /** @description Default: TASK_QUEUE_KIND_NORMAL.
         *
         *      - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history
         *
         *     The task queue specified by the user is always a normal task queue. There can be as many
         *     workers as desired for a single normal task queue. All those workers may pick up tasks from
         *     that queue.
         *      - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are
         *     per-worker.
         *
         *     Sticky queues are created dynamically by each worker during their start up. They only exist
         *     for the lifetime of the worker process. Tasks in a sticky task queue are only available to
         *     the worker that created the sticky queue.
         *
         *     Sticky queues are only for workflow tasks. There are no sticky task queues for activities. */
        'taskQueue.kind'?:
          | 'TASK_QUEUE_KIND_UNSPECIFIED'
          | 'TASK_QUEUE_KIND_NORMAL'
          | 'TASK_QUEUE_KIND_STICKY';
        /** @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
         *     the normal task queue that the sticky worker is running on. */
        'taskQueue.normalName'?: string;
        /** @description If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
         *     Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
         *
         *      - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.
         *      - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.
         *      - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests. */
        taskQueueType?:
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS';
        /** @description Report stats for the requested task queue type(s). */
        reportStats?: boolean;
        /** @description Report Task Queue Config */
        reportConfig?: boolean;
        /** @description Deprecated, use `report_stats` instead.
         *     If true, the task queue status will be included in the response. */
        includeTaskQueueStatus?: boolean;
        /** @description Deprecated. ENHANCED mode is also being deprecated.
         *     Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
         *     Consult the documentation for each field to understand which mode it is supported in.
         *
         *      - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.
         *      - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info. */
        apiMode?:
          | 'DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED'
          | 'DESCRIBE_TASK_QUEUE_MODE_ENHANCED';
        /** @description Include specific Build IDs. */
        'versions.buildIds'?: string[];
        /** @description Include the unversioned queue. */
        'versions.unversioned'?: boolean;
        /** @description Include all active versions. A version is considered active if, in the last few minutes,
         *     it has had new tasks or polls, or it has been the subject of certain task queue API calls. */
        'versions.allActive'?: boolean;
        /** @description Deprecated (as part of the ENHANCED mode deprecation).
         *     Task queue types to report info about. If not specified, all types are considered.
         *
         *      - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.
         *      - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.
         *      - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests. */
        taskQueueTypes?: (
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS'
        )[];
        /** @description Deprecated (as part of the ENHANCED mode deprecation).
         *     Report list of pollers for requested task queue types and versions. */
        reportPollers?: boolean;
        /** @description Deprecated (as part of the ENHANCED mode deprecation).
         *     Report task reachability for the requested versions and all task types (task reachability is not reported
         *     per task type). */
        reportTaskReachability?: boolean;
      };
      header?: never;
      path: {
        namespace: string;
        'taskQueue.name': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeTaskQueueResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateTaskQueueConfig2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Selects the task queue to update. */
        taskQueue: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateTaskQueueConfigBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateTaskQueueConfigResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkerBuildIdCompatibility2: {
    parameters: {
      query?: {
        /** @description Limits how many compatible sets will be returned. Specify 1 to only return the current
         *     default major version set. 0 returns all sets. */
        maxSets?: number;
      };
      header?: never;
      path: {
        namespace: string;
        /** @description Must be set, the task queue to interrogate about worker id compatibility. */
        taskQueue: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkerBuildIdCompatibilityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkerVersioningRules2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        taskQueue: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkerVersioningRulesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateNamespace2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateNamespaceBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateNamespaceResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkerDeploymentVersion2: {
    parameters: {
      query?: {
        /** @description Deprecated. Use `deployment_version`. */
        version?: string;
        /** @description Report stats for task queues which have been polled by this version. */
        reportTaskQueueStats?: boolean;
      };
      header?: never;
      path: {
        namespace: string;
        /** @description Identifies the Worker Deployment this Version is part of. */
        'deploymentVersion.deploymentName': string;
        /** @description A unique identifier for this Version within the Deployment it is a part of.
         *     Not necessarily unique within the namespace.
         *     The combination of `deployment_name` and `build_id` uniquely identifies this
         *     Version within the namespace, because Deployment names are unique within a namespace. */
        'deploymentVersion.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkerDeploymentVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteWorkerDeploymentVersion2: {
    parameters: {
      query?: {
        /** @description Deprecated. Use `deployment_version`. */
        version?: string;
        /** @description Pass to force deletion even if the Version is draining. In this case the open pinned
         *     workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions. */
        skipDrainage?: boolean;
        /** @description Optional. The identity of the client who initiated this request. */
        identity?: string;
      };
      header?: never;
      path: {
        namespace: string;
        /** @description Identifies the Worker Deployment this Version is part of. */
        'deploymentVersion.deploymentName': string;
        /** @description A unique identifier for this Version within the Deployment it is a part of.
         *     Not necessarily unique within the namespace.
         *     The combination of `deployment_name` and `build_id` uniquely identifies this
         *     Version within the namespace, because Deployment names are unique within a namespace. */
        'deploymentVersion.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteWorkerDeploymentVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkerDeploymentVersionMetadata2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Identifies the Worker Deployment this Version is part of. */
        'deploymentVersion.deploymentName': string;
        /** @description A unique identifier for this Version within the Deployment it is a part of.
         *     Not necessarily unique within the namespace.
         *     The combination of `deployment_name` and `build_id` uniquely identifies this
         *     Version within the namespace, because Deployment names are unique within a namespace. */
        'deploymentVersion.buildId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkerDeploymentVersionMetadataResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkerDeployments2: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkerDeploymentsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkerDeployment2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkerDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteWorkerDeployment2: {
    parameters: {
      query?: {
        /** @description Optional. The identity of the client who initiated this request. */
        identity?: string;
      };
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteWorkerDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SetWorkerDeploymentCurrentVersion2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSetWorkerDeploymentCurrentVersionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SetWorkerDeploymentCurrentVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SetWorkerDeploymentRampingVersion2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSetWorkerDeploymentRampingVersionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SetWorkerDeploymentRampingVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkerTaskReachability2: {
    parameters: {
      query?: {
        /** @description Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
         *     The number of build ids that can be queried in a single API call is limited.
         *     Open source users can adjust this limit by setting the server's dynamic config value for
         *     `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store. */
        buildIds?: string[];
        /** @description Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
         *     build ids in the namespace.
         *     Must specify at least one task queue if querying for an unversioned worker.
         *     The number of task queues that the server will fetch reachability information for is limited.
         *     See the `GetWorkerTaskReachabilityResponse` documentation for more information. */
        taskQueues?: string[];
        /** @description Type of reachability to query for.
         *     `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
         *     Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
         *     Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
         *     unspecified.
         *     See the TaskReachability docstring for information about each enum variant.
         *
         *      - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
         *      - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
         *     should *not* be retired.
         *     This enum value does not distinguish between open and closed workflows.
         *      - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
         *     should *not* be retired.
         *      - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
         *     retired dependending on application requirements. For example, if there's no need to query closed workflows. */
        reachability?:
          | 'TASK_REACHABILITY_UNSPECIFIED'
          | 'TASK_REACHABILITY_NEW_WORKFLOWS'
          | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
          | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
          | 'TASK_REACHABILITY_CLOSED_WORKFLOWS';
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkerTaskReachabilityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkers2: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description `query` in ListWorkers is used to filter workers based on worker status info.
         *     The following worker status attributes are expected are supported as part of the query:
         *     * WorkerInstanceKey
         *     * WorkerIdentity
         *     * HostName
         *     * TaskQueue
         *     * DeploymentName
         *     * BuildId
         *     * SdkName
         *     * SdkVersion
         *     * StartTime
         *     * LastHeartbeatTime
         *     * Status
         *     Currently metrics are not supported as a part of ListWorkers query. */
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkersResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorker2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
        /** @description Worker instance key to describe. */
        workerInstanceKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkerResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  FetchWorkerConfig2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceFetchWorkerConfigBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1FetchWorkerConfigResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RecordWorkerHeartbeat2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRecordWorkerHeartbeatBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RecordWorkerHeartbeatResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkerConfig2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkerConfigBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkerConfigResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CountWorkflowExecutions2: {
    parameters: {
      query?: {
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CountWorkflowExecutionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkflowRules2: {
    parameters: {
      query?: {
        nextPageToken?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkflowRulesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CreateWorkflowRule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceCreateWorkflowRuleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CreateWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkflowRule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description User-specified ID of the rule to read. Unique within the namespace. */
        ruleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteWorkflowRule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description ID of the rule to delete. Unique within the namespace. */
        ruleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkflowExecutions2: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkflowExecutionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ExecuteMultiOperation2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceExecuteMultiOperationBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ExecuteMultiOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkflowExecution2: {
    parameters: {
      query?: {
        'execution.runId'?: string;
      };
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkflowExecutionHistory2: {
    parameters: {
      query?: {
        'execution.runId'?: string;
        maximumPageSize?: number;
        /** @description If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
         *     these, it should be passed here to fetch the next page. */
        nextPageToken?: string;
        /** @description If set to true, the RPC call will not resolve until there is a new event which matches
         *     the `history_event_filter_type`, or a timeout is hit. */
        waitNewEvent?: boolean;
        /** @description Filter returned events such that they match the specified filter type.
         *     Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT. */
        historyEventFilterType?:
          | 'HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED'
          | 'HISTORY_EVENT_FILTER_TYPE_ALL_EVENT'
          | 'HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT';
        skipArchival?: boolean;
      };
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkflowExecutionHistoryResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkflowExecutionHistoryReverse2: {
    parameters: {
      query?: {
        'execution.runId'?: string;
        maximumPageSize?: number;
        nextPageToken?: string;
      };
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkflowExecutionHistoryReverseResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  QueryWorkflow2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
        /** @description The workflow-author-defined identifier of the query. Typically a function name. */
        'query.queryType': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceQueryWorkflowBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1QueryWorkflowResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  TriggerWorkflowRule2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceTriggerWorkflowRuleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1TriggerWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RequestCancelWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRequestCancelWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RequestCancelWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ResetWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceResetWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ResetWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SignalWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSignalWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SignalWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  TerminateWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceTerminateWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1TerminateWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkflowExecutionOptions2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace name of the target Workflow. */
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkflowExecutionOptionsBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkflowExecutionOptionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace name of the target Workflow. */
        namespace: string;
        'workflowExecution.workflowId': string;
        /** @description The name of the Update handler to invoke on the target Workflow. */
        'request.input.name': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  StartWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        workflowId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceStartWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1StartWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SignalWithStartWorkflowExecution2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        workflowId: string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSignalWithStartWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SignalWithStartWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListNexusEndpoints2: {
    parameters: {
      query?: {
        pageSize?: number;
        /** @description To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's
         *     response, the token will be empty if there's no other page.
         *     Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size. */
        nextPageToken?: string;
        /** @description Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results. */
        name?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListNexusEndpointsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CreateNexusEndpoint2: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['v1CreateNexusEndpointRequest'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CreateNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetNexusEndpoint2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteNexusEndpoint2: {
    parameters: {
      query?: {
        /** @description Data version for this endpoint. Must match current version. */
        version?: string;
      };
      header?: never;
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateNexusEndpoint2: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['OperatorServiceUpdateNexusEndpointBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetSystemInfo2: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetSystemInfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetClusterInfo: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetClusterInfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListNamespaces: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description By default namespaces in NAMESPACE_STATE_DELETED state are not included.
         *     Setting include_deleted to true will include deleted namespaces.
         *     Note: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet. */
        'namespaceFilter.includeDeleted'?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListNamespacesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RegisterNamespace: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['v1RegisterNamespaceRequest'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RegisterNamespaceResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeNamespace: {
    parameters: {
      query?: {
        id?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeNamespaceResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListSearchAttributes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListSearchAttributesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateNamespace: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateNamespaceBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateNamespaceResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListNexusEndpoints: {
    parameters: {
      query?: {
        pageSize?: number;
        /** @description To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's
         *     response, the token will be empty if there's no other page.
         *     Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size. */
        nextPageToken?: string;
        /** @description Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results. */
        name?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListNexusEndpointsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CreateNexusEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['v1CreateNexusEndpointRequest'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CreateNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetNexusEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteNexusEndpoint: {
    parameters: {
      query?: {
        /** @description Data version for this endpoint. Must match current version. */
        version?: string;
      };
      header?: never;
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateNexusEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Server-generated unique endpoint ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['OperatorServiceUpdateNexusEndpointBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateNexusEndpointResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCanceled: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCanceledBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCanceledResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCanceledById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCanceledByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCanceledByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCompleted: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCompletedBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCompletedResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskCompletedById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskCompletedByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskCompletedByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskFailed: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskFailedBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskFailedResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RespondActivityTaskFailedById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRespondActivityTaskFailedByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RespondActivityTaskFailedByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RecordActivityTaskHeartbeat: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRecordActivityTaskHeartbeatBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RecordActivityTaskHeartbeatResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RecordActivityTaskHeartbeatById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRecordActivityTaskHeartbeatByIdBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RecordActivityTaskHeartbeatByIdResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  PauseActivity: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServicePauseActivityBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1PauseActivityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ResetActivity: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceResetActivityBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ResetActivityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UnpauseActivity: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUnpauseActivityBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UnpauseActivityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateActivityOptions: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace of the workflow which scheduled this activity */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateActivityOptionsBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateActivityOptionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListArchivedWorkflowExecutions: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListArchivedWorkflowExecutionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListBatchOperations: {
    parameters: {
      query?: {
        /** @description List page size */
        pageSize?: number;
        /** @description Next page token */
        nextPageToken?: string;
      };
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListBatchOperationsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeBatchOperation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeBatchOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  StartBatchOperation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Job ID defines the unique ID for the batch job */
        jobId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceStartBatchOperationBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1StartBatchOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  StopBatchOperation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace that contains the batch operation */
        namespace: string;
        /** @description Batch job id */
        jobId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceStopBatchOperationBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1StopBatchOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SetCurrentDeployment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Different versions of the same worker service/application are related together by having a
         *     shared series name.
         *     Out of all deployments of a series, one can be designated as the current deployment, which
         *     receives new workflow executions and new tasks of workflows with
         *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
        'deployment.seriesName': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSetCurrentDeploymentBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SetCurrentDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetCurrentDeployment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        seriesName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetCurrentDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListDeployments: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description Optional. Use to filter based on exact series name match. */
        seriesName?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListDeploymentsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeDeployment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Different versions of the same worker service/application are related together by having a
         *     shared series name.
         *     Out of all deployments of a series, one can be designated as the current deployment, which
         *     receives new workflow executions and new tasks of workflows with
         *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
        'deployment.seriesName': string;
        /** @description Build ID changes with each version of the worker when the worker program code and/or config
         *     changes. */
        'deployment.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetDeploymentReachability: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Different versions of the same worker service/application are related together by having a
         *     shared series name.
         *     Out of all deployments of a series, one can be designated as the current deployment, which
         *     receives new workflow executions and new tasks of workflows with
         *     `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior. */
        'deployment.seriesName': string;
        /** @description Build ID changes with each version of the worker when the worker program code and/or config
         *     changes. */
        'deployment.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetDeploymentReachabilityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListSchedules: {
    parameters: {
      query?: {
        /** @description How many to return at once. */
        maximumPageSize?: number;
        /** @description Token to get the next page of results. */
        nextPageToken?: string;
        /** @description Query to filter schedules. */
        query?: string;
      };
      header?: never;
      path: {
        /** @description The namespace to list schedules in. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListSchedulesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeSchedule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace of the schedule to describe. */
        namespace: string;
        /** @description The id of the schedule to describe. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CreateSchedule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace the schedule should be created in. */
        namespace: string;
        /** @description The id of the new schedule. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceCreateScheduleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CreateScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteSchedule: {
    parameters: {
      query?: {
        /** @description The identity of the client who initiated this request. */
        identity?: string;
      };
      header?: never;
      path: {
        /** @description The namespace of the schedule to delete. */
        namespace: string;
        /** @description The id of the schedule to delete. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListScheduleMatchingTimes: {
    parameters: {
      query?: {
        /** @description Time range to query. */
        startTime?: string;
        endTime?: string;
      };
      header?: never;
      path: {
        /** @description The namespace of the schedule to query. */
        namespace: string;
        /** @description The id of the schedule to query. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListScheduleMatchingTimesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  PatchSchedule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace of the schedule to patch. */
        namespace: string;
        /** @description The id of the schedule to patch. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServicePatchScheduleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1PatchScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateSchedule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace of the schedule to update. */
        namespace: string;
        /** @description The id of the schedule to update. */
        scheduleId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateScheduleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateScheduleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeTaskQueue: {
    parameters: {
      query?: {
        /** @description Default: TASK_QUEUE_KIND_NORMAL.
         *
         *      - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history
         *
         *     The task queue specified by the user is always a normal task queue. There can be as many
         *     workers as desired for a single normal task queue. All those workers may pick up tasks from
         *     that queue.
         *      - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are
         *     per-worker.
         *
         *     Sticky queues are created dynamically by each worker during their start up. They only exist
         *     for the lifetime of the worker process. Tasks in a sticky task queue are only available to
         *     the worker that created the sticky queue.
         *
         *     Sticky queues are only for workflow tasks. There are no sticky task queues for activities. */
        'taskQueue.kind'?:
          | 'TASK_QUEUE_KIND_UNSPECIFIED'
          | 'TASK_QUEUE_KIND_NORMAL'
          | 'TASK_QUEUE_KIND_STICKY';
        /** @description Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
         *     the normal task queue that the sticky worker is running on. */
        'taskQueue.normalName'?: string;
        /** @description If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
         *     Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
         *
         *      - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.
         *      - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.
         *      - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests. */
        taskQueueType?:
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS';
        /** @description Report stats for the requested task queue type(s). */
        reportStats?: boolean;
        /** @description Report Task Queue Config */
        reportConfig?: boolean;
        /** @description Deprecated, use `report_stats` instead.
         *     If true, the task queue status will be included in the response. */
        includeTaskQueueStatus?: boolean;
        /** @description Deprecated. ENHANCED mode is also being deprecated.
         *     Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
         *     Consult the documentation for each field to understand which mode it is supported in.
         *
         *      - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.
         *      - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info. */
        apiMode?:
          | 'DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED'
          | 'DESCRIBE_TASK_QUEUE_MODE_ENHANCED';
        /** @description Include specific Build IDs. */
        'versions.buildIds'?: string[];
        /** @description Include the unversioned queue. */
        'versions.unversioned'?: boolean;
        /** @description Include all active versions. A version is considered active if, in the last few minutes,
         *     it has had new tasks or polls, or it has been the subject of certain task queue API calls. */
        'versions.allActive'?: boolean;
        /** @description Deprecated (as part of the ENHANCED mode deprecation).
         *     Task queue types to report info about. If not specified, all types are considered.
         *
         *      - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.
         *      - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.
         *      - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests. */
        taskQueueTypes?: (
          | 'TASK_QUEUE_TYPE_UNSPECIFIED'
          | 'TASK_QUEUE_TYPE_WORKFLOW'
          | 'TASK_QUEUE_TYPE_ACTIVITY'
          | 'TASK_QUEUE_TYPE_NEXUS'
        )[];
        /** @description Deprecated (as part of the ENHANCED mode deprecation).
         *     Report list of pollers for requested task queue types and versions. */
        reportPollers?: boolean;
        /** @description Deprecated (as part of the ENHANCED mode deprecation).
         *     Report task reachability for the requested versions and all task types (task reachability is not reported
         *     per task type). */
        reportTaskReachability?: boolean;
      };
      header?: never;
      path: {
        namespace: string;
        'taskQueue.name': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeTaskQueueResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateTaskQueueConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Selects the task queue to update. */
        taskQueue: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateTaskQueueConfigBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateTaskQueueConfigResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkerBuildIdCompatibility: {
    parameters: {
      query?: {
        /** @description Limits how many compatible sets will be returned. Specify 1 to only return the current
         *     default major version set. 0 returns all sets. */
        maxSets?: number;
      };
      header?: never;
      path: {
        namespace: string;
        /** @description Must be set, the task queue to interrogate about worker id compatibility. */
        taskQueue: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkerBuildIdCompatibilityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkerVersioningRules: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        taskQueue: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkerVersioningRulesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkerDeploymentVersion: {
    parameters: {
      query?: {
        /** @description Deprecated. Use `deployment_version`. */
        version?: string;
        /** @description Report stats for task queues which have been polled by this version. */
        reportTaskQueueStats?: boolean;
      };
      header?: never;
      path: {
        namespace: string;
        /** @description Identifies the Worker Deployment this Version is part of. */
        'deploymentVersion.deploymentName': string;
        /** @description A unique identifier for this Version within the Deployment it is a part of.
         *     Not necessarily unique within the namespace.
         *     The combination of `deployment_name` and `build_id` uniquely identifies this
         *     Version within the namespace, because Deployment names are unique within a namespace. */
        'deploymentVersion.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkerDeploymentVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteWorkerDeploymentVersion: {
    parameters: {
      query?: {
        /** @description Deprecated. Use `deployment_version`. */
        version?: string;
        /** @description Pass to force deletion even if the Version is draining. In this case the open pinned
         *     workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions. */
        skipDrainage?: boolean;
        /** @description Optional. The identity of the client who initiated this request. */
        identity?: string;
      };
      header?: never;
      path: {
        namespace: string;
        /** @description Identifies the Worker Deployment this Version is part of. */
        'deploymentVersion.deploymentName': string;
        /** @description A unique identifier for this Version within the Deployment it is a part of.
         *     Not necessarily unique within the namespace.
         *     The combination of `deployment_name` and `build_id` uniquely identifies this
         *     Version within the namespace, because Deployment names are unique within a namespace. */
        'deploymentVersion.buildId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteWorkerDeploymentVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkerDeploymentVersionMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description Identifies the Worker Deployment this Version is part of. */
        'deploymentVersion.deploymentName': string;
        /** @description A unique identifier for this Version within the Deployment it is a part of.
         *     Not necessarily unique within the namespace.
         *     The combination of `deployment_name` and `build_id` uniquely identifies this
         *     Version within the namespace, because Deployment names are unique within a namespace. */
        'deploymentVersion.buildId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkerDeploymentVersionMetadataResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkerDeployments: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkerDeploymentsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkerDeployment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkerDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteWorkerDeployment: {
    parameters: {
      query?: {
        /** @description Optional. The identity of the client who initiated this request. */
        identity?: string;
      };
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteWorkerDeploymentResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SetWorkerDeploymentCurrentVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSetWorkerDeploymentCurrentVersionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SetWorkerDeploymentCurrentVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SetWorkerDeploymentRampingVersion: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        deploymentName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSetWorkerDeploymentRampingVersionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SetWorkerDeploymentRampingVersionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkerTaskReachability: {
    parameters: {
      query?: {
        /** @description Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
         *     The number of build ids that can be queried in a single API call is limited.
         *     Open source users can adjust this limit by setting the server's dynamic config value for
         *     `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store. */
        buildIds?: string[];
        /** @description Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
         *     build ids in the namespace.
         *     Must specify at least one task queue if querying for an unversioned worker.
         *     The number of task queues that the server will fetch reachability information for is limited.
         *     See the `GetWorkerTaskReachabilityResponse` documentation for more information. */
        taskQueues?: string[];
        /** @description Type of reachability to query for.
         *     `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
         *     Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
         *     Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
         *     unspecified.
         *     See the TaskReachability docstring for information about each enum variant.
         *
         *      - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
         *      - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
         *     should *not* be retired.
         *     This enum value does not distinguish between open and closed workflows.
         *      - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
         *     should *not* be retired.
         *      - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
         *     retired dependending on application requirements. For example, if there's no need to query closed workflows. */
        reachability?:
          | 'TASK_REACHABILITY_UNSPECIFIED'
          | 'TASK_REACHABILITY_NEW_WORKFLOWS'
          | 'TASK_REACHABILITY_EXISTING_WORKFLOWS'
          | 'TASK_REACHABILITY_OPEN_WORKFLOWS'
          | 'TASK_REACHABILITY_CLOSED_WORKFLOWS';
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkerTaskReachabilityResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkers: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        /** @description `query` in ListWorkers is used to filter workers based on worker status info.
         *     The following worker status attributes are expected are supported as part of the query:
         *     * WorkerInstanceKey
         *     * WorkerIdentity
         *     * HostName
         *     * TaskQueue
         *     * DeploymentName
         *     * BuildId
         *     * SdkName
         *     * SdkVersion
         *     * StartTime
         *     * LastHeartbeatTime
         *     * Status
         *     Currently metrics are not supported as a part of ListWorkers query. */
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkersResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorker: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
        /** @description Worker instance key to describe. */
        workerInstanceKey: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkerResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  FetchWorkerConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceFetchWorkerConfigBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1FetchWorkerConfigResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RecordWorkerHeartbeat: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRecordWorkerHeartbeatBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RecordWorkerHeartbeatResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkerConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Namespace this worker belongs to. */
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkerConfigBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkerConfigResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CountWorkflowExecutions: {
    parameters: {
      query?: {
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CountWorkflowExecutionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkflowRules: {
    parameters: {
      query?: {
        nextPageToken?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkflowRulesResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  CreateWorkflowRule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceCreateWorkflowRuleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1CreateWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkflowRule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description User-specified ID of the rule to read. Unique within the namespace. */
        ruleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DeleteWorkflowRule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        /** @description ID of the rule to delete. Unique within the namespace. */
        ruleId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DeleteWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ListWorkflowExecutions: {
    parameters: {
      query?: {
        pageSize?: number;
        nextPageToken?: string;
        query?: string;
      };
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ListWorkflowExecutionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ExecuteMultiOperation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceExecuteMultiOperationBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ExecuteMultiOperationResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  DescribeWorkflowExecution: {
    parameters: {
      query?: {
        'execution.runId'?: string;
      };
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1DescribeWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkflowExecutionHistory: {
    parameters: {
      query?: {
        'execution.runId'?: string;
        maximumPageSize?: number;
        /** @description If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
         *     these, it should be passed here to fetch the next page. */
        nextPageToken?: string;
        /** @description If set to true, the RPC call will not resolve until there is a new event which matches
         *     the `history_event_filter_type`, or a timeout is hit. */
        waitNewEvent?: boolean;
        /** @description Filter returned events such that they match the specified filter type.
         *     Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT. */
        historyEventFilterType?:
          | 'HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED'
          | 'HISTORY_EVENT_FILTER_TYPE_ALL_EVENT'
          | 'HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT';
        skipArchival?: boolean;
      };
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkflowExecutionHistoryResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetWorkflowExecutionHistoryReverse: {
    parameters: {
      query?: {
        'execution.runId'?: string;
        maximumPageSize?: number;
        nextPageToken?: string;
      };
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetWorkflowExecutionHistoryReverseResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  QueryWorkflow: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
        /** @description The workflow-author-defined identifier of the query. Typically a function name. */
        'query.queryType': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceQueryWorkflowBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1QueryWorkflowResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  TriggerWorkflowRule: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'execution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceTriggerWorkflowRuleBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1TriggerWorkflowRuleResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  RequestCancelWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceRequestCancelWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1RequestCancelWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  ResetWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceResetWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1ResetWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SignalWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSignalWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SignalWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  TerminateWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceTerminateWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1TerminateWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkflowExecutionOptions: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace name of the target Workflow. */
        namespace: string;
        'workflowExecution.workflowId': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkflowExecutionOptionsBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkflowExecutionOptionsResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  UpdateWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The namespace name of the target Workflow. */
        namespace: string;
        'workflowExecution.workflowId': string;
        /** @description The name of the Update handler to invoke on the target Workflow. */
        'request.input.name': string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceUpdateWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1UpdateWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  StartWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        workflowId: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceStartWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1StartWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  SignalWithStartWorkflowExecution: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        namespace: string;
        workflowId: string;
        /** @description The workflow author-defined name of the signal to send to the workflow */
        signalName: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['WorkflowServiceSignalWithStartWorkflowExecutionBody'];
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1SignalWithStartWorkflowExecutionResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
  GetSystemInfo: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A successful response. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['v1GetSystemInfoResponse'];
        };
      };
      /** @description An unexpected error response. */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['rpcStatus'];
        };
      };
    };
  };
}
